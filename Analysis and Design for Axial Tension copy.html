<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Principle of Steel Design</title>
    <link rel="stylesheet" href="style.css"/>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
    <header>
        <div class="header"><b>STEEL DESIGN HELPER</b></div>
        
    </header>

    <nav class="navbar">
        <div class="ADcon">
            <a class="con" href="index.html">|HOME|</a>
            <a class="con" id="active" href="Analysis and Design for Axial Tension.html">|Analysis and Design for Axial Tension|</a>
            <a class="con" href="Analysis and Design for Axial Compression.html">|Analysis and Design for Axial Compression|</a>
            <a class="con" href="Analysis and Design of Members for Bending.html">|Analysis and Design of Members for Bending|</a>
            <a class="con" href="Shear Strength of Structural Member.html">|Shear Strength of Structural Member|</a>
        </div>
    </nav>

    <div class="AnalysisAxialTen">
        <div class="AxielT" style="display: in;">
            <h1 >Analysis of Tension Member</h1>
        </div>
        <div class="AxialTenionmember">

        <div class="AnalysisTen">
            <div id="ASTMSPEC" class="AxialTen">
                <form>
                    <h2>ASTM SPECIFICATION</h2>
                    <select id="ASpecA">
                        <option value="A36">A36</option>
                        <option value="A572Gr.42">A572 Gr. 42</option>
                        <option value="A572Gr.50">A572 Gr. 50</option>
                        <option value="A572Gr.55">A572 Gr. 55</option>
                        <option value="A572Gr.60">A572 Gr. 60</option>
                        <option value="A572Gr.65">A572 Gr. 65</option>
                        <option value="A588Gr.42">A588 Gr. 42</option>
                        <option value="A588Gr.46">A588 Gr. 46</option>
                        <option value="A588Gr.50">A588 Gr. 50</option>
                        <option value="A687">A687</option>
                        <option value="A992">A992</option>
                    </select>

                    <h2>HOLE</h2>
                    <label>Diameter of bolts:</label>
                    <input type="number" id="dholeA" step="0.001" placeholder="inches" required><br>
                    <label>Number of holes per column (max 6):</label>
                    <input type="number" id="nholeC" min="1" max="6" value="3"/><br>
                    <label>Number of holes per row (max 6):</label>
                    <input type="number" id="nholeR" min="1" max="6" value="3"/>

                    <h2>SHEAR LAG FACTOR</h2>
                    <select id="ulagCase">
                        <option value="1">Case 1</option>
                        <option value="2">Case 2</option>
                        <option value="7">Case 7</option>
                        <option value="8">Case 8</option>
                    </select>
                    <label>Length (in):</label>
                    <input type="number" id="lengthA" placeholder="Length">

                    <h2>STEEL</h2>
                    <label>Shape:</label>
                    <select id="shapeA">
                        <option value="W">W</option>
                         <option value="W">L</option>
                    </select>
                    <label>Dimension:</label>
                    <input type="text" id="dimA" placeholder="12X45" required>

                    <div class="blockstag-column">
                        <div id="blockShearInputs" style="display:none;">
                            <label>Agv:</label><input type="number" id="Agv" placeholder="in²" step="0.001"><br>
                            <label>Anv:</label><input type="number" id="Anv" placeholder="in²" step="0.001"><br>
                            <label>Ant:</label><input type="number" id="Ant" placeholder="in²" step="0.001">
                        </div>
                    </div>

                    <h2>CHOOSE ONE OPTION ONLY</h2>
                    <label><input type="radio" name="designOption" value="none" checked> No Block Shear or Stagger</label><br>
                    <label><input type="radio" name="designOption" value="block"> Include Block Shear Only</label><br>
                    <label><input type="radio" name="designOption" value="stagger"> Include Staggered Holes Only</label><br>

                    <input type="button" class="Calculate" value="Calculate">

                </form>
                
            </div>

            <div class="AxialTenR" id="Result">
                <div class="YS"><div class="RESULT"><p class="YSt">GROSS CROSS SECTION:</p><p id="AG" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">NET AREA:</p><p id="AE" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">YIELDING IN GROSS CROSS SECTION: </p><p id="YC" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">FRACTURE IN EFFECTIVE NET AREA:</p><p id="FS" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">LRFD:</p><p id="LRFD" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">ASD:</p><p id="ASD" style="color:red;"></p></div></div>
                <!-- New result display for staggered hole calculations -->
                <div class="YS" id="failurePathResult" style="display:none;">
                    <div class="RESULT"><p class="YSt">ZIGZAG FAILURE PATH:</p><p id="criticalPath" style="color:red;"></p></div>
                </div>
                <div class="YS" id="staggerReductionResult" style="display:none;">
                    <div class="RESULT"><p class="YSt">STAGGER REDUCTION:</p><p id="staggerReduction" style="color:red;"></p></div>
                </div>
                <div></div>
            </div>
        </div>

        <div id="shearDiv" class="BLOCKSTAGGER" style="display:none;">
            

            <div id="column-inputs">
                <h3>Remove Specific Hole</h3>
                <div class="control-section">
                    <div class="control-group">
                        <label for="removeRow">Row (1–6):</label>
                        <input type="number" id="removeRow" min="1" max="6" placeholder="1–6">
                        
                        <label for="removeCol">Column (1–6):</label>
                        <input type="number" id="removeCol" min="1" max="6" placeholder="1–6">
                        
                        <button onclick="removeSpecificHole()">Remove Hole</button>
                    </div>
            
                    <div class="control-group">
                        <label for="removeHoleCol">Remove Entire Column (1–6):</label>
                        <input type="number" id="removeHoleCol" min="1" max="6" placeholder="Column #">
                        <button onclick="removeHoleColumn()">Remove Column</button>
                    </div>
            
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button class="restore-btn" onclick="restoreAllHoles()">Restore All Holes</button>
                    </div>
            
                    <div class="control-group">
                        <label for="spacingS">Horizontal spacing (s):</label>
                        <input type="number" id="spacingS" value="2" step="0.1" class="stagger-input"> in
            
                        <label for="spacingG">Vertical spacing (g):</label>
                        <input type="number" id="spacingG" value="1.5" step="0.1" class="gauge-input"> in
                    </div>
                </div>
            
                <div id="dynamicFlange" style="position:relative; width:400px; height:300px; border:2px solid black; background:#f0f0f0; margin-top:20px;"></div>
            </div>
        </div>
   
        <div class="DesignAxialTen">
        <hr>
        <div class="AxialD">
            <h1 style="text-align: center;">Design of Tension Member</h1>
        </div>
        <div class="DesignT">
            <div class="DesignTenData">
                
                <div>
            
                <form action="">
                    <div class="input-group">
                        <label for="designMethod">Design Method:</label>
                        <select id="designMethod">
                            <option value="LRFD">LRFD</option>
                            <option value="ASD">ASD</option>
                        </select>
                    </div>
                    
                    <label>ASTM Specification</label>
                    <select id="ASpecD" name="ASTM SPECIFICATION">
                        <option value="A36">A36</option>
                        <option value="A572Gr.42">A572 Gr. 42</option>
                        <option value="A572Gr.50">A572 Gr. 50</option>
                        <option value="A572Gr.55">A572 Gr. 55</option>
                        <option value="A572Gr.60">A572 Gr. 60</option>
                        <option value="A572Gr.65">A572 Gr. 65</option>
                        <option value="A588Gr.42">A588 Gr. 42</option>
                        <option value="A588Gr.46">A588 Gr. 46</option>
                        <option value="A588Gr.50">A588 Gr. 50</option>
                        <option value="A687">A687</option>
                        <option value="A992">A992</option>
                       
                    </select>
                </div>
                <div>
                    Shear Lag:
                    <select id="ulagCase"> 
                        <option value="1">Case 1</option>
                        <option value="2">Case 2</option>
                        <option value="7">Case 7</option>
                        <option value="8">Case 8</option>
                    </select>
                 </div>
                 <div>

                    <label for="DeadDload">Dead Load:</label>
                    <input id="Dload" type="number" placeholder="kips">
                </div>
                <div>
                    <label for="Lload">Live Load:</label>
                    <input id="Lload" type="number" placeholder="kips">
                 </div>
                 <div>
                    <label for="length">Length:</label>
                    
                    <input id="LenghtD" type="number" placeholder="ft."  step="0.001">
                </div>
                    <div>

                    <label for="dholeD"  >Diameter  of Bolts:</label>
                    <input id="dholeD" typ="numebr" placeholder="in."  step="0.001">
                    </div>  

                    
                    <div><label>number of holes</label>
                    <input class="nholeD" placeholder="in." type="number" > </div>
                   

                    
            </form>
             <button class="Design" id="design">DESIGN</button> 



            
            </div>
    

        </div>

    </div>
    <div class="DesignTRes">
        <div class="DesignCalcT">
            
            <h1>Design Calculation</h1>
            <div class="LRFDdis">
                <H2>Step 1: Load Combinations</H2>

            <h4>LRFD Load Combination: 1.2D + 1.6L=<p id="LRFDdesignComb"></p></h4> <h4>ASD Load Combination: 1.4D =<p id="ASDdesignComb"></p></h4>
            </div> 
        </div>    
            <div class="DesignCalcT">
            <h2>Step 2: Required Area Calculation</h2>
            <h3>For Yielding (LRFD):</h3>
            <h4>Pu ≤ φPn = φFyAg <br>
                Ag ≥ Pu / (φFy) = <p id="LRFDYielding"></p></h4>
                <h3>For Yielding (ASD):</h3>
            <h4>TnΩ = FyAg/Ω = FyAg /1.67 <br>
                Ag ≥ Pu / (φFy) = <p id="ASDYielding"></p></h4>
                <h3>For Fracture (LRFD):</h3>
                <h4>Pu ≤ φPn = φFuAe = <p id="LRFDFracture"></p></p></h4>
                <h3>For Fracture (ASD):</h3>
                <h4>Tn/Ω = FuAe/Ω = FuAe/2.00 <p id="ASDFracture"></p></p></h4>

            <H3 >Controlling Ag requirement: <p class="controlR"></p></H3>     
        </div>
                                <div class="DesignCon">
                                                     <div class="recommended-shapes">
                 <h2>Recommended W Shapes</h2>
                <p>The following shapes provide sufficient area for the tension member:</p>
                
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Shape</th>
                             <th>ry</th>
                            <th>Area Gross (in²)</th>
                            <th>Demand</th>
                            <th>Weight (lb/ft)</th>
                            <th>Ahole</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td id="rank1"></td>
                             <td id="ry1"></td>
                            <td id="Shape1"></td>
                            <td id="AreaG1"></td>
                            <td id="D1"></td>
                            <td id="Weight1"></td>
                            <td id="Ahole1"></td>
                            <td id="Status1"></td>
                        </tr>
                        <tr>
                            <td id="rank2"></td>
                             <td id="ry2"></td>
                            <td id="Shape2"></td>
                            <td id="AreaG2"></td>
                            <td id="D2"></td>
                            <td id="Weight2"></td>
                            <td id="Ahole2"></td>
                            <td id="Status2"></td>
                        </tr>
                        <tr>
                            <td id="rank3"></td>
                             <td id="ry3"></td>
                            <td id="Shape3"></td>
                            <td id="AreaG3"></td>
                            <td id="D3"></td>
                            <td id="Weight3"></td>
                            <td id="Ahole3"></td>
                            <td id="Status3"></td>
                        </tr>
                        <tr>
                            <td id="rank4"></td>
                             <td id="ry4"></td>
                            <td id="Shape4"></td>
                            <td id="AreaG4"></td>
                            <td id="D4"></td>
                            <td id="Weight4"></td>
                            <td id="Ahole4"></td>
                            <td id="Status4"></td>
                        </tr>
                        
                    </tbody>
                </table>
                
                
                
               
                                        </div>
                                                    </div>

        
            
 
   
   
    </div>
</div>
    <script>
    
    // Add a loading state

    let steelData = {}; // Define steelData object if not already defined elsewhere

    function loadExcelData() {
        console.log("Loading Excel data...");
        dataLoaded = false;
        
        // Show loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.id = 'loading-indicator';
        loadingIndicator.innerHTML = 'Loading steel section data...';
        loadingIndicator.style.position = 'fixed';
        loadingIndicator.style.top = '10px';
        loadingIndicator.style.right = '10px';
        loadingIndicator.style.padding = '5px 10px';
        loadingIndicator.style.backgroundColor = '#ffe0e0';
        loadingIndicator.style.border = '1px solid #ffcccc';
        loadingIndicator.style.borderRadius = '3px';
        loadingIndicator.style.zIndex = '1000';
        document.body.appendChild(loadingIndicator);
        
        fetch('ASTMSPEC.xlsx')
            .then(res => res.arrayBuffer())
            .then(data => {
                const workbook = XLSX.read(data, { type: 'array' });
                const shapeSheet = workbook.Sheets[workbook.SheetNames[1]];
                const shapeRows = XLSX.utils.sheet_to_json(shapeSheet);

                console.log("Excel data loaded, processing", shapeRows.length, "rows");
                
                shapeRows.forEach(row => {
                    if (row["AISC_Manual_Label"]) {
                        const label = row["AISC_Manual_Label"].trim().toUpperCase().replace(/\s/g, '');
                        
                        // Store data based on section type
                        if (label.startsWith('W')) {
                        // W shape (wide flange)
                        steelData[label] = {
                            type: 'W',
                            A: parseFloat(row.A),
                            tw: parseFloat(row.tw),
                            d: parseFloat(row.d),
                            bf: parseFloat(row.bf)
                        };
                    } else if (label.startsWith('L')) {
                        // L shape (angle)
                        steelData[label] = {
                            type: 'L',
                            A: parseFloat(row.A),
                            t: parseFloat(row.t),          // thickness
                            b: parseFloat(row.b),          // longer leg
                            d: parseFloat(row.d)           // shorter leg
                        };
                    }
                }
            });
            
            console.log("Steel data loaded:", Object.keys(steelData).length, "sections");
            dataLoaded = true;
            
            // Remove loading indicator
            document.getElementById('loading-indicator').remove();
        })
        .catch(error => {
            console.error("Error loading Excel data:", error);
            // Fallback to some default data
            steelData["W12X45"] = { 
                type: 'W',
                A: 13.2, 
                tw: 0.335, 
                d: 12.1, 
                bf: 8.05 
            };
            
            steelData["L4X3X3/8"] = { 
                type: 'L',
                A: 2.59, 
                t: 0.375, 
                b: 4.0, 
                d: 3.0 
            };
            
            // Update loading indicator
            document.getElementById('loading-indicator').innerHTML = 'Failed to load data. Using defaults.';
            document.getElementById('loading-indicator').style.backgroundColor = '#ffcccc';
            
            setTimeout(() => {
                document.getElementById('loading-indicator').remove();
            }, 3000);
            
            dataLoaded = true;
        });
}

// Add this function to debug the steel data loading
function debugSteelData(sectionKey) {
    console.log("Looking for section: " + sectionKey);
    console.log("Available steel data keys:", Object.keys(steelData));
    console.log("Found section data:", steelData[sectionKey]);
    
    // Check if we have any keys that are similar
    const similarKeys = Object.keys(steelData).filter(key => 
        key.includes(sectionKey.replace(/^[WL]/, '')) || 
        sectionKey.includes(key.replace(/^[WL]/, ''))
    );
    
    if (similarKeys.length > 0) {
        console.log("Similar keys found:", similarKeys);
    }
    
    return steelData[sectionKey];
}

// Normalize section key to handle various input formats
function normalizeSectionKey(shape, dim) {
    // Convert to uppercase and remove spaces
    shape = shape.trim().toUpperCase();
    dim = dim.trim().toUpperCase().replace(/\s/g, '');
    
    // Handle L shape special format (may contain multiple X's)
    if (shape === 'L') {
        // Ensure format is like L4X3X3/8 (no spaces)
        return shape + dim.replace(/X/g, 'X');
    }
    
    // For W shapes
    return shape + dim;
}

// Get section data with improved format handling
function getSectionData() {
    const shape = document.getElementById('shapeA').value.trim().toUpperCase();
    const dim = document.getElementById('dimA').value.trim().toUpperCase().replace(/\s/g, '');
    const sectionKey = normalizeSectionKey(shape, dim);
    
    console.log("Attempting to get section data for:", sectionKey);
    
    let section = steelData[sectionKey];
    
    // If not found, try with different formatting
    if (!section) {
        console.log("Section not found, trying alternative formats...");
        
        // Array of possible format variations
        const alternativeFormats = [];
        
        if (shape === 'W') {
            // Try alternative W formats
            alternativeFormats.push(
                shape + dim.replace('X', 'x'),
                shape + 'X' + dim.replace('X', '')
            );
        } else if (shape === 'L') {
            // Try alternative L formats - angles often have various formats
            // e.g. L4X3X3/8, L4x3x3/8, L4X3-3/8
            
            // Split the dimension by X
            const parts = dim.split('X');
            if (parts.length >= 2) {
                const leg1 = parts[0];
                const leg2 = parts.length > 1 ? parts[1] : parts[0];
                const thickness = parts.length > 2 ? parts[2] : "";
                
                alternativeFormats.push(
                    `L${leg1}X${leg2}X${thickness}`,
                    `L${leg1}x${leg2}x${thickness}`,
                    `L${leg1}X${leg2}-${thickness}`
                );
            }
        }
        
        // Try each alternative format
        for (const altFormat of alternativeFormats) {
            if (steelData[altFormat]) {
                console.log("Found with format:", altFormat);
                section = steelData[altFormat];
                break;
            }
        }
        
        // If still not found, check for similar keys as a last resort
        if (!section) {
            // For L shapes, try to match by the main dimensions
            if (shape === 'L') {
                const mainDims = dim.split('X').slice(0, 2).join('X');
                const possibleMatches = Object.keys(steelData).filter(key => 
                    key.startsWith('L') && key.includes(mainDims)
                );
                
                if (possibleMatches.length > 0) {
                    console.log("Found similar angle section:", possibleMatches[0]);
                    section = steelData[possibleMatches[0]];
                }
            } else {
                // For W shapes, try to match by the main number
                const mainNumber = dim.split('X')[0];
                const possibleMatches = Object.keys(steelData).filter(key => 
                    key.startsWith('W') && key.includes(mainNumber)
                );
                
                if (possibleMatches.length > 0) {
                    console.log("Found similar W section:", possibleMatches[0]);
                    section = steelData[possibleMatches[0]];
                }
            }
        }
    }
    
    // If still not found, log and return defaults
    if (!section) {
        // Log all available keys for debugging
        console.log("Section not found. Available keys:", Object.keys(steelData).slice(0, 10).join(", ") + "...");
        
        // Return default values based on shape type
        if (shape === 'L') {
            console.log("Using default L shape values");
            return { 
                type: 'L',
                A: 2.59, 
                t: 0.375, 
                b: 4.0, 
                d: 3.0
            };
        } else {
            console.log("Using default W shape values");
            return { 
                type: 'W',
                A: 13.2, 
                tw: 0.335, 
                d: 12.1, 
                bf: 8.05 
            };
        }
    }
    
    console.log("Section found:", section);
    return section;
}

        // Add this function to create the interactive drawing area
function createInteractiveDrawingArea() {
    const flange = document.getElementById('dynamicFlange');
    flange.innerHTML = '';
    
    // Create a grid layout that users can click to toggle holes
    const nholeC = parseInt(document.getElementById('nholeC').value);
    const nholeR = parseInt(document.getElementById('nholeR').value);
    const s = parseFloat(document.getElementById('spacingS').value);
    const g = parseFloat(document.getElementById('spacingG').value);
    const pxPerIn = 20, leftStart = 60, topStart = 40;
    
    // Create instructions
    const instructions = document.createElement('div');
    instructions.innerHTML = '<strong>Click to add/remove holes</strong>';
    instructions.style.position = 'absolute';
    instructions.style.top = '5px';
    instructions.style.left = '5px';
    instructions.style.color = 'blue';
    flange.appendChild(instructions);
    
    // Create the grid
    for (let row = 0; row < nholeC; row++) {
        for (let col = 0; col < nholeR; col++) {
            const x = leftStart + col * s * pxPerIn;
            const y = topStart + row * g * pxPerIn;
            
            // Create grid cell background
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.style.width = '20px';
            cell.style.height = '20px';
            cell.style.border = '1px dashed #ccc';
            cell.style.position = 'absolute';
            cell.style.left = `${x - 5}px`;
            cell.style.top = `${y - 5}px`;
            cell.dataset.row = row + 1;
            cell.dataset.col = col + 1;
            flange.appendChild(cell);
            
            // Create hole (initially with full opacity)
            const hole = document.createElement('div');
            hole.className = 'hole';
            hole.style.width = '10px';
            hole.style.height = '10px';
            hole.style.borderRadius = '50%';
            hole.style.backgroundColor = 'black';
            hole.style.position = 'absolute';
            hole.style.left = `${x}px`;
            hole.style.top = `${y}px`;
            hole.dataset.row = row + 1;
            hole.dataset.col = col + 1;
            hole.dataset.active = '1'; // Default is active
            flange.appendChild(hole);
            
            // Make holes clickable
            hole.addEventListener('click', function() {
                if (this.dataset.active === '1') {
                    this.style.opacity = '0.2';
                    this.dataset.active = '0';
                    removedHoles.add(`${this.dataset.row}-${this.dataset.col}`);
                } else {
                    this.style.opacity = '1';
                    this.dataset.active = '1';
                    removedHoles.delete(`${this.dataset.row}-${this.dataset.col}`);
                }
            });
            
            // Add spacing labels
            if (row < nholeC - 1 && col === 0) {
                const label = document.createElement('div');
                label.style.position = 'absolute';
                label.style.left = `${x - 30}px`;
                label.style.top = `${y + g * pxPerIn / 2 - 8}px`;
                label.style.color = 'red';
                label.innerHTML = `${g}"`;
                flange.appendChild(label);
            }
            
            if (col < nholeR - 1 && row === 0) {
                const hLabel = document.createElement('div');
                hLabel.style.position = 'absolute';
                hLabel.style.left = `${x + s * pxPerIn / 2 - 8}px`;
                hLabel.style.top = `${y - 20}px`;
                hLabel.style.color = 'red';
                hLabel.innerHTML = `${s}"`;
                flange.appendChild(hLabel);
            }
        }
    }
    
    // Add clear and fill buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.position = 'absolute';
    buttonContainer.style.bottom = '10px';
    buttonContainer.style.right = '10px';
    
    const clearBtn = document.createElement('button');
    clearBtn.innerText = 'Clear All Holes';
    clearBtn.onclick = function() {
        document.querySelectorAll('.hole').forEach(hole => {
            hole.style.opacity = '0.2';
            hole.dataset.active = '0';
            removedHoles.add(`${hole.dataset.row}-${hole.dataset.col}`);
        });
    };
    
    const fillBtn = document.createElement('button');
    fillBtn.innerText = 'Fill All Holes';
    fillBtn.onclick = function() {
        document.querySelectorAll('.hole').forEach(hole => {
            hole.style.opacity = '1';
            hole.dataset.active = '1';
            removedHoles.delete(`${hole.dataset.row}-${hole.dataset.col}`);
        });
    };
    
    buttonContainer.appendChild(clearBtn);
    buttonContainer.appendChild(document.createTextNode(' '));
    buttonContainer.appendChild(fillBtn);
    flange.appendChild(buttonContainer);
}

// Replace updateHoleLayout with the interactive drawing version
function updateHoleLayout() {
    createInteractiveDrawingArea();
}

        // Global variables
        let removedHoles = new Set();

        // ASTM material properties
        const astmData = {
            "A36": { Fy: 36, Fu: 58 }, 
            "A572GR42": { Fy: 42, Fu: 60 }, 
            "A572GR50": { Fy: 50, Fu: 65 },
            "A572GR55": { Fy: 55, Fu: 70 }, 
            "A572GR60": { Fy: 60, Fu: 75 }, 
            "A572GR65": { Fy: 65, Fu: 80 },
            "A588GR42": { Fy: 42, Fu: 63 }, 
            "A588GR46": { Fy: 46, Fu: 67 }, 
            "A588GR50": { Fy: 50, Fu: 70 },
            "A687": { Fy: 45, Fu: 75 }, 
            "A992": { Fy: 50, Fu: 65 }
        };


const styleElement = document.createElement('style');
styleElement.textContent = `
    .hole {
        cursor: pointer;
        transition: opacity 0.2s;
    }
    .hole:hover {
        box-shadow: 0 0 5px blue;
    }
    .grid-cell:hover {
        background-color: rgba(200, 200, 255, 0.3);
    }
    #dynamicFlange button {
        margin: 0 5px;
        padding: 5px 10px;
        background-color: #f0f0f0;
        border: 1px solid #999;
        border-radius: 3px;
        cursor: pointer;
    }
    #dynamicFlange button:hover {
        background-color: #e0e0e0;
    }
`;
document.head.appendChild(styleElement);

        // Toggle display based on design option
        function toggleShearDiv() {
    const selection = document.querySelector('input[name="designOption"]:checked').value;
    document.getElementById('shearDiv').style.display = (selection !== 'none') ? 'block' : 'none';
    document.getElementById('blockShearInputs').style.display = selection === 'block' ? 'block' : 'none';
    document.getElementById('column-inputs').style.display = selection === 'stagger' ? 'block' : 'none';
    document.getElementById('failurePathResult').style.display = selection === 'stagger' ? 'block' : 'none';
    document.getElementById('staggerReductionResult').style.display = selection === 'stagger' ? 'block' : 'none';
    
    // Initialize drawing area if stagger option is selected
    if (selection === 'stagger') {
        createInteractiveDrawingArea();
    }
}


function getHolePattern() {
    const nholeC = parseInt(document.getElementById('nholeC').value);
    const nholeR = parseInt(document.getElementById('nholeR').value);
    const pattern = [];
    
    for (let row = 0; row < nholeC; row++) {
        pattern[row] = [];
        for (let col = 0; col < nholeR; col++) {
            const holeElement = document.querySelector(`.hole[data-row="${row+1}"][data-col="${col+1}"]`);
            if (holeElement && holeElement.dataset.active === '1') {
                pattern[row][col] = 1; // Active hole
            } else {
                pattern[row][col] = 0; // Inactive hole
            }
        }
    }
      return pattern;
}

        
        // Get form input values
        function getInputValues() {
            return {
                ASTM: document.getElementById('ASpecA').value.toUpperCase().replace(/\./g, ''),
                dhole: parseFloat(document.getElementById('dholeA').value),
                nholeC: parseInt(document.getElementById('nholeC').value),
                nholeR: parseInt(document.getElementById('nholeR').value),
                spacingS: parseFloat(document.getElementById('spacingS').value),
                spacingG: parseFloat(document.getElementById('spacingG').value),
                caseId: document.getElementById('ulagCase').value,
                length: parseFloat(document.getElementById('lengthA').value),
                shape: document.getElementById('shapeA').value.toUpperCase(),
                dim: document.getElementById('dimA').value.toUpperCase().replace(/\s/g, ''),
                designOption: document.querySelector('input[name="designOption"]:checked').value
            };
        }

        // Calculate shear lag factor U
        function calculateU(caseId, xbar, length, bf, d) {
            switch (parseInt(caseId)) {
                case 1: return 1.0;
                case 2: 
                    const case2Value = 1 - (xbar / length);
                    return case2Value;
                case 7: 
                    const case2ForComp = 1 - (xbar / length);
                    return Math.max(bf / d >= 2 / 3 ? 0.9 : 0.8, case2ForComp);
                case 8: return 0.8;
                default: return 1.0;
            }
        }

        function updateColumnControls() {
    const columnInputs = document.getElementById('column-inputs');
    columnInputs.innerHTML = `
        <h3>Interactive Hole Pattern</h3>
        <div class="control-section">
            <div class="control-group">
                <label for="spacingS">Horizontal spacing (s):</label>
                <input type="number" id="spacingS" value="2" step="0.1" class="stagger-input"> in
                
                <label for="spacingG">Vertical spacing (g):</label>
                <input type="number" id="spacingG" value="1.5" step="0.1" class="gauge-input"> in
                
                <button onclick="updateGrid()">Update Grid</button>
            </div>
            
            <div class="control-group" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ccc;">
                <h4>Path Calculation Options</h4>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathAuto" name="pathMethod" value="auto" checked>
                    <label for="pathAuto">Find critical path automatically</label>
                </div>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathManual" name="pathMethod" value="manual">
                    <label for="pathManual">Specify custom path</label>
                </div>
                
                <div id="customPathContainer" style="margin-top: 10px; display: none;">
                    <label for="customPathInput">Custom Path (format: 1-1,1-2,2-3,...):</label><br>
                    <input type="text" id="customPathInput" placeholder="row-col,row-col,..." style="width: 90%; margin-top: 5px;">
                    <div style="margin-top: 5px; font-size: 0.85em; color: #666;">
                        Example: 1-1,1-2,2-3 means path from hole (1,1) → (1,2) → (2,3)
                    </div>
                    <button id="visualizePath" style="margin-top: 8px;">Visualize Path</button>
                </div>
            </div>
        </div>
        
        <div id="dynamicFlange" style="position:relative; width:400px; height:300px; border:2px solid black; background:#f0f0f0; margin-top:20px;"></div>
    `;
    
    // Add event listeners for the spacing inputs
    document.getElementById('spacingS').addEventListener('change', updateGrid);
    document.getElementById('spacingG').addEventListener('change', updateGrid);
    
    // Add event listeners for path selection
    document.getElementById('pathAuto').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'none';
    });
    
    document.getElementById('pathManual').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'block';
    });
    
    // Add event listener for path visualization
    document.getElementById('visualizePath').addEventListener('click', visualizeCustomPath);
}
    function updateGrid() {
    // Save current pattern
    const pattern = getHolePattern();
    
    // Recreate the drawing area
    createInteractiveDrawingArea();
    
    // Restore pattern
    const nholeC = parseInt(document.getElementById('nholeC').value);
    const nholeR = parseInt(document.getElementById('nholeR').value);
    
    for (let row = 0; row < Math.min(nholeC, pattern.length); row++) {
        for (let col = 0; col < Math.min(nholeR, pattern[row].length); col++) {
            if (pattern[row][col] === 0) {
                const holeElement = document.querySelector(`.hole[data-row="${row+1}"][data-col="${col+1}"]`);
                if (holeElement) {
                    holeElement.style.opacity = '0.2';
                    holeElement.dataset.active = '0';
                    removedHoles.add(`${row+1}-${col+1}`);
                }
            }
        }
    }
}

function visualizeOptimalPath() {
    // First reset all path highlights
    document.querySelectorAll('.path-highlight').forEach(el => {
        el.remove();
    });
    
    const holePattern = getHolePattern();
    const path = findOptimalStagPath(holePattern);
    
    if (path.length < 2) {
        alert("Not enough active holes to create a path");
        return;
    }
    
    // Create visualization
    const flange = document.getElementById('dynamicFlange');
    
    // Create SVG container for path lines
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.classList.add('path-overlay', 'path-highlight');
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.style.pointerEvents = 'none';
    flange.appendChild(svg);
    
    // Draw lines and markers for the path
    for (let i = 0; i < path.length; i++) {
        const [row, col] = path[i];
        
        // Get the hole element
        const hole = document.querySelector(`.hole[data-row="${row+1}"][data-col="${col+1}"]`);
        if (!hole) continue;
        
        // Get coordinates
        const holeRect = hole.getBoundingClientRect();
        const flangeRect = flange.getBoundingClientRect();
        const x = holeRect.left + holeRect.width/2 - flangeRect.left;
        const y = holeRect.top + holeRect.height/2 - flangeRect.top;
        
        // Add number marker to hole
        const marker = document.createElement('div');
        marker.classList.add('path-marker', 'path-highlight');
        marker.style.position = 'absolute';
        marker.style.left = (x - 8) + 'px';
        marker.style.top = (y - 8) + 'px';
        marker.style.width = '16px';
        marker.style.height = '16px';
        marker.style.borderRadius = '50%';
        marker.style.backgroundColor = 'rgba(255,0,0,0.2)';
        marker.style.border = '2px solid red';
        marker.style.color = 'red';
        marker.style.display = 'flex';
        marker.style.alignItems = 'center';
        marker.style.justifyContent = 'center';
        marker.style.fontWeight = 'bold';
        marker.style.fontSize = '10px';
        marker.style.zIndex = '10';
        marker.textContent = i + 1;
        flange.appendChild(marker);
        
        // Draw line to next point
        if (i < path.length - 1) {
            const [nextRow, nextCol] = path[i+1];
            const nextHole = document.querySelector(`.hole[data-row="${nextRow+1}"][data-col="${nextCol+1}"]`);
            
            if (nextHole) {
                const nextRect = nextHole.getBoundingClientRect();
                const x2 = nextRect.left + nextRect.width/2 - flangeRect.left;
                const y2 = nextRect.top + nextRect.height/2 - flangeRect.top;
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', y);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', 'red');
                line.setAttribute('stroke-width', '2');
                svg.appendChild(line);
            }
        }
    }
    
    // Set the path to the custom path input
    const customPathInput = document.getElementById('customPathInput');
    if (customPathInput) {
        const pathStr = path.map(p => `${p[0]+1}-${p[1]+1}`).join(',');
        customPathInput.value = pathStr;
    }
}


function findOptimalStagPath(holePattern) {
    const rows = holePattern.length;
    const cols = holePattern[0].length;
    const path = [];
    
    // Start searching from the top row
    for (let row = 0; row < rows; row++) {
        // First try to find a hole in column 1 for this row
        if (holePattern[row][0] === 1) {
            path.push([row, 0]);
            continue; // Move to next row
        }
        
        // If no hole in column 1, find one in any other column
        let holeFound = false;
        for (let col = 1; col < cols; col++) {
            if (holePattern[row][col] === 1) {
                path.push([row, col]);
                holeFound = true;
                break; // Only take one hole per row
            }
        }
        
        // Skip rows with no holes
        if (!holeFound) {
            continue;
        }
    }
    
    return path;
}
    





  
function calculateZigzagNetArea(Ag, holePattern, holeDia, s, g) {
    const d_hole = holeDia + 1/8; // Add 1/8" for standard hole
    const nholeC = holePattern.length; // rows
    const nholeR = holePattern[0].length; // columns
    
    // Get section properties for hole area calculation
    const sectionKey = document.getElementById('shapeA').value + document.getElementById('dimA').value.toUpperCase().replace(/\s/g, '');
    const section = steelData[sectionKey] || { tw: 0.335 }; // Use default if not found
    const tw = section.tw; // Web thickness for hole area
    
    // Calculate standard net area using the critical column approach
    const standardResult = calculateStandardNetArea(
        Ag,
        holePattern,
        holeDia,
        tw
    );
    const standardNetArea = standardResult.netArea;
    
    // Check if manual path selection is active
    const useManualPath = document.getElementById('pathManual') && 
                         document.getElementById('pathManual').checked;
    
    if (useManualPath) {
        // Use custom path from input
        const pathInput = document.getElementById('customPathInput').value.trim();
        if (!pathInput) {
            alert("Please enter a valid path or switch to automatic calculation");
            return {
                standardNetArea: standardNetArea,
                netArea: standardNetArea,
                criticalPath: "No valid path specified",
                staggerReduction: 0
            };
        }
        
        try {
            // Parse the path string into array of [row, col] coordinates
            const customPath = pathInput.split(',').map(coord => {
                const [row, col] = coord.trim().split('-').map(Number);
                if (isNaN(row) || isNaN(col) || row < 1 || col < 1 || 
                    row > nholeC || col > nholeR || holePattern[row-1][col-1] !== 1) {
                    throw new Error(`Invalid or inactive hole at position (${row},${col})`);
                }
                return [row-1, col-1]; // Convert to 0-based indexing
            });
            
            if (customPath.length < 2) {
                throw new Error("Path must contain at least 2 points");
            }
            
            // Calculate net area for this custom path
            let holeLoss = customPath.length * d_hole * tw;
            let totalStaggerReduction = 0;
            
            // Calculate stagger reduction for each diagonal segment
            for (let i = 1; i < customPath.length; i++) {
                const [prevRow, prevCol] = customPath[i-1];
                const [currRow, currCol] = customPath[i];
                
                // If moving diagonally (both row and column change)
                if (prevRow !== currRow && prevCol !== currCol) {
                    const dx = Math.abs(currCol - prevCol) * s; // Horizontal spacing
                    const dy = Math.abs(currRow - prevRow) * g; // Vertical spacing
                    const staggerReduction = Math.pow(dx, 2) / (4 * dy);
                    totalStaggerReduction += staggerReduction;
                }
            }
            
            // Calculate net area for this path
            const netArea = Ag - holeLoss + (totalStaggerReduction * tw);
            
            // Path summary for display
            let pathSummary = `Custom Path: `;
            customPath.forEach((p, idx) => {
                pathSummary += `(${p[0]+1},${p[1]+1})`;
                if (idx < customPath.length - 1) pathSummary += " → ";
            });
            
            return {
                standardNetArea: standardNetArea,
                netArea: netArea,
                criticalPath: pathSummary,
                staggerReduction: totalStaggerReduction * tw
            };
            
        } catch (error) {
            alert("Error in custom path: " + error.message);
            return {
                standardNetArea: standardNetArea,
                netArea: standardNetArea,
                criticalPath: "Error in path: " + error.message,
                staggerReduction: 0
            };
        }
    } else {
        // Use new optimized path algorithm - one hole per row prioritizing column 1
        const path = findOptimalStagPath(holePattern);
        
        if (path.length < 2) {
            return {
                standardNetArea: standardNetArea,
                netArea: standardNetArea,
                criticalPath: "Insufficient holes for stagger calculation",
                staggerReduction: 0
            };
        }
        
        // Calculate net area
        let holeLoss = path.length * d_hole * tw;
        let totalStaggerReduction = 0;
        
        // Calculate stagger reduction for each diagonal segment
        for (let i = 1; i < path.length; i++) {
            const [prevRow, prevCol] = path[i-1];
            const [currRow, currCol] = path[i];
            
            // If moving diagonally (both row and column change)
            if (prevRow !== currRow && prevCol !== currCol) {
                const dx = Math.abs(currCol - prevCol) * s; // Horizontal spacing
                const dy = Math.abs(currRow - prevRow) * g; // Vertical spacing
                const staggerReduction = Math.pow(dx, 2) / (4 * dy);
                totalStaggerReduction += staggerReduction;
            }
        }
        
        // Calculate net area for this path
        const netArea = Ag - holeLoss + (totalStaggerReduction * tw);
        
        // Path summary for display
        let pathSummary = `One-per-row Path: `;
        path.forEach((p, idx) => {
            pathSummary += `(${p[0]+1},${p[1]+1})`;
            if (idx < path.length - 1) pathSummary += " → ";
        });
        
        return {
            standardNetArea: standardNetArea,
            netArea: netArea,
            criticalPath: pathSummary,
            staggerReduction: totalStaggerReduction * tw
        };
    }
}


function updateColumnControls() {
    const columnInputs = document.getElementById('column-inputs');
    columnInputs.innerHTML = `
        <h3>Interactive Hole Pattern</h3>
        <div class="control-section">
            <div class="control-group">
                <label for="spacingS">Horizontal spacing (s):</label>
                <input type="number" id="spacingS" value="2" step="0.1" class="stagger-input"> in
                
                <label for="spacingG">Vertical spacing (g):</label>
                <input type="number" id="spacingG" value="1.5" step="0.1" class="gauge-input"> in
                
                <button onclick="updateGrid()">Update Grid</button>
            </div>
            
            <div class="control-group" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ccc;">
                <h4>Path Calculation Options</h4>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathAuto" name="pathMethod" value="auto" checked>
                    <label for="pathAuto">One hole per row (prioritize column 1)</label>
                </div>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathLegacy" name="pathMethod" value="legacy">
                    <label for="pathLegacy">Find critical zigzag path (legacy)</label>
                </div>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathManual" name="pathMethod" value="manual">
                    <label for="pathManual">Specify custom path</label>
                </div>
                
                <div style="margin-top: 10px;">
                    <button onclick="visualizeOptimalPath()">Preview Current Path</button>
                </div>
                
                <div id="customPathContainer" style="margin-top: 10px; display: none;">
                    <label for="customPathInput">Custom Path (format: 1-1,1-2,2-3,...):</label><br>
                    <input type="text" id="customPathInput" placeholder="row-col,row-col,..." style="width: 90%; margin-top: 5px;">
                    <div style="margin-top: 5px; font-size: 0.85em; color: #666;">
                        Example: 1-1,1-2,2-3 means path from hole (1,1) → (1,2) → (2,3)
                    </div>
                    <button id="visualizePath" style="margin-top: 8px;">Visualize Path</button>
                </div>
            </div>
        </div>
        
        <div id="dynamicFlange" style="position:relative; width:400px; height:300px; border:2px solid black; background:#f0f0f0; margin-top:20px;"></div>
    `;
    
    // Add event listeners
    document.getElementById('spacingS').addEventListener('change', updateGrid);
    document.getElementById('spacingG').addEventListener('change', updateGrid);
    
    // Add event listeners for path selection
    document.getElementById('pathAuto').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'none';
    });
    
    document.getElementById('pathLegacy').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'none';
    });
    
    document.getElementById('pathManual').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'block';
    });
    
    // Add event listener for path visualization
    document.getElementById('visualizePath').addEventListener('click', visualizeCustomPath);
    
    // Initialize the drawing area
    createInteractiveDrawingArea();
}


function findAllPathsRowBased(holePattern, startRow, startCol, maxCols, maxRows) {
    // Base case: if we've reached the last row
    if (startRow === maxRows - 1) {
        // Return current position as a single-element path if there's a hole here
        return holePattern[startRow][startCol] === 1 ? [[[startRow, startCol]]] : [];
    }
    
    let paths = [];
    
    // If there's a hole at the current position
    if (holePattern[startRow][startCol] === 1) {
        // Try moving to each hole in the next row
        for (let nextCol = 0; nextCol < maxCols; nextCol++) {
            const subPaths = findAllPathsRowBased(holePattern, startRow + 1, nextCol, maxCols, maxRows);
            
            // Attach current position to each subpath
            subPaths.forEach(subPath => {
                paths.push([[startRow, startCol], ...subPath]);
            });
        }
        
        // If no valid subpaths were found, return current position as endpoint
        if (paths.length === 0) {
            paths.push([[startRow, startCol]]);
        }
    }
    
    return paths;
}




// First, let's modify the calculateStandardNetArea function to find critical rows instead of columns
function calculateStandardNetArea(Ag, holeDia, totalHoles, tw) {
    const d_hole = holeDia + 1/8; // Add 1/8" for standard hole
    
    // Calculate net area by subtracting hole area from gross area
    const holeLoss = totalHoles * d_hole * tw;
    const netArea = Ag - holeLoss;
    
    return {
        netArea: netArea,
        holesCount: totalHoles
    };
}

   function performCalculations() {
    if (!dataLoaded) {
        alert("Steel section data is still loading. Please wait a moment and try again.");
        return;
    }
    const inputValues = getInputValues();
    
    // Validate inputs
    if (isNaN(inputValues.dhole) || inputValues.dhole <= 0) {
        alert("Please enter a valid hole diameter");
        return;
    }
    
    if (isNaN(inputValues.length) || inputValues.length <= 0) {
        alert("Please enter a valid length");
        return;
    }
    
    // Get material properties
    const material = astmData[inputValues.ASTM] || { Fy: 36, Fu: 58 };
    
    // Get section properties from steel data
    const sectionKey = inputValues.shape + inputValues.dim;
    const section = steelData[sectionKey] || { A: 0, d: 0, bf: 0, tw: 0 };
    
    if (!section.A) {
        // Default value if section not found
        section.A = 13.2;
        section.d = 12.1;
        section.bf = 8.05;
        section.tw = 0.335;
        console.warn("Section not found, using default values");
    }
    
    // Gross area
    const Ag = section.A;
    document.getElementById('AG').textContent = Ag.toFixed(3) + " in²";
    
    // Variables for net area and effective net area
    let An, Ae, criticalPathText = "", staggerReductionValue = 0;
    let standardNetArea = 0;
    
    // Calculate xbar for U (simplified - center of gravity to connection)
    const xbar = section.bf / 2;
        
    // Calculate U - shear lag factor
    const U = calculateU(
        inputValues.caseId,
        xbar, 
        inputValues.length,
        section.bf,
        section.d
    );
    
    if (inputValues.designOption === 'stagger') {
        const holePattern = getHolePattern();
        
        // Check which path method is selected
        let useManualPath = false;
        let useLegacyPath = false;
        
        if (document.getElementById('pathManual') && document.getElementById('pathManual').checked) {
            useManualPath = true;
        } else if (document.getElementById('pathLegacy') && document.getElementById('pathLegacy').checked) {
            useLegacyPath = true;
        }
        
        let result;
        
        if (useLegacyPath) {
            // Use the original zigzag function
            result = calculateLegacyZigzagNetArea(
                Ag, 
                holePattern, 
                inputValues.dhole, 
                inputValues.spacingS, 
                inputValues.spacingG
            );
        } else {
            // Use our new improved calculation
            result = calculateZigzagNetArea(
                Ag, 
                holePattern, 
                inputValues.dhole, 
                inputValues.spacingS, 
                inputValues.spacingG
            );
        }
        
        // Visualize the path after calculation
        if (!useManualPath) {
            visualizeOptimalPath();
        }
        
        standardNetArea = result.standardNetArea;
        An = result.netArea;  // This is the net area without the shear lag factor
        Ae = An * U;         // Apply shear lag factor to get effective net area
        criticalPathText = result.criticalPath;
        staggerReductionValue = result.staggerReduction;
        
        document.getElementById('criticalPath').textContent = criticalPathText;
        document.getElementById('staggerReduction').textContent = staggerReductionValue.toFixed(3) + " in²";
        
        // Update results to show both values - NET AREA first
        document.getElementById('AE').textContent = 
            `${An.toFixed(3)} in² (With stagger effect)`;
            
    } else if (inputValues.designOption === 'block') {
        // Block shear calculation
        const Agv = parseFloat(document.getElementById('Agv').value) || 0;
        const Anv = parseFloat(document.getElementById('Anv').value) || 0;
        const Ant = parseFloat(document.getElementById('Ant').value) || 0;
        
        if (Agv <= 0 || Anv <= 0 || Ant <= 0) {
            alert("Please enter valid values for block shear areas");
            return;
        }
        
        // AISC Equation J4-5
        const blockShear1 = 0.60 * material.Fu * Anv + material.Fy * Agv;
        // AISC Equation J4-5 (alternative)
        const blockShear2 = 0.60 * material.Fy * Agv + material.Fu * Ant;
        
        // For block shear, An is the minimum of the two calculations
        An = Math.min(blockShear1, blockShear2);
        Ae = An;  // For block shear, we don't apply the U factor
        
        document.getElementById('AE').textContent = An.toFixed(3) + " in² (Block shear)";
        
    } 
    
    else {
    // Simple calculation with holes - just count total holes in a column
    const tw = section.tw;
    const nholeC = parseInt(document.getElementById('nholeC').value);
    
    // Use function to calculate standard net area
    const standardAreaResult = calculateStandardNetArea(
        Ag,
        inputValues.dhole,
        nholeC, // Just pass the number of holes in a column
        tw
    );
    
    An = standardAreaResult.netArea;  // This is the net area (An)
    Ae = An * U;  // The effective net area (Ae) applies the shear lag factor
    
    // Show detailed information about NET AREA
    document.getElementById('AE').textContent = 
        `${An.toFixed(3)} in² (${standardAreaResult.holesCount} holes in column)`;
}
    
    // Calculate yielding strength (uses gross area)
    const Py = material.Fy * Ag;
    
    // Calculate fracture strength (uses effective net area)
    const Pf = material.Fu * Ae;  // Use Ae (effective net area)
    
    // Determine which limit state controls
    const isYieldingControls = Py <= Pf;
    
    // Display yielding strength with highlight if it controls
    document.getElementById('YC').innerHTML = isYieldingControls 
        ? `<span style="color:green; font-weight:bold">${Py.toFixed(1)} kips (CONTROLS)</span>` 
        : `${Py.toFixed(1)} kips`;
    
    // Display fracture strength with highlight if it controls
    document.getElementById('FS').innerHTML = !isYieldingControls 
        ? `<span style="color:green; font-weight:bold">${Pf.toFixed(1)} kips (CONTROLS)</span>` 
        : `${Pf.toFixed(1)} kips`;
    
    // Nominal strength is minimum of yield and fracture
    const Pn = Math.min(Py, Pf);
    
    // LRFD design strength
    const phiPn = 0.9 * Py; // φ = 0.9 for tension yielding
    const phiPnFracture = 0.75 * Pf; // φ = 0.75 for fracture
    const phiPnFinal = Math.min(phiPn, phiPnFracture);
    
    // Add text to indicate which governs LRFD
    const lrfdGoverns = phiPn <= phiPnFracture ? "yielding" : "fracture";
    document.getElementById('LRFD').textContent = `${phiPnFinal.toFixed(1)} kips (${lrfdGoverns})`;
    
    // ASD allowable strength
    // Use appropriate safety factor based on which failure mode controls
    const safetyFactor = isYieldingControls ? 1.67 : 2.0;
    const PnASD = Pn / safetyFactor;
    document.getElementById('ASD').textContent = `${PnASD.toFixed(1)} kips (${isYieldingControls ? "yielding" : "fracture"})`;
}

        // Event listeners
        document.querySelector('.Calculate').addEventListener('click', performCalculations);

document.querySelectorAll('input[name="designOption"]').forEach(el => {
    el.addEventListener('change', function() {
        toggleShearDiv();
        if (this.value === 'stagger') {
            updateColumnControls();
            createInteractiveDrawingArea();
        }
    });
});

document.addEventListener('DOMContentLoaded', function() {
    loadExcelData();
    toggleShearDiv();
});

// JavaScript for Axial Tension Member Design Calculator with Excel Data Import

// Function to load the SheetJS library





















// Global variables for data storage
let steelSpecs = [];
let sectionData = {};
let beamData = {};  // To store beam data from sheet 3 if needed
let dataLoaded = false;

// Initialize the application when the document is loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log("Initializing application");
    
    // Initialize event listeners
    setupEventListeners();
    
    // Try to load the data from Excel file
    loadExcelData()
        .then(() => {
            console.log("Excel data loaded successfully");
            dataLoaded = true;
            // Call updateShapeOptions to populate the W-shape and L-shape input datalist
            updateShapeOptions();
        })
        .catch(error => {
            console.warn("Failed to load Excel data:", error);
            console.log("Using hardcoded data instead");
            useHardcodedData();
            dataLoaded = true;
            // Still call updateShapeOptions with the hardcoded data
            updateShapeOptions();
        });
});

// Function to set up all event listeners
function setupEventListeners() {
    console.log("Setting up event listeners");
    
    // Get the button element first
    const analyzeButton = document.getElementById('AnalysisShear');
    
    // Check if the button exists
    if (analyzeButton) {
        console.log("Found Analysis button, adding click listener");
        analyzeButton.addEventListener('click', analyzeShear);
    } else {
        console.error("Could not find 'AnalysisShear' button");
        // Try again when window is fully loaded
        window.addEventListener('load', function() {
            const buttonRetry = document.getElementById('AnalysisShear');
            if (buttonRetry) {
                console.log("Found button on window load, adding listener");
                buttonRetry.addEventListener('click', analyzeShear);
            }
        });
    }
}

// Function to load Excel data using fetch API
async function loadExcelData() {
    // Show loading indicator
    const loadingIndicator = document.createElement('div');
    loadingIndicator.id = 'loading-indicator';
    loadingIndicator.innerHTML = 'Loading steel section data...';
    loadingIndicator.style.position = 'fixed';
    loadingIndicator.style.top = '10px';
    loadingIndicator.style.right = '10px';
    loadingIndicator.style.padding = '5px 10px';
    loadingIndicator.style.backgroundColor = '#ffe0e0';
    loadingIndicator.style.border = '1px solid #ffcccc';
    loadingIndicator.style.borderRadius = '3px';
    loadingIndicator.style.zIndex = '1000';
    document.body.appendChild(loadingIndicator);
    
    try {
        console.log("Attempting to load Excel data...");
        
        // Use fetch API to load the Excel file as a blob
        const response = await fetch('ASTMSPEC.xlsx', {
            method: 'GET',
            mode: 'cors',
            cache: 'no-cache'
        });
        
        if (!response.ok) {
            throw new Error(`Failed to fetch Excel file: ${response.status}`);
        }
        
        // Get the file as an ArrayBuffer
        const arrayBuffer = await response.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // Parse with SheetJS
        const workbook = XLSX.read(data, { type: 'array' });
        
        // Load steel specifications from the first sheet
        const steelSheet = workbook.Sheets[workbook.SheetNames[0]];
        const rawSteelSpecs = XLSX.utils.sheet_to_json(steelSheet);
        
        // Validate steel specs data
        steelSpecs = rawSteelSpecs.filter(spec => 
            spec.Steel_name && 
            typeof spec.Fy === 'number' && 
            typeof spec.Fu === 'number'
        );
        
        if (steelSpecs.length === 0) {
            console.error("No valid steel specifications found in the Excel file");
            console.log("Raw steel specs data:", rawSteelSpecs);
            useHardcodedData();
        } else {
            console.log(`Successfully loaded ${steelSpecs.length} steel specifications`);
            steelSpecs.slice(0, 5).forEach(spec => 
                console.log(`Steel: ${spec.Steel_name}, Fy: ${spec.Fy}, Fu: ${spec.Fu}`)
            );
        }
        
        // Load section data from the second sheet
        const sectionSheet = workbook.Sheets[workbook.SheetNames[1]];
        const sectionsArray = XLSX.utils.sheet_to_json(sectionSheet);
        
        // Convert array to object with section names as keys
        sectionData = {};
        sectionsArray.forEach(section => {
            if (section.AISC_Manual_Label) {
                const label = section.AISC_Manual_Label.trim().toUpperCase().replace(/\s/g, '');
                sectionData[label] = {
                    A: parseFloat(section.A) || 0,
                    tw: parseFloat(section.tw) || 0,
                    d: parseFloat(section.d) || 0,
                    bf: parseFloat(section.bf) || 0,
                    Zx: parseFloat(section.Zx) || 0,
                    Sx: parseFloat(section.Sx) || 0,
                    Ry: parseFloat(section.Ry) || 0,  // Added Ry support
                    Zy: parseFloat(section.Zy) || 0,  // Added Zy support
                    Sy: parseFloat(section.Sy) || 0,  // Added Sy support
                    "bf/2tf": parseFloat(section["bf/2tf"]) || 0,
                    "h/tw": parseFloat(section["h/tw"]) || 0,
                    Kc: parseFloat(section.Kc) || 0,
                    type: label.startsWith('L') ? 'L' : 
                           label.startsWith('W') ? 'W' : 'Other',  // Added section type detection
                    AISC_Manual_Label: label
                };
            }
        });
        
        console.log(`Loaded ${Object.keys(sectionData).length} sections`);
        
        // Try to load beam data from third sheet if it exists
        if (workbook.SheetNames.length > 2) {
            const beamSheet = workbook.Sheets[workbook.SheetNames[2]];
            const beamsArray = XLSX.utils.sheet_to_json(beamSheet);
            
            beamData = {};
            beamsArray.forEach(beam => {
                if (beam.BeamID) {
                    beamData[beam.BeamID] = beam;
                }
            });
            
            console.log(`Loaded ${Object.keys(beamData).length} beam entries`);
        }
        
        // Remove loading indicator
        if (document.getElementById('loading-indicator')) {
            document.getElementById('loading-indicator').remove();
        }
        
        return true;
    } catch (error) {
        console.error("Error loading Excel data:", error);
        
        // Update loading indicator
        if (document.getElementById('loading-indicator')) {
            document.getElementById('loading-indicator').innerHTML = 'Failed to load data. Using defaults.';
            document.getElementById('loading-indicator').style.backgroundColor = '#ffcccc';
            
            setTimeout(() => {
                if (document.getElementById('loading-indicator')) {
                    document.getElementById('loading-indicator').remove();
                }
            }, 3000);
        }
        
        // Use hardcoded data as fallback
        useHardcodedData();
        
        return false;
    }
}

// Function to provide hardcoded data fallback
function useHardcodedData() {
    // Default steel specifications
    const hardcodedSteelSpecs = [
        { Steel_name: "A36", Fy: 36, Fu: 58 },
        { Steel_name: "A572Gr.42", Fy: 42, Fu: 60 },
        { Steel_name: "A572Gr.50", Fy: 50, Fu: 65 },
        { Steel_name: "A572Gr.55", Fy: 55, Fu: 70 },
        { Steel_name: "A572Gr.60", Fy: 60, Fu: 75 },
        { Steel_name: "A572Gr.65", Fy: 65, Fu: 80 },
        { Steel_name: "A588Gr.42", Fy: 42, Fu: 63 },
        { Steel_name: "A588Gr.46", Fy: 46, Fu: 67 },
        { Steel_name: "A588Gr.50", Fy: 50, Fu: 70 },
        { Steel_name: "A687", Fy: 50, Fu: 70 },
        { Steel_name: "A992", Fy: 50, Fu: 65 }
    ];
    
    // Common W and L shapes with their properties
    const hardcodedSectionData = {
        "W12X45": { 
            A: 13.2, tw: 0.335, d: 12.1, bf: 8.05, 
            Zx: 88.6, Sx: 78.0, Ry: 2.45, Zy: 16.4, Sy: 13.6,
            "bf/2tf": 8.5, "h/tw": 29.9, Kc: 0.707, 
            type: 'W', AISC_Manual_Label: "W12X45" 
        },
        "W10X33": { 
            A: 9.71, tw: 0.29, d: 9.73, bf: 5.77, 
            Zx: 42.1, Sx: 36.6, Ry: 2.18, Zy: 8.7, Sy: 7.5,
            "bf/2tf": 9.15, "h/tw": 27.9, Kc: 0.707, 
            type: 'W', AISC_Manual_Label: "W10X33" 
        },
        "L4X3X3/8": {
            A: 4.22, tw: 0.375, d: 4.0, bf: 3.0, 
            Zx: 6.92, Sx: 5.64, Ry: 1.47, Zy: 2.83, Sy: 2.37,
            "bf/2tf": 4.0, "h/tw": 8.0, Kc: 0.707, 
            type: 'L', AISC_Manual_Label: "L4X3X3/8"
        },
        "L5X3X1/2": {
            A: 6.72, tw: 0.5, d: 5.0, bf: 3.0, 
            Zx: 13.5, Sx: 11.2, Ry: 1.82, Zy: 5.51, Sy: 4.65,
            "bf/2tf": 3.0, "h/tw": 8.0, Kc: 0.707, 
            type: 'L', AISC_Manual_Label: "L5X3X1/2"
        },
        "W8X24": { 
            A: 7.08, tw: 0.25, d: 7.93, bf: 6.5, 
            Zx: 23.2, Sx: 20.9, Ry: 2.05, Zy: 5.2, Sy: 4.8,
            "bf/2tf": 10.8, "h/tw": 26.0, Kc: 0.707, 
            type: 'W', AISC_Manual_Label: "W8X24" 
        }
    };
    
    // Set the data in both global and window scopes to ensure access
    window.steelSpecs = hardcodedSteelSpecs;
    window.sectionData = hardcodedSectionData;
    steelSpecs = hardcodedSteelSpecs;
    sectionData = hardcodedSectionData;
    
    console.log("Using hardcoded data with", Object.keys(hardcodedSectionData).length, "sections");
}

// Function to get section data with improved error handling
function getSectionData(sectionKey) {
    if (!sectionKey) {
        console.error("No section key provided");
        return null;
    }
    
    // Normalize the input key by removing spaces and ensuring uppercase
    const normalizedKey = sectionKey.toString().toUpperCase().replace(/\s/g, '');
    console.log("Looking for section:", normalizedKey);
    
    // Direct lookup
    if (sectionData[normalizedKey]) {
        console.log("Section found directly:", normalizedKey);
        return sectionData[normalizedKey];
    }
    
    // Try alternative formats
    const alternatives = [
        normalizedKey.replace('X', 'x'),          // Try with lowercase x
        normalizedKey.replace('x', 'X'),          // Try with uppercase X
        `W${normalizedKey.replace(/^W/i, '')}`,   // Ensure W prefix
        `WX${normalizedKey.replace(/^W(?:X)?/i, '')}`, // Try WX format
        `L${normalizedKey.replace(/^L/i, '')}`,   // Ensure L prefix
        `L${normalizedKey.replace(/^L/i, '').replace('X', 'X')}`  // L shape variations
    ];
    
    for (const altKey of alternatives) {
        if (sectionData[altKey]) {
            console.log("Section found with alternative format:", altKey);
            return sectionData[altKey];
        }
    }
    
    // Look for similar keys, now including both W and L sections
    const similarKeys = Object.keys(sectionData).filter(key => 
        key.includes(normalizedKey.replace(/^[WL]/, '')) || 
        normalizedKey.includes(key.replace(/^[WL]/, ''))
    );
    
    if (similarKeys.length > 0) {
        console.log("Similar keys found:", similarKeys);
        console.log("Using first similar key:", similarKeys[0]);
        return sectionData[similarKeys[0]];
    }
    
    console.warn("Section not found:", normalizedKey);
    console.log("Available keys:", Object.keys(sectionData).slice(0, 10).join(", ") + "...");
    
    // Return default values if not found, now including Ry and type
    return {
        A: 13.2, 
        tw: 0.335, 
        d: 12.1, 
        bf: 8.05,
        Zx: 88.6,
        Sx: 78.0,
        Ry: 2.45,
        Zy: 16.4,
        Sy: 13.6,
        "bf/2tf": 8.5,
        "h/tw": 29.9,
        Kc: 0.707,
        type: 'W',
        AISC_Manual_Label: "W12X45 (DEFAULT)"
    };
}

// Function to get steel specification data
function getSteelSpecData(steelName) {
    if (!steelName) {
        console.error("No steel specification name provided");
        return null;
    }
    
    // Normalize the input
    const normalizedName = steelName.toString().toUpperCase().replace(/\s/g, '');
    
    // Find the steel specification
    const spec = steelSpecs.find(s => 
        s.Steel_name.toUpperCase().replace(/\s/g, '') === normalizedName
    );
    
    if (spec) {
        return spec;
    }
    
    console.warn("Steel specification not found:", normalizedName);
    
    // Return default values if not found
    return {
        Steel_name: "A36 (DEFAULT)",
        Fy: 36,
        Fu: 58
    };
}

// Function to update shape options for datalist input
function updateShapeOptions() {
    const datalist = document.getElementById('sectionShapes');
    
    // Clear existing options
    if (datalist) {
        datalist.innerHTML = '';
        
        // Add W-shapes and L-shapes to the datalist
        Object.keys(sectionData).forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            datalist.appendChild(option);
        });
        
        console.log("Updated section shape options");
    } else {
        console.warn("Could not find datalist for section shapes");
    }
}

// Function to ensure SheetJS is loaded
function addExcelLibrary() {
    return new Promise((resolve, reject) => {
        // Check if SheetJS is already loaded
        if (window.XLSX) {
            console.log("SheetJS already loaded");
            resolve();
            return;
        }
        
        console.log("Loading SheetJS...");
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js';
        script.onload = () => {
            console.log("SheetJS loaded successfully");
            resolve();
        };
        script.onerror = () => {
            console.error("Failed to load SheetJS");
            reject(new Error("Failed to load SheetJS library"));
        };
        document.head.appendChild(script);
    });
}















// Function to calculate tension member design
function designTensionMember() {
    // Get input values
    const designMethod = document.getElementById('designMethod').value;
    const steelSpec = document.getElementById('ASpecD').value;
    const sectionShape = document.getElementById('sectionShapeD').value; // Add section shape input
    const deadLoad = parseFloat(document.getElementById('Dload').value) || 0;
    const liveLoad = parseFloat(document.getElementById('Lload').value) || 0;
    const length = parseFloat(document.getElementById('LenghtD').value) || 0;
    const boltDiameter = parseFloat(document.getElementById('dholeD').value) || 0;
    const numberOfHoles = parseInt(document.getElementById('nholeD').value) || 0;

    // Validate inputs
    if (isNaN(deadLoad) || isNaN(liveLoad) || isNaN(length) || isNaN(boltDiameter) || isNaN(numberOfHoles)) {
        alert('Please fill in all input fields with valid numbers');
        return;
    }

    // Get steel specification data
    const steelData = getSteelSpecData(steelSpec);
    const Fy = steelData.Fy; // Yield strength
    const Fu = steelData.Fu; // Ultimate strength

    // Calculate load combinations
    let Tu, phiFy, phiFu;
    if (designMethod === 'LRFD') {
        // LRFD Load Combination: 1.2D + 1.6L
        Tu = 1.2 * deadLoad + 1.6 * liveLoad;
        phiFy = 0.90 * Fy; // Resistance factor for yielding
        phiFu = 0.75 * Fu; // Resistance factor for fracture
        document.getElementById('LRFDdesignComb').textContent = Tu.toFixed(2) + ' kips';
    } else { // ASD
        // ASD Load Combination: 1.4D
        Tu = 1.4 * deadLoad;
        phiFy = Fy / 1.67; // ASD adjustment
        phiFu = Fu / 2.00; // ASD adjustment
        document.getElementById('ASDdesignComb').textContent = Tu.toFixed(2) + ' kips';
    }

    // Calculate required gross area for yielding
    const AgYielding = Tu / phiFy;
    const AgFracture = (Tu / (0.75 * Fu)) / 0.85; // Calculating net area with shear lag

    // Determine controlling gross area requirement
    const governingAg = Math.max(AgYielding, AgFracture);
    
    // Calculate hole area
    const Ahole = boltDiameter * numberOfHoles * (length * 12 / 1000); // Assuming thickness is 1/8 inch

    // Calculate minimum radius of gyration for L/300 deflection limit
    const L_over_300 = length * 12 / 300; // Convert length to inches and divide by 300

    // Find suitable shapes
    const suitableShapes = [];
    
    // Scan through section data with improved filtering
    Object.keys(sectionData).forEach(shapeKey => {
        const shape = sectionData[shapeKey];
        
        // Check if the shape's gross area meets the requirement and matches the preferred type (if specified)
        const areaCheck = shape.A >= governingAg;
        const typeCheck = !sectionShape || 
            (sectionShape.toUpperCase().startsWith('W') && shape.type === 'W') ||
            (sectionShape.toUpperCase().startsWith('L') && shape.type === 'L');
        
        if (areaCheck && typeCheck) {
            // Calculate Rz (minimum radius of gyration in the weakest axis)
            const Rz = shape.type === 'W' ? Math.min(shape.Ry, shape.Rz || 1) : 
                       shape.type === 'L' ? shape.Ry : 1;
            
            // Check deflection limit
            const shapeRmin = length * 12 / (300 * Rz);
            
            suitableShapes.push({
                shape: shapeKey,
                area: shape.A,
                demand: governingAg,
                weight: calculateWeight(shape.A, length), // Assuming 10 lb/ft per sq inch
                ahole: Ahole,
                Rz: Rz,
                rmin: shapeRmin,
                status: shapeRmin >= Rz ? 'Safe' : 'Check Deflection'
            });
        }
    });

    // Sort shapes by multiple criteria
    suitableShapes.sort((a, b) => {
        // First, prioritize safe shapes
        if (a.status === 'Safe' && b.status !== 'Safe') return -1;
        if (a.status !== 'Safe' && b.status === 'Safe') return 1;
        
        // Then sort by weight
        return a.weight - b.weight;
    });

    // Display results
    const resultsToDisplay = suitableShapes.slice(0, 4); // Top 4 shapes
    
    // Clear any existing results
    for (let rank = 1; rank <= 4; rank++) {
        document.getElementById(`rank${rank}`).textContent = '-';
        document.getElementById(`Shape${rank}`).textContent = '-';
        document.getElementById(`AreaG${rank}`).textContent = '-';
        document.getElementById(`D${rank}`).textContent = '-';
        document.getElementById(`Weight${rank}`).textContent = '-';
        document.getElementById(`Ahole${rank}`).textContent = '-';
        document.getElementById(`Rz${rank}`).textContent = '-';
        document.getElementById(`rmin${rank}`).textContent = '-';
        document.getElementById(`Status${rank}`).textContent = '-';
    }
    
    // Populate results table
    resultsToDisplay.forEach((result, index) => {
        const rank = index + 1;
        document.getElementById(`rank${rank}`).textContent = rank;
        document.getElementById(`Shape${rank}`).textContent = result.shape;
        document.getElementById(`AreaG${rank}`).textContent = result.area.toFixed(2);
        document.getElementById(`D${rank}`).textContent = result.demand.toFixed(2);
        document.getElementById(`Weight${rank}`).textContent = result.weight.toFixed(2);
        document.getElementById(`Ahole${rank}`).textContent = result.ahole.toFixed(2);
        document.getElementById(`Rz${rank}`).textContent = result.Rz.toFixed(2);
        document.getElementById(`rmin${rank}`).textContent = result.rmin.toFixed(2);
        document.getElementById(`Status${rank}`).textContent = result.status;
    });

    // Update yielding and fracture calculations
    document.getElementById('LRFDYielding').textContent = AgYielding.toFixed(2);
    document.getElementById('ASDYielding').textContent = AgYielding.toFixed(2);
    document.getElementById('LRFDFracture').textContent = AgFracture.toFixed(2);
    document.getElementById('ASDFracture').textContent = AgFracture.toFixed(2);
    
    // Determine controlling requirement and show deflection limit
    document.querySelector('.controlR').textContent = 
        AgYielding > AgFracture ? 'Yielding' : 'Fracture';
    
    // Display deflection limit calculation
    document.getElementById('deflectionLimit').textContent = `L/300 Rmin: ${rmin.toFixed(4)}`;
}
// Add event listener to design button
document.addEventListener('DOMContentLoaded', function() {
    const designButton = document.getElementById('design');
    if (designButton) {
        designButton.addEventListener('click', designTensionMember);
    } else {
        console.error("Design button not found");
    }
});

// Ensure SheetJS and other libraries are loaded
document.addEventListener('DOMContentLoaded', function() {
    // Add SheetJS library
    addExcelLibrary()
        .then(() => {
            // Attempt to load Excel data
            return loadExcelData();
        })
        .catch(error => {
            console.error("Error initializing application:", error);
            // Fallback to hardcoded data
            useHardcodedData();
        });
});



    </script>
</body>
</html>