<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Principle of Steel Design</title>
    <link rel="stylesheet" href="style.css"/>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
    <header>
        <div class="header"><b>STEEL DESIGN HELPER</b></div>
        
    </header>

    <nav class="navbar">
        <div class="ADcon">
            <a class="con" href="index.html">|HOME|</a>
            <a class="con" id="active" href="Analysis and Design for Axial Tension.html">|Analysis and Design for Axial Tension|</a>
            <a class="con" href="Analysis and Design for Axial Compression.html">|Analysis and Design for Axial Compression|</a>
            <a class="con" href="Analysis and Design of Members for Bending.html">|Analysis and Design of Members for Bending|</a>
            <a class="con" href="Shear Strength of Structural Member.html">|Shear Strength of Structural Member|</a>
        </div>
    </nav>

    <div class="AnalysisAxialTen">
        <div class="AxielT" style="display: in;">
            <h1 >Analysis of Tension Member</h1>
        </div>
        <div class="AxialTenionmember">

        <div class="AnalysisTen">
            <div id="ASTMSPEC" class="AxialTen">
                <form>
                    <h2>ASTM SPECIFICATION</h2>
                    <select id="ASpecA">
                        <option value="A36">A36</option>
                        <option value="A572Gr.42">A572 Gr. 42</option>
                        <option value="A572Gr.50">A572 Gr. 50</option>
                        <option value="A572Gr.55">A572 Gr. 55</option>
                        <option value="A572Gr.60">A572 Gr. 60</option>
                        <option value="A572Gr.65">A572 Gr. 65</option>
                        <option value="A588Gr.42">A588 Gr. 42</option>
                        <option value="A588Gr.46">A588 Gr. 46</option>
                        <option value="A588Gr.50">A588 Gr. 50</option>
                        <option value="A687">A687</option>
                        <option value="A992">A992</option>
                    </select>

                    <h2>HOLE</h2>
                    <label>Diameter of bolts:</label>
                    <input type="number" id="dholeA" step="0.001" placeholder="inches" required><br>
                    <label>Number of holes per column (max 6):</label>
                    <input type="number" id="nholeC" min="1" max="6" value="3"/><br>
                    <label>Number of holes per row (max 6):</label>
                    <input type="number" id="nholeR" min="1" max="6" value="3"/>

                    <h2>SHEAR LAG FACTOR</h2>
                    <select id="ulagCase">
                        <option value="1">Case 1</option>
                        <option value="2">Case 2</option>
                        <option value="7">Case 7</option>
                        <option value="8">Case 8</option>
                    </select>
                    <label>Length (in):</label>
                    <input type="number" id="lengthA" placeholder="Length">

                    <h2>STEEL</h2>
                    <label>Shape:</label>
                    <select id="shapeA">
                        <option value="W">W</option>
                         <option value="W">L</option>
                    </select>
                    <label>Dimension:</label>
                    <input type="text" id="dimA" placeholder="12X45" required>

                    <div class="blockstag-column">
                        <div id="blockShearInputs" style="display:none;">
                            <label>Agv:</label><input type="number" id="Agv" placeholder="in²" step="0.001"><br>
                            <label>Anv:</label><input type="number" id="Anv" placeholder="in²" step="0.001"><br>
                            <label>Ant:</label><input type="number" id="Ant" placeholder="in²" step="0.001">
                        </div>
                    </div>

                    <h2>CHOOSE ONE OPTION ONLY</h2>
                    <label><input type="radio" name="designOption" value="none" checked> No Block Shear or Stagger</label><br>
                    <label><input type="radio" name="designOption" value="block"> Include Block Shear Only</label><br>
                    <label><input type="radio" name="designOption" value="stagger"> Include Staggered Holes Only</label><br>

                    <input type="button" class="Calculate" value="Calculate">

                </form>
                
            </div>

            <div class="AxialTenR" id="Result">
                <div class="YS"><div class="RESULT"><p class="YSt">GROSS CROSS SECTION:</p><p id="AG" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">NET AREA:</p><p id="AE" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">YIELDING IN GROSS CROSS SECTION: </p><p id="YC" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">FRACTURE IN EFFECTIVE NET AREA:</p><p id="FS" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">LRFD:</p><p id="LRFD" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">ASD:</p><p id="ASD" style="color:red;"></p></div></div>
                <!-- New result display for staggered hole calculations -->
                <div class="YS" id="failurePathResult" style="display:none;">
                    <div class="RESULT"><p class="YSt">ZIGZAG FAILURE PATH:</p><p id="criticalPath" style="color:red;"></p></div>
                </div>
                <div class="YS" id="staggerReductionResult" style="display:none;">
                    <div class="RESULT"><p class="YSt">STAGGER REDUCTION:</p><p id="staggerReduction" style="color:red;"></p></div>
                </div>
                <div></div>
            </div>
        </div>

        <div id="shearDiv" class="BLOCKSTAGGER" style="display:none;">
            

            <div id="column-inputs">
                <h3>Remove Specific Hole</h3>
                <div class="control-section">
                    <div class="control-group">
                        <label for="removeRow">Row (1–6):</label>
                        <input type="number" id="removeRow" min="1" max="6" placeholder="1–6">
                        
                        <label for="removeCol">Column (1–6):</label>
                        <input type="number" id="removeCol" min="1" max="6" placeholder="1–6">
                        
                        <button onclick="removeSpecificHole()">Remove Hole</button>
                    </div>
            
                    <div class="control-group">
                        <label for="removeHoleCol">Remove Entire Column (1–6):</label>
                        <input type="number" id="removeHoleCol" min="1" max="6" placeholder="Column #">
                        <button onclick="removeHoleColumn()">Remove Column</button>
                    </div>
            
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button class="restore-btn" onclick="restoreAllHoles()">Restore All Holes</button>
                    </div>
            
                    <div class="control-group">
                        <label for="spacingS">Horizontal spacing (s):</label>
                        <input type="number" id="spacingS" value="2" step="0.1" class="stagger-input"> in
            
                        <label for="spacingG">Vertical spacing (g):</label>
                        <input type="number" id="spacingG" value="1.5" step="0.1" class="gauge-input"> in
                    </div>
                </div>
            
                <div id="dynamicFlange" style="position:relative; width:400px; height:300px; border:2px solid black; background:#f0f0f0; margin-top:20px;"></div>
            </div>
        </div>
   
        <div class="DesignAxialTen">
        <hr>
        <div class="AxialD">
            <h1 style="text-align: center;">Design of Tension Member</h1>
        </div>
        <div class="DesignT">
            <div class="DesignTenData">
                
                <div>
            
                <form action="">
                    <div class="input-group">
                        <label for="designMethod">Design Method:</label>
                        <select id="designMethod">
                            <option value="LRFD">LRFD</option>
                            <option value="ASD">ASD</option>
                        </select>
                    </div>
                    
                    <label>ASTM Specification</label>
                    <select id="ASpecD" name="ASTM SPECIFICATION">
                        <option value="A36">A36</option>
                        <option value="A572Gr.42">A572 Gr. 42</option>
                        <option value="A572Gr.50">A572 Gr. 50</option>
                        <option value="A572Gr.55">A572 Gr. 55</option>
                        <option value="A572Gr.60">A572 Gr. 60</option>
                        <option value="A572Gr.65">A572 Gr. 65</option>
                        <option value="A588Gr.42">A588 Gr. 42</option>
                        <option value="A588Gr.46">A588 Gr. 46</option>
                        <option value="A588Gr.50">A588 Gr. 50</option>
                        <option value="A687">A687</option>
                        <option value="A992">A992</option>
                       
                    </select>
                </div>
                <div>
                    Shear Lag:
                    <select id="ulagCase"> 
                        <option value="1">Case 1</option>
                        <option value="2">Case 2</option>
                        <option value="7">Case 7</option>
                        <option value="8">Case 8</option>
                    </select>
                 </div>
                 <div>

                    <label for="DeadDload">Dead Load:</label>
                    <input id="Dload" type="number" placeholder="kips">
                </div>
                <div>
                    <label for="Lload">Live Load:</label>
                    <input id="Lload" type="number" placeholder="kips">
                 </div>
                 <div>
                    <label for="length">Length:</label>
                    
                    <input id="LenghtD" type="number" placeholder="ft."  step="0.001">
                </div>
                    <div>

                    <label for="dholeD"  >Diameter  of Bolts:</label>
                    <input id="dholeD" typ="numebr" placeholder="in."  step="0.001">
                    </div>  

                    
                    <div><label>number of holes</label>
                    <input class="nholeD" placeholder="in." type="number" > </div>
                   

                    
            </form>
             <button class="Design" id="design">DESIGN</button> 



            
            </div>
    

        </div>

    </div>
    <div class="DesignTRes">
        <div class="DesignCalcT">
            
            <h1>Design Calculation</h1>
            <div class="LRFDdis">
                <H2>Step 1: Load Combinations</H2>

            <h4>LRFD Load Combination: 1.2D + 1.6L=<p id="LRFDdesignComb"></p></h4> <h4>ASD Load Combination: 1.4D =<p id="ASDdesignComb"></p></h4>
            </div> 
        </div>    
            <div class="DesignCalcT">
            <h2>Step 2: Required Area Calculation</h2>
            <h3>For Yielding (LRFD):</h3>
            <h4>Pu ≤ φPn = φFyAg <br>
                Ag ≥ Pu / (φFy) = <p id="LRFDYielding"></p></h4>
                <h3>For Yielding (ASD):</h3>
            <h4>TnΩ = FyAg/Ω = FyAg /1.67 <br>
                Ag ≥ Pu / (φFy) = <p id="ASDYielding"></p></h4>
                <h3>For Fracture (LRFD):</h3>
                <h4>Pu ≤ φPn = φFuAe = <p id="LRFDFracture"></p></p></h4>
                <h3>For Fracture (ASD):</h3>
                <h4>Tn/Ω = FuAe/Ω = FuAe/2.00 <p id="ASDFracture"></p></p></h4>

            <H3 >Controlling Ag requirement: <p class="controlR"></p></H3>     
        </div>
                                <div class="DesignCon">
                                                     <div class="recommended-shapes">
                 <h2>Recommended W Shapes</h2>
                <p>The following shapes provide sufficient area for the tension member:</p>
                
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Shape</th>
                            <th>Area Gross (in²)</th>
                            <th>Demand</th>
                            <th>Weight (lb/ft)</th>
                            <th>Ahole</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td id="rank1"></td>
                            <td id="Shape1"></td>
                            <td id="AreaG1"></td>
                            <td id="D1"></td>
                            <td id="Weight1"></td>
                            <td id="Ahole1"></td>
                            <td id="Status1"></td>
                        </tr>
                        <tr>
                            <td id="rank2"></td>
                            <td id="Shape2"></td>
                            <td id="AreaG2"></td>
                            <td id="D2"></td>
                            <td id="Weight2"></td>
                            <td id="Ahole2"></td>
                            <td id="Status2"></td>
                        </tr>
                        <tr>
                            <td id="rank3"></td>
                            <td id="Shape3"></td>
                            <td id="AreaG3"></td>
                            <td id="D3"></td>
                            <td id="Weight3"></td>
                            <td id="Ahole3"></td>
                            <td id="Status3"></td>
                        </tr>
                        <tr>
                            <td id="rank4"></td>
                            <td id="Shape4"></td>
                            <td id="AreaG4"></td>
                            <td id="D4"></td>
                            <td id="Weight4"></td>
                            <td id="Ahole4"></td>
                            <td id="Status4"></td>
                        </tr>
                        
                    </tbody>
                </table>
                
                
                
               
                                        </div>
                                                    </div>

        
            
 
   
   
    </div>
</div>
    <script>
    
 // Add a loading state
let dataLoaded = false;
let steelData = {}; // Define steelData object if not already defined elsewhere

function loadExcelData() {
    console.log("Loading Excel data...");
    dataLoaded = false;
    
    // Show loading indicator
    const loadingIndicator = document.createElement('div');
    loadingIndicator.id = 'loading-indicator';
    loadingIndicator.innerHTML = 'Loading steel section data...';
    loadingIndicator.style.position = 'fixed';
    loadingIndicator.style.top = '10px';
    loadingIndicator.style.right = '10px';
    loadingIndicator.style.padding = '5px 10px';
    loadingIndicator.style.backgroundColor = '#ffe0e0';
    loadingIndicator.style.border = '1px solid #ffcccc';
    loadingIndicator.style.borderRadius = '3px';
    loadingIndicator.style.zIndex = '1000';
    document.body.appendChild(loadingIndicator);
    
    fetch('ASTMSPEC.xlsx')
        .then(res => res.arrayBuffer())
        .then(data => {
            const workbook = XLSX.read(data, { type: 'array' });
            const shapeSheet = workbook.Sheets[workbook.SheetNames[1]];
            const shapeRows = XLSX.utils.sheet_to_json(shapeSheet);

            console.log("Excel data loaded, processing", shapeRows.length, "rows");
            
            shapeRows.forEach(row => {
                if (row["AISC_Manual_Label"]) {
                    const label = row["AISC_Manual_Label"].trim().toUpperCase().replace(/\s/g, '');
                    
                    // Store data based on section type
                    if (label.startsWith('W')) {
                        // W shape (wide flange)
                        steelData[label] = {
                            type: 'W',
                            A: parseFloat(row.A),
                            tw: parseFloat(row.tw),
                            d: parseFloat(row.d),
                            bf: parseFloat(row.bf)
                        };
                    } else if (label.startsWith('L')) {
                        // L shape (angle)
                        steelData[label] = {
                            type: 'L',
                            A: parseFloat(row.A),
                            t: parseFloat(row.t),          // thickness
                            b: parseFloat(row.b),          // longer leg
                            d: parseFloat(row.d)           // shorter leg
                        };
                    }
                }
            });
            
            console.log("Steel data loaded:", Object.keys(steelData).length, "sections");
            dataLoaded = true;
            
            // Remove loading indicator
            document.getElementById('loading-indicator').remove();
        })
        .catch(error => {
            console.error("Error loading Excel data:", error);
            // Fallback to some default data
            steelData["W12X45"] = { 
                type: 'W',
                A: 13.2, 
                tw: 0.335, 
                d: 12.1, 
                bf: 8.05 
            };
            
            steelData["L4X3X3/8"] = { 
                type: 'L',
                A: 2.59, 
                t: 0.375, 
                b: 4.0, 
                d: 3.0 
            };
            
            // Update loading indicator
            document.getElementById('loading-indicator').innerHTML = 'Failed to load data. Using defaults.';
            document.getElementById('loading-indicator').style.backgroundColor = '#ffcccc';
            
            setTimeout(() => {
                document.getElementById('loading-indicator').remove();
            }, 3000);
            
            dataLoaded = true;
        });
}

// Add this function to debug the steel data loading
function debugSteelData(sectionKey) {
    console.log("Looking for section: " + sectionKey);
    console.log("Available steel data keys:", Object.keys(steelData));
    console.log("Found section data:", steelData[sectionKey]);
    
    // Check if we have any keys that are similar
    const similarKeys = Object.keys(steelData).filter(key => 
        key.includes(sectionKey.replace(/^[WL]/, '')) || 
        sectionKey.includes(key.replace(/^[WL]/, ''))
    );
    
    if (similarKeys.length > 0) {
        console.log("Similar keys found:", similarKeys);
    }
    
    return steelData[sectionKey];
}

// Normalize section key to handle various input formats
function normalizeSectionKey(shape, dim) {
    // Convert to uppercase and remove spaces
    shape = shape.trim().toUpperCase();
    dim = dim.trim().toUpperCase().replace(/\s/g, '');
    
    // Handle L shape special format (may contain multiple X's)
    if (shape === 'L') {
        // Ensure format is like L4X3X3/8 (no spaces)
        return shape + dim.replace(/X/g, 'X');
    }
    
    // For W shapes
    return shape + dim;
}

// Get section data with improved format handling
function getSectionData() {
    const shape = document.getElementById('shapeA').value.trim().toUpperCase();
    const dim = document.getElementById('dimA').value.trim().toUpperCase().replace(/\s/g, '');
    const sectionKey = normalizeSectionKey(shape, dim);
    
    console.log("Attempting to get section data for:", sectionKey);
    
    let section = steelData[sectionKey];
    
    // If not found, try with different formatting
    if (!section) {
        console.log("Section not found, trying alternative formats...");
        
        // Array of possible format variations
        const alternativeFormats = [];
        
        if (shape === 'W') {
            // Try alternative W formats
            alternativeFormats.push(
                shape + dim.replace('X', 'x'),
                shape + 'X' + dim.replace('X', '')
            );
        } else if (shape === 'L') {
            // Try alternative L formats - angles often have various formats
            // e.g. L4X3X3/8, L4x3x3/8, L4X3-3/8
            
            // Split the dimension by X
            const parts = dim.split('X');
            if (parts.length >= 2) {
                const leg1 = parts[0];
                const leg2 = parts.length > 1 ? parts[1] : parts[0];
                const thickness = parts.length > 2 ? parts[2] : "";
                
                alternativeFormats.push(
                    `L${leg1}X${leg2}X${thickness}`,
                    `L${leg1}x${leg2}x${thickness}`,
                    `L${leg1}X${leg2}-${thickness}`
                );
            }
        }
        
        // Try each alternative format
        for (const altFormat of alternativeFormats) {
            if (steelData[altFormat]) {
                console.log("Found with format:", altFormat);
                section = steelData[altFormat];
                break;
            }
        }
        
        // If still not found, check for similar keys as a last resort
        if (!section) {
            // For L shapes, try to match by the main dimensions
            if (shape === 'L') {
                const mainDims = dim.split('X').slice(0, 2).join('X');
                const possibleMatches = Object.keys(steelData).filter(key => 
                    key.startsWith('L') && key.includes(mainDims)
                );
                
                if (possibleMatches.length > 0) {
                    console.log("Found similar angle section:", possibleMatches[0]);
                    section = steelData[possibleMatches[0]];
                }
            } else {
                // For W shapes, try to match by the main number
                const mainNumber = dim.split('X')[0];
                const possibleMatches = Object.keys(steelData).filter(key => 
                    key.startsWith('W') && key.includes(mainNumber)
                );
                
                if (possibleMatches.length > 0) {
                    console.log("Found similar W section:", possibleMatches[0]);
                    section = steelData[possibleMatches[0]];
                }
            }
        }
    }
    
    // If still not found, log and return defaults
    if (!section) {
        // Log all available keys for debugging
        console.log("Section not found. Available keys:", Object.keys(steelData).slice(0, 10).join(", ") + "...");
        
        // Return default values based on shape type
        if (shape === 'L') {
            console.log("Using default L shape values");
            return { 
                type: 'L',
                A: 2.59, 
                t: 0.375, 
                b: 4.0, 
                d: 3.0
            };
        } else {
            console.log("Using default W shape values");
            return { 
                type: 'W',
                A: 13.2, 
                tw: 0.335, 
                d: 12.1, 
                bf: 8.05 
            };
        }
    }
    
    console.log("Section found:", section);
    return section;
}

        // Add this function to create the interactive drawing area
function createInteractiveDrawingArea() {
    const flange = document.getElementById('dynamicFlange');
    flange.innerHTML = '';
    
    // Create a grid layout that users can click to toggle holes
    const nholeC = parseInt(document.getElementById('nholeC').value);
    const nholeR = parseInt(document.getElementById('nholeR').value);
    const s = parseFloat(document.getElementById('spacingS').value);
    const g = parseFloat(document.getElementById('spacingG').value);
    const pxPerIn = 20, leftStart = 60, topStart = 40;
    
    // Create instructions
    const instructions = document.createElement('div');
    instructions.innerHTML = '<strong>Click to add/remove holes</strong>';
    instructions.style.position = 'absolute';
    instructions.style.top = '5px';
    instructions.style.left = '5px';
    instructions.style.color = 'blue';
    flange.appendChild(instructions);
    
    // Create the grid
    for (let row = 0; row < nholeC; row++) {
        for (let col = 0; col < nholeR; col++) {
            const x = leftStart + col * s * pxPerIn;
            const y = topStart + row * g * pxPerIn;
            
            // Create grid cell background
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.style.width = '20px';
            cell.style.height = '20px';
            cell.style.border = '1px dashed #ccc';
            cell.style.position = 'absolute';
            cell.style.left = `${x - 5}px`;
            cell.style.top = `${y - 5}px`;
            cell.dataset.row = row + 1;
            cell.dataset.col = col + 1;
            flange.appendChild(cell);
            
            // Create hole (initially with full opacity)
            const hole = document.createElement('div');
            hole.className = 'hole';
            hole.style.width = '10px';
            hole.style.height = '10px';
            hole.style.borderRadius = '50%';
            hole.style.backgroundColor = 'black';
            hole.style.position = 'absolute';
            hole.style.left = `${x}px`;
            hole.style.top = `${y}px`;
            hole.dataset.row = row + 1;
            hole.dataset.col = col + 1;
            hole.dataset.active = '1'; // Default is active
            flange.appendChild(hole);
            
            // Make holes clickable
            hole.addEventListener('click', function() {
                if (this.dataset.active === '1') {
                    this.style.opacity = '0.2';
                    this.dataset.active = '0';
                    removedHoles.add(`${this.dataset.row}-${this.dataset.col}`);
                } else {
                    this.style.opacity = '1';
                    this.dataset.active = '1';
                    removedHoles.delete(`${this.dataset.row}-${this.dataset.col}`);
                }
            });
            
            // Add spacing labels
            if (row < nholeC - 1 && col === 0) {
                const label = document.createElement('div');
                label.style.position = 'absolute';
                label.style.left = `${x - 30}px`;
                label.style.top = `${y + g * pxPerIn / 2 - 8}px`;
                label.style.color = 'red';
                label.innerHTML = `${g}"`;
                flange.appendChild(label);
            }
            
            if (col < nholeR - 1 && row === 0) {
                const hLabel = document.createElement('div');
                hLabel.style.position = 'absolute';
                hLabel.style.left = `${x + s * pxPerIn / 2 - 8}px`;
                hLabel.style.top = `${y - 20}px`;
                hLabel.style.color = 'red';
                hLabel.innerHTML = `${s}"`;
                flange.appendChild(hLabel);
            }
        }
    }
    
    // Add clear and fill buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.position = 'absolute';
    buttonContainer.style.bottom = '10px';
    buttonContainer.style.right = '10px';
    
    const clearBtn = document.createElement('button');
    clearBtn.innerText = 'Clear All Holes';
    clearBtn.onclick = function() {
        document.querySelectorAll('.hole').forEach(hole => {
            hole.style.opacity = '0.2';
            hole.dataset.active = '0';
            removedHoles.add(`${hole.dataset.row}-${hole.dataset.col}`);
        });
    };
    
    const fillBtn = document.createElement('button');
    fillBtn.innerText = 'Fill All Holes';
    fillBtn.onclick = function() {
        document.querySelectorAll('.hole').forEach(hole => {
            hole.style.opacity = '1';
            hole.dataset.active = '1';
            removedHoles.delete(`${hole.dataset.row}-${hole.dataset.col}`);
        });
    };
    
    buttonContainer.appendChild(clearBtn);
    buttonContainer.appendChild(document.createTextNode(' '));
    buttonContainer.appendChild(fillBtn);
    flange.appendChild(buttonContainer);
}

// Replace updateHoleLayout with the interactive drawing version
function updateHoleLayout() {
    createInteractiveDrawingArea();
}

        // Global variables
        let removedHoles = new Set();

        // ASTM material properties
        const astmData = {
            "A36": { Fy: 36, Fu: 58 }, 
            "A572GR42": { Fy: 42, Fu: 60 }, 
            "A572GR50": { Fy: 50, Fu: 65 },
            "A572GR55": { Fy: 55, Fu: 70 }, 
            "A572GR60": { Fy: 60, Fu: 75 }, 
            "A572GR65": { Fy: 65, Fu: 80 },
            "A588GR42": { Fy: 42, Fu: 63 }, 
            "A588GR46": { Fy: 46, Fu: 67 }, 
            "A588GR50": { Fy: 50, Fu: 70 },
            "A687": { Fy: 45, Fu: 75 }, 
            "A992": { Fy: 50, Fu: 65 }
        };


const styleElement = document.createElement('style');
styleElement.textContent = `
    .hole {
        cursor: pointer;
        transition: opacity 0.2s;
    }
    .hole:hover {
        box-shadow: 0 0 5px blue;
    }
    .grid-cell:hover {
        background-color: rgba(200, 200, 255, 0.3);
    }
    #dynamicFlange button {
        margin: 0 5px;
        padding: 5px 10px;
        background-color: #f0f0f0;
        border: 1px solid #999;
        border-radius: 3px;
        cursor: pointer;
    }
    #dynamicFlange button:hover {
        background-color: #e0e0e0;
    }
`;
document.head.appendChild(styleElement);

        // Toggle display based on design option
        function toggleShearDiv() {
    const selection = document.querySelector('input[name="designOption"]:checked').value;
    document.getElementById('shearDiv').style.display = (selection !== 'none') ? 'block' : 'none';
    document.getElementById('blockShearInputs').style.display = selection === 'block' ? 'block' : 'none';
    document.getElementById('column-inputs').style.display = selection === 'stagger' ? 'block' : 'none';
    document.getElementById('failurePathResult').style.display = selection === 'stagger' ? 'block' : 'none';
    document.getElementById('staggerReductionResult').style.display = selection === 'stagger' ? 'block' : 'none';
    
    // Initialize drawing area if stagger option is selected
    if (selection === 'stagger') {
        createInteractiveDrawingArea();
    }
}


function getHolePattern() {
    const nholeC = parseInt(document.getElementById('nholeC').value);
    const nholeR = parseInt(document.getElementById('nholeR').value);
    const pattern = [];
    
    for (let row = 0; row < nholeC; row++) {
        pattern[row] = [];
        for (let col = 0; col < nholeR; col++) {
            const holeElement = document.querySelector(`.hole[data-row="${row+1}"][data-col="${col+1}"]`);
            if (holeElement && holeElement.dataset.active === '1') {
                pattern[row][col] = 1; // Active hole
            } else {
                pattern[row][col] = 0; // Inactive hole
            }
        }
    }
      return pattern;
}

        
        // Get form input values
        function getInputValues() {
            return {
                ASTM: document.getElementById('ASpecA').value.toUpperCase().replace(/\./g, ''),
                dhole: parseFloat(document.getElementById('dholeA').value),
                nholeC: parseInt(document.getElementById('nholeC').value),
                nholeR: parseInt(document.getElementById('nholeR').value),
                spacingS: parseFloat(document.getElementById('spacingS').value),
                spacingG: parseFloat(document.getElementById('spacingG').value),
                caseId: document.getElementById('ulagCase').value,
                length: parseFloat(document.getElementById('lengthA').value),
                shape: document.getElementById('shapeA').value.toUpperCase(),
                dim: document.getElementById('dimA').value.toUpperCase().replace(/\s/g, ''),
                designOption: document.querySelector('input[name="designOption"]:checked').value
            };
        }

        // Calculate shear lag factor U
        function calculateU(caseId, xbar, length, bf, d) {
            switch (parseInt(caseId)) {
                case 1: return 1.0;
                case 2: 
                    const case2Value = 1 - (xbar / length);
                    return case2Value;
                case 7: 
                    const case2ForComp = 1 - (xbar / length);
                    return Math.max(bf / d >= 2 / 3 ? 0.9 : 0.8, case2ForComp);
                case 8: return 0.8;
                default: return 1.0;
            }
        }

        function updateColumnControls() {
    const columnInputs = document.getElementById('column-inputs');
    columnInputs.innerHTML = `
        <h3>Interactive Hole Pattern</h3>
        <div class="control-section">
            <div class="control-group">
                <label for="spacingS">Horizontal spacing (s):</label>
                <input type="number" id="spacingS" value="2" step="0.1" class="stagger-input"> in
                
                <label for="spacingG">Vertical spacing (g):</label>
                <input type="number" id="spacingG" value="1.5" step="0.1" class="gauge-input"> in
                
                <button onclick="updateGrid()">Update Grid</button>
            </div>
            
            <div class="control-group" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ccc;">
                <h4>Path Calculation Options</h4>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathAuto" name="pathMethod" value="auto" checked>
                    <label for="pathAuto">Find critical path automatically</label>
                </div>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathManual" name="pathMethod" value="manual">
                    <label for="pathManual">Specify custom path</label>
                </div>
                
                <div id="customPathContainer" style="margin-top: 10px; display: none;">
                    <label for="customPathInput">Custom Path (format: 1-1,1-2,2-3,...):</label><br>
                    <input type="text" id="customPathInput" placeholder="row-col,row-col,..." style="width: 90%; margin-top: 5px;">
                    <div style="margin-top: 5px; font-size: 0.85em; color: #666;">
                        Example: 1-1,1-2,2-3 means path from hole (1,1) → (1,2) → (2,3)
                    </div>
                    <button id="visualizePath" style="margin-top: 8px;">Visualize Path</button>
                </div>
            </div>
        </div>
        
        <div id="dynamicFlange" style="position:relative; width:400px; height:300px; border:2px solid black; background:#f0f0f0; margin-top:20px;"></div>
    `;
    
    // Add event listeners for the spacing inputs
    document.getElementById('spacingS').addEventListener('change', updateGrid);
    document.getElementById('spacingG').addEventListener('change', updateGrid);
    
    // Add event listeners for path selection
    document.getElementById('pathAuto').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'none';
    });
    
    document.getElementById('pathManual').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'block';
    });
    
    // Add event listener for path visualization
    document.getElementById('visualizePath').addEventListener('click', visualizeCustomPath);
}
    function updateGrid() {
    // Save current pattern
    const pattern = getHolePattern();
    
    // Recreate the drawing area
    createInteractiveDrawingArea();
    
    // Restore pattern
    const nholeC = parseInt(document.getElementById('nholeC').value);
    const nholeR = parseInt(document.getElementById('nholeR').value);
    
    for (let row = 0; row < Math.min(nholeC, pattern.length); row++) {
        for (let col = 0; col < Math.min(nholeR, pattern[row].length); col++) {
            if (pattern[row][col] === 0) {
                const holeElement = document.querySelector(`.hole[data-row="${row+1}"][data-col="${col+1}"]`);
                if (holeElement) {
                    holeElement.style.opacity = '0.2';
                    holeElement.dataset.active = '0';
                    removedHoles.add(`${row+1}-${col+1}`);
                }
            }
        }
    }
}

function visualizeOptimalPath() {
    // First reset all path highlights
    document.querySelectorAll('.path-highlight').forEach(el => {
        el.remove();
    });
    
    const holePattern = getHolePattern();
    const path = findOptimalStagPath(holePattern);
    
    if (path.length < 2) {
        alert("Not enough active holes to create a path");
        return;
    }
    
    // Create visualization
    const flange = document.getElementById('dynamicFlange');
    
    // Create SVG container for path lines
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.classList.add('path-overlay', 'path-highlight');
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.style.pointerEvents = 'none';
    flange.appendChild(svg);
    
    // Draw lines and markers for the path
    for (let i = 0; i < path.length; i++) {
        const [row, col] = path[i];
        
        // Get the hole element
        const hole = document.querySelector(`.hole[data-row="${row+1}"][data-col="${col+1}"]`);
        if (!hole) continue;
        
        // Get coordinates
        const holeRect = hole.getBoundingClientRect();
        const flangeRect = flange.getBoundingClientRect();
        const x = holeRect.left + holeRect.width/2 - flangeRect.left;
        const y = holeRect.top + holeRect.height/2 - flangeRect.top;
        
        // Add number marker to hole
        const marker = document.createElement('div');
        marker.classList.add('path-marker', 'path-highlight');
        marker.style.position = 'absolute';
        marker.style.left = (x - 8) + 'px';
        marker.style.top = (y - 8) + 'px';
        marker.style.width = '16px';
        marker.style.height = '16px';
        marker.style.borderRadius = '50%';
        marker.style.backgroundColor = 'rgba(255,0,0,0.2)';
        marker.style.border = '2px solid red';
        marker.style.color = 'red';
        marker.style.display = 'flex';
        marker.style.alignItems = 'center';
        marker.style.justifyContent = 'center';
        marker.style.fontWeight = 'bold';
        marker.style.fontSize = '10px';
        marker.style.zIndex = '10';
        marker.textContent = i + 1;
        flange.appendChild(marker);
        
        // Draw line to next point
        if (i < path.length - 1) {
            const [nextRow, nextCol] = path[i+1];
            const nextHole = document.querySelector(`.hole[data-row="${nextRow+1}"][data-col="${nextCol+1}"]`);
            
            if (nextHole) {
                const nextRect = nextHole.getBoundingClientRect();
                const x2 = nextRect.left + nextRect.width/2 - flangeRect.left;
                const y2 = nextRect.top + nextRect.height/2 - flangeRect.top;
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', y);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', 'red');
                line.setAttribute('stroke-width', '2');
                svg.appendChild(line);
            }
        }
    }
    
    // Set the path to the custom path input
    const customPathInput = document.getElementById('customPathInput');
    if (customPathInput) {
        const pathStr = path.map(p => `${p[0]+1}-${p[1]+1}`).join(',');
        customPathInput.value = pathStr;
    }
}


function findOptimalStagPath(holePattern) {
    const rows = holePattern.length;
    const cols = holePattern[0].length;
    const path = [];
    
    // Start searching from the top row
    for (let row = 0; row < rows; row++) {
        // First try to find a hole in column 1 for this row
        if (holePattern[row][0] === 1) {
            path.push([row, 0]);
            continue; // Move to next row
        }
        
        // If no hole in column 1, find one in any other column
        let holeFound = false;
        for (let col = 1; col < cols; col++) {
            if (holePattern[row][col] === 1) {
                path.push([row, col]);
                holeFound = true;
                break; // Only take one hole per row
            }
        }
        
        // Skip rows with no holes
        if (!holeFound) {
            continue;
        }
    }
    
    return path;
}
    





  
function calculateZigzagNetArea(Ag, holePattern, holeDia, s, g) {
    const d_hole = holeDia + 1/8; // Add 1/8" for standard hole
    const nholeC = holePattern.length; // rows
    const nholeR = holePattern[0].length; // columns
    
    // Get section properties for hole area calculation
    const sectionKey = document.getElementById('shapeA').value + document.getElementById('dimA').value.toUpperCase().replace(/\s/g, '');
    const section = steelData[sectionKey] || { tw: 0.335 }; // Use default if not found
    const tw = section.tw; // Web thickness for hole area
    
    // Calculate standard net area using the critical column approach
    const standardResult = calculateStandardNetArea(
        Ag,
        holePattern,
        holeDia,
        tw
    );
    const standardNetArea = standardResult.netArea;
    
    // Check if manual path selection is active
    const useManualPath = document.getElementById('pathManual') && 
                         document.getElementById('pathManual').checked;
    
    if (useManualPath) {
        // Use custom path from input
        const pathInput = document.getElementById('customPathInput').value.trim();
        if (!pathInput) {
            alert("Please enter a valid path or switch to automatic calculation");
            return {
                standardNetArea: standardNetArea,
                netArea: standardNetArea,
                criticalPath: "No valid path specified",
                staggerReduction: 0
            };
        }
        
        try {
            // Parse the path string into array of [row, col] coordinates
            const customPath = pathInput.split(',').map(coord => {
                const [row, col] = coord.trim().split('-').map(Number);
                if (isNaN(row) || isNaN(col) || row < 1 || col < 1 || 
                    row > nholeC || col > nholeR || holePattern[row-1][col-1] !== 1) {
                    throw new Error(`Invalid or inactive hole at position (${row},${col})`);
                }
                return [row-1, col-1]; // Convert to 0-based indexing
            });
            
            if (customPath.length < 2) {
                throw new Error("Path must contain at least 2 points");
            }
            
            // Calculate net area for this custom path
            let holeLoss = customPath.length * d_hole * tw;
            let totalStaggerReduction = 0;
            
            // Calculate stagger reduction for each diagonal segment
            for (let i = 1; i < customPath.length; i++) {
                const [prevRow, prevCol] = customPath[i-1];
                const [currRow, currCol] = customPath[i];
                
                // If moving diagonally (both row and column change)
                if (prevRow !== currRow && prevCol !== currCol) {
                    const dx = Math.abs(currCol - prevCol) * s; // Horizontal spacing
                    const dy = Math.abs(currRow - prevRow) * g; // Vertical spacing
                    const staggerReduction = Math.pow(dx, 2) / (4 * dy);
                    totalStaggerReduction += staggerReduction;
                }
            }
            
            // Calculate net area for this path
            const netArea = Ag - holeLoss + (totalStaggerReduction * tw);
            
            // Path summary for display
            let pathSummary = `Custom Path: `;
            customPath.forEach((p, idx) => {
                pathSummary += `(${p[0]+1},${p[1]+1})`;
                if (idx < customPath.length - 1) pathSummary += " → ";
            });
            
            return {
                standardNetArea: standardNetArea,
                netArea: netArea,
                criticalPath: pathSummary,
                staggerReduction: totalStaggerReduction * tw
            };
            
        } catch (error) {
            alert("Error in custom path: " + error.message);
            return {
                standardNetArea: standardNetArea,
                netArea: standardNetArea,
                criticalPath: "Error in path: " + error.message,
                staggerReduction: 0
            };
        }
    } else {
        // Use new optimized path algorithm - one hole per row prioritizing column 1
        const path = findOptimalStagPath(holePattern);
        
        if (path.length < 2) {
            return {
                standardNetArea: standardNetArea,
                netArea: standardNetArea,
                criticalPath: "Insufficient holes for stagger calculation",
                staggerReduction: 0
            };
        }
        
        // Calculate net area
        let holeLoss = path.length * d_hole * tw;
        let totalStaggerReduction = 0;
        
        // Calculate stagger reduction for each diagonal segment
        for (let i = 1; i < path.length; i++) {
            const [prevRow, prevCol] = path[i-1];
            const [currRow, currCol] = path[i];
            
            // If moving diagonally (both row and column change)
            if (prevRow !== currRow && prevCol !== currCol) {
                const dx = Math.abs(currCol - prevCol) * s; // Horizontal spacing
                const dy = Math.abs(currRow - prevRow) * g; // Vertical spacing
                const staggerReduction = Math.pow(dx, 2) / (4 * dy);
                totalStaggerReduction += staggerReduction;
            }
        }
        
        // Calculate net area for this path
        const netArea = Ag - holeLoss + (totalStaggerReduction * tw);
        
        // Path summary for display
        let pathSummary = `One-per-row Path: `;
        path.forEach((p, idx) => {
            pathSummary += `(${p[0]+1},${p[1]+1})`;
            if (idx < path.length - 1) pathSummary += " → ";
        });
        
        return {
            standardNetArea: standardNetArea,
            netArea: netArea,
            criticalPath: pathSummary,
            staggerReduction: totalStaggerReduction * tw
        };
    }
}


function updateColumnControls() {
    const columnInputs = document.getElementById('column-inputs');
    columnInputs.innerHTML = `
        <h3>Interactive Hole Pattern</h3>
        <div class="control-section">
            <div class="control-group">
                <label for="spacingS">Horizontal spacing (s):</label>
                <input type="number" id="spacingS" value="2" step="0.1" class="stagger-input"> in
                
                <label for="spacingG">Vertical spacing (g):</label>
                <input type="number" id="spacingG" value="1.5" step="0.1" class="gauge-input"> in
                
                <button onclick="updateGrid()">Update Grid</button>
            </div>
            
            <div class="control-group" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ccc;">
                <h4>Path Calculation Options</h4>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathAuto" name="pathMethod" value="auto" checked>
                    <label for="pathAuto">One hole per row (prioritize column 1)</label>
                </div>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathLegacy" name="pathMethod" value="legacy">
                    <label for="pathLegacy">Find critical zigzag path (legacy)</label>
                </div>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathManual" name="pathMethod" value="manual">
                    <label for="pathManual">Specify custom path</label>
                </div>
                
                <div style="margin-top: 10px;">
                    <button onclick="visualizeOptimalPath()">Preview Current Path</button>
                </div>
                
                <div id="customPathContainer" style="margin-top: 10px; display: none;">
                    <label for="customPathInput">Custom Path (format: 1-1,1-2,2-3,...):</label><br>
                    <input type="text" id="customPathInput" placeholder="row-col,row-col,..." style="width: 90%; margin-top: 5px;">
                    <div style="margin-top: 5px; font-size: 0.85em; color: #666;">
                        Example: 1-1,1-2,2-3 means path from hole (1,1) → (1,2) → (2,3)
                    </div>
                    <button id="visualizePath" style="margin-top: 8px;">Visualize Path</button>
                </div>
            </div>
        </div>
        
        <div id="dynamicFlange" style="position:relative; width:400px; height:300px; border:2px solid black; background:#f0f0f0; margin-top:20px;"></div>
    `;
    
    // Add event listeners
    document.getElementById('spacingS').addEventListener('change', updateGrid);
    document.getElementById('spacingG').addEventListener('change', updateGrid);
    
    // Add event listeners for path selection
    document.getElementById('pathAuto').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'none';
    });
    
    document.getElementById('pathLegacy').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'none';
    });
    
    document.getElementById('pathManual').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'block';
    });
    
    // Add event listener for path visualization
    document.getElementById('visualizePath').addEventListener('click', visualizeCustomPath);
    
    // Initialize the drawing area
    createInteractiveDrawingArea();
}


function findAllPathsRowBased(holePattern, startRow, startCol, maxCols, maxRows) {
    // Base case: if we've reached the last row
    if (startRow === maxRows - 1) {
        // Return current position as a single-element path if there's a hole here
        return holePattern[startRow][startCol] === 1 ? [[[startRow, startCol]]] : [];
    }
    
    let paths = [];
    
    // If there's a hole at the current position
    if (holePattern[startRow][startCol] === 1) {
        // Try moving to each hole in the next row
        for (let nextCol = 0; nextCol < maxCols; nextCol++) {
            const subPaths = findAllPathsRowBased(holePattern, startRow + 1, nextCol, maxCols, maxRows);
            
            // Attach current position to each subpath
            subPaths.forEach(subPath => {
                paths.push([[startRow, startCol], ...subPath]);
            });
        }
        
        // If no valid subpaths were found, return current position as endpoint
        if (paths.length === 0) {
            paths.push([[startRow, startCol]]);
        }
    }
    
    return paths;
}




// First, let's modify the calculateStandardNetArea function to find critical rows instead of columns
function calculateStandardNetArea(Ag, holeDia, totalHoles, tw) {
    const d_hole = holeDia + 1/8; // Add 1/8" for standard hole
    
    // Calculate net area by subtracting hole area from gross area
    const holeLoss = totalHoles * d_hole * tw;
    const netArea = Ag - holeLoss;
    
    return {
        netArea: netArea,
        holesCount: totalHoles
    };
}

   function performCalculations() {
    if (!dataLoaded) {
        alert("Steel section data is still loading. Please wait a moment and try again.");
        return;
    }
    const inputValues = getInputValues();
    
    // Validate inputs
    if (isNaN(inputValues.dhole) || inputValues.dhole <= 0) {
        alert("Please enter a valid hole diameter");
        return;
    }
    
    if (isNaN(inputValues.length) || inputValues.length <= 0) {
        alert("Please enter a valid length");
        return;
    }
    
    // Get material properties
    const material = astmData[inputValues.ASTM] || { Fy: 36, Fu: 58 };
    
    // Get section properties from steel data
    const sectionKey = inputValues.shape + inputValues.dim;
    const section = steelData[sectionKey] || { A: 0, d: 0, bf: 0, tw: 0 };
    
    if (!section.A) {
        // Default value if section not found
        section.A = 13.2;
        section.d = 12.1;
        section.bf = 8.05;
        section.tw = 0.335;
        console.warn("Section not found, using default values");
    }
    
    // Gross area
    const Ag = section.A;
    document.getElementById('AG').textContent = Ag.toFixed(3) + " in²";
    
    // Variables for net area and effective net area
    let An, Ae, criticalPathText = "", staggerReductionValue = 0;
    let standardNetArea = 0;
    
    // Calculate xbar for U (simplified - center of gravity to connection)
    const xbar = section.bf / 2;
        
    // Calculate U - shear lag factor
    const U = calculateU(
        inputValues.caseId,
        xbar, 
        inputValues.length,
        section.bf,
        section.d
    );
    
    if (inputValues.designOption === 'stagger') {
        const holePattern = getHolePattern();
        
        // Check which path method is selected
        let useManualPath = false;
        let useLegacyPath = false;
        
        if (document.getElementById('pathManual') && document.getElementById('pathManual').checked) {
            useManualPath = true;
        } else if (document.getElementById('pathLegacy') && document.getElementById('pathLegacy').checked) {
            useLegacyPath = true;
        }
        
        let result;
        
        if (useLegacyPath) {
            // Use the original zigzag function
            result = calculateLegacyZigzagNetArea(
                Ag, 
                holePattern, 
                inputValues.dhole, 
                inputValues.spacingS, 
                inputValues.spacingG
            );
        } else {
            // Use our new improved calculation
            result = calculateZigzagNetArea(
                Ag, 
                holePattern, 
                inputValues.dhole, 
                inputValues.spacingS, 
                inputValues.spacingG
            );
        }
        
        // Visualize the path after calculation
        if (!useManualPath) {
            visualizeOptimalPath();
        }
        
        standardNetArea = result.standardNetArea;
        An = result.netArea;  // This is the net area without the shear lag factor
        Ae = An * U;         // Apply shear lag factor to get effective net area
        criticalPathText = result.criticalPath;
        staggerReductionValue = result.staggerReduction;
        
        document.getElementById('criticalPath').textContent = criticalPathText;
        document.getElementById('staggerReduction').textContent = staggerReductionValue.toFixed(3) + " in²";
        
        // Update results to show both values - NET AREA first
        document.getElementById('AE').textContent = 
            `${An.toFixed(3)} in² (With stagger effect)`;
            
    } else if (inputValues.designOption === 'block') {
        // Block shear calculation
        const Agv = parseFloat(document.getElementById('Agv').value) || 0;
        const Anv = parseFloat(document.getElementById('Anv').value) || 0;
        const Ant = parseFloat(document.getElementById('Ant').value) || 0;
        
        if (Agv <= 0 || Anv <= 0 || Ant <= 0) {
            alert("Please enter valid values for block shear areas");
            return;
        }
        
        // AISC Equation J4-5
        const blockShear1 = 0.60 * material.Fu * Anv + material.Fy * Agv;
        // AISC Equation J4-5 (alternative)
        const blockShear2 = 0.60 * material.Fy * Agv + material.Fu * Ant;
        
        // For block shear, An is the minimum of the two calculations
        An = Math.min(blockShear1, blockShear2);
        Ae = An;  // For block shear, we don't apply the U factor
        
        document.getElementById('AE').textContent = An.toFixed(3) + " in² (Block shear)";
        
    } 
    
    else {
    // Simple calculation with holes - just count total holes in a column
    const tw = section.tw;
    const nholeC = parseInt(document.getElementById('nholeC').value);
    
    // Use function to calculate standard net area
    const standardAreaResult = calculateStandardNetArea(
        Ag,
        inputValues.dhole,
        nholeC, // Just pass the number of holes in a column
        tw
    );
    
    An = standardAreaResult.netArea;  // This is the net area (An)
    Ae = An * U;  // The effective net area (Ae) applies the shear lag factor
    
    // Show detailed information about NET AREA
    document.getElementById('AE').textContent = 
        `${An.toFixed(3)} in² (${standardAreaResult.holesCount} holes in column)`;
}
    
    // Calculate yielding strength (uses gross area)
    const Py = material.Fy * Ag;
    
    // Calculate fracture strength (uses effective net area)
    const Pf = material.Fu * Ae;  // Use Ae (effective net area)
    
    // Determine which limit state controls
    const isYieldingControls = Py <= Pf;
    
    // Display yielding strength with highlight if it controls
    document.getElementById('YC').innerHTML = isYieldingControls 
        ? `<span style="color:green; font-weight:bold">${Py.toFixed(1)} kips (CONTROLS)</span>` 
        : `${Py.toFixed(1)} kips`;
    
    // Display fracture strength with highlight if it controls
    document.getElementById('FS').innerHTML = !isYieldingControls 
        ? `<span style="color:green; font-weight:bold">${Pf.toFixed(1)} kips (CONTROLS)</span>` 
        : `${Pf.toFixed(1)} kips`;
    
    // Nominal strength is minimum of yield and fracture
    const Pn = Math.min(Py, Pf);
    
    // LRFD design strength
    const phiPn = 0.9 * Py; // φ = 0.9 for tension yielding
    const phiPnFracture = 0.75 * Pf; // φ = 0.75 for fracture
    const phiPnFinal = Math.min(phiPn, phiPnFracture);
    
    // Add text to indicate which governs LRFD
    const lrfdGoverns = phiPn <= phiPnFracture ? "yielding" : "fracture";
    document.getElementById('LRFD').textContent = `${phiPnFinal.toFixed(1)} kips (${lrfdGoverns})`;
    
    // ASD allowable strength
    // Use appropriate safety factor based on which failure mode controls
    const safetyFactor = isYieldingControls ? 1.67 : 2.0;
    const PnASD = Pn / safetyFactor;
    document.getElementById('ASD').textContent = `${PnASD.toFixed(1)} kips (${isYieldingControls ? "yielding" : "fracture"})`;
}

        // Event listeners
        document.querySelector('.Calculate').addEventListener('click', performCalculations);

document.querySelectorAll('input[name="designOption"]').forEach(el => {
    el.addEventListener('change', function() {
        toggleShearDiv();
        if (this.value === 'stagger') {
            updateColumnControls();
            createInteractiveDrawingArea();
        }
    });
});

document.addEventListener('DOMContentLoaded', function() {
    loadExcelData();
    toggleShearDiv();
});

// JavaScript for Axial Tension Member Design Calculator with Excel Data Import

// Function to load the SheetJS library
function loadScript(url) {
    return new Promise((resolve, reject) => {
        if (document.querySelector(`script[src="${url}"]`)) {
            resolve(); // Script already loaded
            return;
        }
        const script = document.createElement('script');
        script.src = url;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

// Enhanced steel data management
async function loadLShapeData() {
    try {
        console.log("Loading L shape data...");
        
        // Show loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.id = 'loading-indicator';
        loadingIndicator.innerHTML = 'Loading L shape data...';
        loadingIndicator.style.position = 'fixed';
        loadingIndicator.style.top = '10px';
        loadingIndicator.style.right = '10px';
        loadingIndicator.style.padding = '5px 10px';
        loadingIndicator.style.backgroundColor = '#e0f0ff';
        loadingIndicator.style.border = '1px solid #ccddff';
        loadingIndicator.style.borderRadius = '3px';
        loadingIndicator.style.zIndex = '1000';
        document.body.appendChild(loadingIndicator);
        
        // Initialize steelData object if it doesn't exist
        if (!window.steelData) {
            window.steelData = {};
        }
        
        // Load the Excel file
        try {
            const response = await fetch('./ASTMSPEC.xlsx');
            if (!response.ok) {
                throw new Error(`Failed to fetch Excel file: ${response.status} ${response.statusText}`);
            }
            
            const data = await response.arrayBuffer();
            const workbook = XLSX.read(data, { type: 'array' });
            
            // Find the sheet with L shapes
            // Try to find a sheet with "angle" or "L" in the name, otherwise default to second sheet
            let sheetIndex = 1; // Default to second sheet
            for (let i = 0; i < workbook.SheetNames.length; i++) {
                const name = workbook.SheetNames[i].toLowerCase();
                if (name.includes('angle') || name.includes('l shapes') || name === 'l') {
                    sheetIndex = i;
                    break;
                }
            }
            
            const sheetName = workbook.SheetNames[sheetIndex];
            console.log(`Using sheet: ${sheetName}`);
            
            const shapeSheet = workbook.Sheets[sheetName];
            const shapeRows = XLSX.utils.sheet_to_json(shapeSheet);
            
            console.log("Excel data loaded, processing", shapeRows.length, "rows");
            
            let lShapeCount = 0;
            
            // Process only L shapes
            shapeRows.forEach(row => {
                // Check if AISC_Manual_Label exists and starts with L
                if (row["AISC_Manual_Label"] && 
                    typeof row["AISC_Manual_Label"] === 'string' && 
                    row["AISC_Manual_Label"].trim().toUpperCase().startsWith('L')) {
                    
                    const label = row["AISC_Manual_Label"].trim().toUpperCase().replace(/\s/g, '');
                    
                    // Extract thickness from the label (e.g., L3X1/2 means 1/2 inch thickness)
                    let thickness = extractThicknessFromLabel(label);
                    
                    // Safely parse values with fallbacks to avoid NaN
                    const safeParseFloat = (value) => {
                        if (value === undefined || value === null) return 0;
                        const parsed = parseFloat(value);
                        return isNaN(parsed) ? 0 : parsed;
                    };
                    
                    window.steelData[label] = {
                        type: 'L',
                        shape: label,
                        A: safeParseFloat(row.A),       // Cross-sectional area
                        t: thickness,                   // Thickness extracted from shape name
                        b: safeParseFloat(row.b),       // Longer leg
                        d: safeParseFloat(row.d),       // Shorter leg
                        weight: safeParseFloat(row.W),  // Weight per foot
                        rx: safeParseFloat(row.rx),     // Radius of gyration x-axis
                        ry: safeParseFloat(row.ry),     // Radius of gyration y-axis
                        rz: safeParseFloat(row.rz),     // Radius of gyration z-axis
                        x: safeParseFloat(row.x),       // Centroid x coordinate
                        y: safeParseFloat(row.y)        // Centroid y coordinate
                    };
                    
                    lShapeCount++;
                }
            });
            
            console.log(`Successfully loaded ${lShapeCount} L shapes`);
            return lShapeCount;
            
        } catch (error) {
            console.error("Error loading Excel file:", error);
            throw error;
        }
        
    } catch (error) {
        console.error("Error in loadLShapeData:", error);
        alert("Failed to load L shape data: " + error.message);
    } finally {
        // Remove loading indicator
        const loadingIndicator = document.getElementById('loading-indicator');
        if (loadingIndicator) {
            loadingIndicator.remove();
        }
    }
}

// Function to extract thickness from L shape label (e.g., L3X1/2 → 0.5)
function extractThicknessFromLabel(label) {
    try {
        // Handle various formats like L3X1/2, L3X3X1/2, L3X3X3/8, etc.
        const parts = label.split('X');
        
        // Get the last part which should contain the thickness
        const thicknessPart = parts[parts.length - 1];
        
        // Handle fraction format (e.g., 1/2, 3/8)
        if (thicknessPart.includes('/')) {
            const fractionParts = thicknessPart.split('/');
            if (fractionParts.length === 2) {
                const numerator = parseFloat(fractionParts[0]);
                const denominator = parseFloat(fractionParts[1]);
                return numerator / denominator;
            }
        }
        
        // Handle decimal format
        return parseFloat(thicknessPart);
    } catch (error) {
        console.error("Error extracting thickness from label:", label, error);
        return 0.5; // Default fallback
    }
}

// Get steel properties based on ASTM specification
function getSteelProperties(astmSpec) {
    const steelProperties = {
        "A36": { Fy: 36, Fu: 58 },
        "A572Gr.42": { Fy: 42, Fu: 60 },
        "A572Gr.50": { Fy: 50, Fu: 65 },
        "A572Gr.55": { Fy: 55, Fu: 70 },
        "A572Gr.60": { Fy: 60, Fu: 75 },
        "A572Gr.65": { Fy: 65, Fu: 80 },
        "A588Gr.42": { Fy: 42, Fu: 63 },
        "A588Gr.46": { Fy: 46, Fu: 67 },
        "A588Gr.50": { Fy: 50, Fu: 70 },
        "A687": { Fy: 50, Fu: 70 },
        "A992": { Fy: 50, Fu: 65 }
    };
    
    return steelProperties[astmSpec] || { Fy: 36, Fu: 58 }; // Default to A36 if not found
}

// Enhanced shear lag factor U calculation
function calculateShearLagFactor(caseId, shape) {
    // Get centroid value (x-bar) for the shape
    let xbar = 0;
    
    if (shape && shape.x) {
        xbar = shape.x; // Use actual centroid from shape data
    } else {
        // Default approximate calculation if shape data not available
        if (shape && shape.b && shape.d) {
            // For unequal leg angles
            if (shape.b !== shape.d) {
                xbar = (shape.b * shape.b) / (shape.b + shape.d);
            } else {
                // For equal leg angles
                xbar = shape.b / 3;
            }
        } else {
            // Fallback default
            xbar = 0.8;
        }
    }
    
    const caseIdInt = parseInt(caseId);
    const length = parseFloat(document.getElementById('LenghtD').value) || 24; // Connection length
    let U = 1.0; // Default value
    
    switch (caseIdInt) {
        case 1: // All elements connected
            U = 1.0;
            break;
        case 2: // Some elements connected
            U = 1 - (xbar / length);
            if (U < 0.4) U = 0.4; // AISC lower bound
            if (U > 0.9) U = 0.9; // AISC upper bound
            break;
        case 7: // Angles connected by one leg
            const bf = shape && shape.b ? shape.b : 4.0;
            const d = shape && shape.d ? shape.d : 4.0;
            const case2Value = 1 - (xbar / length);
            // Apply special case for angles
            U = Math.max(bf / d >= 2 / 3 ? 0.9 : 0.8, case2Value);
            if (U > 0.9) U = 0.9; // AISC upper bound
            break;
        case 8: // Single angles
            U = 0.8;
            break;
        default:
            U = 1.0;
    }
    
    return parseFloat(U.toFixed(3));
}

// Calculate design loads based on method
function calculateDesignLoads(deadLoad, liveLoad, designMethod) {
    const loads = {
        LRFD: {
            load: 1.2 * deadLoad + 1.6 * liveLoad,
            formula: `1.2D + 1.6L = 1.2 × ${deadLoad} + 1.6 × ${liveLoad} = ${(1.2 * deadLoad + 1.6 * liveLoad).toFixed(2)} kips`
        },
        ASD: {
            load: deadLoad + liveLoad,
            formula: `D + L = ${deadLoad} + ${liveLoad} = ${(deadLoad + liveLoad).toFixed(2)} kips`
        }
    };
    
    return loads[designMethod];
}

// Calculate required areas for tension member design
function calculateRequiredAreas(designLoad, steelProperties, U, designMethod, numHoles, dHole, memberThickness) {
    const areas = {};
    
    // Hole area calculation (if hole parameters are provided)
    const holeArea = numHoles && dHole && memberThickness ? numHoles * dHole * memberThickness : 0;
    
    if (designMethod === 'LRFD') {
        // LRFD calculations
        // Yielding (φ = 0.9)
        areas.yielding = designLoad / (0.9 * steelProperties.Fy);
        
        // Fracture (φ = 0.75)
        // Calculate required net area directly
        const requiredAn = designLoad / (0.75 * steelProperties.Fu * U);
        
        // For fracture, we need Ag where: An = Ag - hole_area
        // Therefore: Ag = An + hole_area
        areas.fracture = requiredAn + holeArea;
        
        // Controlling case
        areas.controlling = Math.max(areas.yielding, areas.fracture);
        areas.governingCase = areas.yielding >= areas.fracture ? 'yielding' : 'fracture';
        
        // Store the net area requirement for reference
        areas.requiredNetArea = requiredAn;
        areas.holeArea = holeArea;
    } else {
        // ASD calculations
        // Yielding (Ω = 1.67)
        areas.yielding = designLoad * 1.67 / steelProperties.Fy;
        
        // Fracture (Ω = 2.0)
        // Calculate required net area directly
        const requiredAn = designLoad * 2.0 / (steelProperties.Fu * U);
        
        // For fracture, we need Ag where: An = Ag - hole_area
        // Therefore: Ag = An + hole_area
        areas.fracture = requiredAn + holeArea;
        
        // Controlling case
        areas.controlling = Math.max(areas.yielding, areas.fracture);
        areas.governingCase = areas.yielding >= areas.fracture ? 'yielding' : 'fracture';
        
        // Store the net area requirement for reference
        areas.requiredNetArea = requiredAn;
        areas.holeArea = holeArea;
    }
    
    return areas;
}

// Enhanced L shape selector with additional evaluation criteria
function selectBestLShapes(requiredArea, designLoad, designMethod, astmSpec, shearLagCase, connectionLength, dHole, numHoles) {
    return new Promise(async (resolve, reject) => {
        try {
            // Make sure L shape data is loaded
            if (!window.steelData || Object.keys(window.steelData).filter(k => k.startsWith('L')).length === 0) {
                await loadLShapeData();
            }
            
            // Get all L shapes from the loaded data
            const lShapes = Object.values(window.steelData).filter(section => section.type === 'L');
            
            if (!lShapes || lShapes.length === 0) {
                throw new Error("No L shapes data available");
            }
            
            console.log(`Found ${lShapes.length} L shapes to evaluate`);
            
            // Get steel properties
            const steelProps = getSteelProperties(astmSpec);
            
            // Advanced shape selection criteria
            const shapes = lShapes.map(shape => {
                // Calculate hole area for this shape
                const holeArea = numHoles * dHole * shape.t;
                
                // Calculate net area
                const netArea = shape.A - holeArea;
                
                // Calculate specific shear lag factor for this shape
                const U = calculateShearLagFactor(shearLagCase, shape);
                
                // Calculate effective area
                const effectiveArea = U * netArea;
                
                // Calculate LRFD capacity
                const LRFDYieldCapacity = 0.9 * steelProps.Fy * shape.A;
                const LRFDFractureCapacity = 0.75 * steelProps.Fu * effectiveArea;
                const LRFDCapacity = Math.min(LRFDYieldCapacity, LRFDFractureCapacity);
                
                // Calculate ASD capacity
                const ASDYieldCapacity = steelProps.Fy * shape.A / 1.67;
                const ASDFractureCapacity = steelProps.Fu * effectiveArea / 2.0;
                const ASDCapacity = Math.min(ASDYieldCapacity, ASDFractureCapacity);
                
                // Select the appropriate capacity based on design method
                const capacity = designMethod === 'LRFD' ? LRFDCapacity : ASDCapacity;
                
                // Calculate demand/capacity ratio
                const DCRatio = designLoad / capacity;
                
                // Calculate fracture area requirement (this is An)
                let requiredNetArea;
                if (designMethod === 'LRFD') {
                    requiredNetArea = designLoad / (0.75 * steelProps.Fu * U);
                } else { // ASD
                    requiredNetArea = designLoad * 2.0 / (steelProps.Fu * U);
                }
                
                // Calculate gross area requirement for fracture
                // Ag = An + holeArea
                const requiredGrossArea = requiredNetArea + holeArea;
                
                // Calculate weight efficiency (capacity per pound)
                const weightEfficiency = capacity / shape.weight;
                
                // Calculate cost index (approximation based on weight)
                const costIndex = shape.weight * 1.5; // simplified cost model
                
                // Calculate an overall score (lower is better)
                // Factors: 1) How close is area to required (avoid over-design)
                //          2) Weight efficiency
                //          3) Must satisfy DCRatio < 1.0
                let score = 0;
                
                if (DCRatio < 1.0) {
                    // Only consider shapes that have sufficient capacity
                    // Score based on how close the area is to required (avoid excess material)
                    const areaRatio = shape.A / requiredArea;
                    score = areaRatio * 0.7 + (1/weightEfficiency) * 0.3;
                } else {
                    // Penalize shapes that don't meet capacity requirements
                    score = 999;
                }
                
                return {
                    shape: shape.shape,
                    area: shape.A,
                    thickness: shape.t,
                    legs: `${shape.b} × ${shape.d}`,
                    weight: shape.weight,
                    holeArea: holeArea,
                    netArea: netArea,
                    effectiveArea: effectiveArea,
                    shearLagFactor: U,
                    capacity: capacity,
                    requiredNetArea: requiredNetArea,
                    requiredGrossArea: requiredGrossArea,
                    demandCapacityRatio: DCRatio, // Keep this for internal use
                    weightEfficiency: weightEfficiency,
                    costIndex: costIndex,
                    score: score,
                    status: DCRatio < 1.0 ? "PASS" : "FAIL"
                };
            });
            
            // Log for debugging
            console.log(`Evaluated ${shapes.length} shapes, filtering for valid ones...`);
            
            // Sort by score (best options first)
            const validShapes = shapes
                .filter(shape => shape.status === "PASS")
                .sort((a, b) => a.score - b.score);
            
            console.log(`Found ${validShapes.length} valid shapes that meet requirements`);
            
            resolve(validShapes.slice(0, 4)); // Return top 4 options to match the table in the HTML
        } catch (error) {
            console.error("Error selecting L shapes:", error);
            reject(error);
        }
    });
}

// Main design function for tension members
async function designTensionMember() {
    try {
        // Show calculating indicator
        const calculatingIndicator = document.createElement('div');
        calculatingIndicator.id = 'calculating-indicator';
        calculatingIndicator.innerHTML = 'Calculating tension member design...';
        calculatingIndicator.style.position = 'fixed';
        calculatingIndicator.style.top = '50%';
        calculatingIndicator.style.left = '50%';
        calculatingIndicator.style.transform = 'translate(-50%, -50%)';
        calculatingIndicator.style.padding = '10px 20px';
        calculatingIndicator.style.backgroundColor = '#f0f8ff';
        calculatingIndicator.style.border = '1px solid #b0d8ff';
        calculatingIndicator.style.borderRadius = '5px';
        calculatingIndicator.style.zIndex = '1000';
        document.body.appendChild(calculatingIndicator);
        
        // Get input values
        const designMethod = document.getElementById('designMethod').value;
        const astmSpec = document.getElementById('ASpecD').value;
        const shearLagCase = document.getElementById('ulagCase').value;
        const deadLoad = parseFloat(document.getElementById('Dload').value) || 0;
        const liveLoad = parseFloat(document.getElementById('Lload').value) || 0;
        const length = parseFloat(document.getElementById('LenghtD').value) || 0;
        const dHole = parseFloat(document.getElementById('dholeD').value) || 0;
        const numHoles = parseInt(document.querySelector('.nholeD').value) || 0;
        
        console.log("Design inputs:", { designMethod, astmSpec, shearLagCase, deadLoad, liveLoad, length, dHole, numHoles });
        
        // Calculate design loads
        const designLoads = calculateDesignLoads(deadLoad, liveLoad, designMethod);
        const designLoad = designLoads.load;
        
        console.log("Design load:", designLoad);
        
        // Display load combinations
        document.getElementById('LRFDdesignComb').textContent = calculateDesignLoads(deadLoad, liveLoad, 'LRFD').formula;
        document.getElementById('ASDdesignComb').textContent = calculateDesignLoads(deadLoad, liveLoad, 'ASD').formula;
        
        // Get steel properties
        const steelProperties = getSteelProperties(astmSpec);
        
        console.log("Steel properties:", steelProperties);
        
        // Ensure L shape data is loaded
        if (!window.steelData || Object.keys(window.steelData).filter(k => k.startsWith('L')).length === 0) {
            console.log("L shape data not loaded yet, loading now...");
            await loadLShapeData();
        }
        
        // Use a real shape from the loaded data for U factor calculation if possible
        let defaultShape;
        const sampleLShapes = Object.values(window.steelData).filter(section => section.type === 'L');
        
        if (sampleLShapes && sampleLShapes.length > 0) {
            // Use the first available L shape
            defaultShape = sampleLShapes[0];
            console.log("Using actual L shape data for U factor:", defaultShape);
        } else {
            // Fallback to default shape
            defaultShape = {
                b: 4.0, // default longer leg
                d: 4.0, // default shorter leg
                x: 1.1  // approximate centroid
            };
            console.log("Using fallback shape data for U factor");
        }
        
        // Calculate shear lag factor
        const U = calculateShearLagFactor(shearLagCase, defaultShape);
        console.log("Calculated shear lag factor U:", U);
        
        // Calculate required areas
        const areas = calculateRequiredAreas(designLoad, steelProperties, U, designMethod);
        console.log("Required areas:", areas);
        
        // Display calculated areas
        if (designMethod === 'LRFD') {
            document.getElementById('LRFDYielding').textContent = areas.yielding.toFixed(2) + " in²";
            document.getElementById('LRFDFracture').textContent = areas.fracture.toFixed(2) + " in²";
            
            // Hide ASD results
            document.getElementById('ASDFracture').textContent = "";
            document.getElementById('ASDYielding').textContent = "";
        } else {
            document.getElementById('ASDYielding').textContent = areas.yielding.toFixed(2) + " in²";
            document.getElementById('ASDFracture').textContent = areas.fracture.toFixed(2) + " in²";
            
            // Hide LRFD results
            document.getElementById('LRFDYielding').textContent = "";
            document.getElementById('LRFDFracture').textContent = "";
        }
        
        // Update the controlling required area display
        document.querySelector('.controlR').textContent = areas.controlling.toFixed(2) + " in²";
        
        // Highlight the governing case
        if (designMethod === 'LRFD') {
            if (areas.governingCase === 'yielding') {
                document.getElementById('LRFDYielding').parentElement.style.color = 'red';
                document.getElementById('LRFDFracture').parentElement.style.color = '';
            } else {
                document.getElementById('LRFDYielding').parentElement.style.color = '';
                document.getElementById('LRFDFracture').parentElement.style.color = 'red';
            }
        } else {
            if (areas.governingCase === 'yielding') {
                document.getElementById('ASDYielding').parentElement.style.color = 'red';
                document.getElementById('ASDFracture').parentElement.style.color = '';
            } else {
                document.getElementById('ASDYielding').parentElement.style.color = '';
                document.getElementById('ASDFracture').parentElement.style.color = 'red';
            }
        }
        
        // Select best L shapes
        console.log("Selecting best L shapes...");
        const bestShapes = await selectBestLShapes(
            areas.controlling,
            designLoad,
            designMethod,
            astmSpec,
            shearLagCase,
            length,
            dHole,
            numHoles
        );
        
        console.log("Best shapes selected:", bestShapes);
        
        // Display results in the table
        displayShapeResults(bestShapes, areas.controlling);
        
        // Remove calculating indicator
        document.getElementById('calculating-indicator').remove();
        
        // Show success message
        showMessage("Design complete! Showing top recommendations.", "success");
        
    } catch (error) {
        console.error("Error in tension member design:", error);
        
        // Remove calculating indicator if it exists
        if (document.getElementById('calculating-indicator')) {
            document.getElementById('calculating-indicator').remove();
        }
        
        // Show error message
        showMessage("Error in tension member design: " + error.message, "error");
    }
}

// Display shape results in the table
function displayShapeResults(shapes, requiredArea) {
    // Update each row in the table with results
    shapes.forEach((shape, index) => {
        const rankId = `rank${index + 1}`;
        const shapeId = `Shape${index + 1}`;
        const areaGId = `AreaG${index + 1}`;
        const demandId = `D${index + 1}`;  // This will now show An+Ahole
        const weightId = `Weight${index + 1}`;
        const aholeId = `Ahole${index + 1}`;
        const statusId = `Status${index + 1}`;
        
        // Set values
        document.getElementById(rankId).textContent = index + 1;
        document.getElementById(shapeId).textContent = shape.shape;
        document.getElementById(areaGId).textContent = shape.area.toFixed(2);
        
        // Changed from DCRatio to An+Ahole - FIX HERE: Use anPlusAhole instead
        document.getElementById(demandId).textContent = shape.anPlusAhole.toFixed(2);
        
        document.getElementById(weightId).textContent = shape.weight.toFixed(1);
        document.getElementById(aholeId).textContent = shape.holeArea.toFixed(2);
        document.getElementById(statusId).textContent = shape.status;
        
        // Style based on status
        document.getElementById(statusId).style.color = shape.status === 'PASS' ? 'green' : 'red';
        document.getElementById(statusId).style.fontWeight = 'bold';
    });
    
    // Clear any unused rows
    for (let i = shapes.length + 1; i <= 4; i++) {
        document.getElementById(`rank${i}`).textContent = '';
        document.getElementById(`Shape${i}`).textContent = '';
        document.getElementById(`AreaG${i}`).textContent = '';
        document.getElementById(`D${i}`).textContent = '';
        document.getElementById(`Weight${i}`).textContent = '';
        document.getElementById(`Ahole${i}`).textContent = '';
        document.getElementById(`Status${i}`).textContent = '';
    }
    
    // If no shapes were found
    if (shapes.length === 0) {
        document.getElementById('rank1').textContent = '';
        document.getElementById('Shape1').textContent = 'No suitable shapes found';
        document.getElementById('Shape1').colSpan = 7;
        document.getElementById('Shape1').style.textAlign = 'center';
        document.getElementById('Shape1').style.color = 'red';
        document.getElementById('AreaG1').textContent = '';
        document.getElementById('D1').textContent = '';
        document.getElementById('Weight1').textContent = '';
        document.getElementById('Ahole1').textContent = '';
        document.getElementById('Status1').textContent = '';
    }
    
    // Update the column header to reflect the new calculation
    const dcHeader = document.querySelector('th[data-field="D"]');
    if (dcHeader) {
        dcHeader.textContent = "An+Ahole (in²)";
    }
}
// Helper function to show messages
function showMessage(message, type = "info") {
    // Create message element
    const messageElement = document.createElement('div');
    messageElement.className = 'message ' + type;
    messageElement.innerHTML = message;
    messageElement.style.position = 'fixed';
    messageElement.style.bottom = '20px';
    messageElement.style.right = '20px';
    messageElement.style.padding = '10px 20px';
    messageElement.style.borderRadius = '5px';
    messageElement.style.zIndex = '1000';
    
    // Style based on type
    switch (type) {
        case "success":
            messageElement.style.backgroundColor = '#d4edda';
            messageElement.style.border = '1px solid #c3e6cb';
            messageElement.style.color = '#155724';
            break;
        case "error":
            messageElement.style.backgroundColor = '#f8d7da';
            messageElement.style.border = '1px solid #f5c6cb';
            messageElement.style.color = '#721c24';
            break;
        default:
            messageElement.style.backgroundColor = '#cce5ff';
            messageElement.style.border = '1px solid #b8daff';
            messageElement.style.color = '#004085';
    }
    
    // Add to document
    document.body.appendChild(messageElement);
    
    // Auto remove after 5 seconds
    setTimeout(() => {
        if (messageElement.parentNode) {
            messageElement.parentNode.removeChild(messageElement);
        }
    }, 5000);
}




// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM loaded, initializing tension member design app");
    
    // Preload L shape data
    loadLShapeData();
    
    // Add event listener for the design button
    const designButton = document.getElementById('design');
    if (designButton) {
        designButton.addEventListener('click', function(e) {
            e.preventDefault();
            designTensionMember();
        });
        console.log("Design button listener added");
    } else {
        console.error("Design button not found");
    }
    
    // Add input validation for numeric fields
    const numericInputs = document.querySelectorAll('input[type="number"]');
    numericInputs.forEach(input => {
        input.addEventListener('input', function() {
            const value = parseFloat(this.value);
            if (isNaN(value) || value < 0) {
                this.style.borderColor = 'red';
            } else {
                this.style.borderColor = '';
            }
        });
    });

    // Add shear lag info
    addShearLagInfo();
    
    // Adjust the visibility of design calculation sections based on the selected design method
    const designMethodSelect = document.getElementById('designMethod');
    if (designMethodSelect) {
        designMethodSelect.addEventListener('change', function() {
            if (this.value === 'LRFD') {
                document.querySelectorAll('[id^="LRFD"]').forEach(el => {
                    el.parentElement.style.display = 'block';
                });
                document.querySelectorAll('[id^="ASD"]').forEach(el => {
                    el.parentElement.style.display = 'none';
                });
            } else {
                document.querySelectorAll('[id^="LRFD"]').forEach(el => {
                    el.parentElement.style.display = 'none';
                });
                document.querySelectorAll('[id^="ASD"]').forEach(el => {
                    el.parentElement.style.display = 'block';
                });
            }
        });
        
        // Trigger the change event to set initial visibility
        const changeEvent = new Event('change');
        designMethodSelect.dispatchEvent(changeEvent);
    }
});
    </script>
</body>
</html>