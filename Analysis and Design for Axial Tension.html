<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Principle of Steel Design</title>
    <link rel="stylesheet" href="style.css"/>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
    <header>
        <div class="header"><b>STEEL DESIGN HELPER</b></div>
        
    </header>

    <nav class="navbar">
        <div class="ADcon">
            <a class="con" href="index.html">|HOME|</a>
            <a class="con" id="active" href="Analysis and Design for Axial Tension.html">|Analysis and Design for Axial Tension|</a>
            <a class="con" href="Analysis and Design for Axial Compression.html">|Analysis and Design for Axial Compression|</a>
            <a class="con" href="Analysis and Design of Members for Bending.html">|Analysis and Design of Members for Bending|</a>
            <a class="con" href="Shear Strength of Structural Member.html">|Shear Strength of Structural Member|</a>
        </div>
    </nav>

    <div class="AnalysisAxialTen">
        <div class="AxielT" style="display: in;">
            <h1 >Analysis of Tension Member</h1>
        </div>
        <div class="AxialTenionmember">

        <div class="AnalysisTen">
            <div id="ASTMSPEC" class="AxialTen">
                <form>
                    <h2>ASTM SPECIFICATION</h2>
                    <select id="ASpecA">
                        <option value="A36">A36</option>
                        <option value="A572Gr.42">A572 Gr. 42</option>
                        <option value="A572Gr.50">A572 Gr. 50</option>
                        <option value="A572Gr.55">A572 Gr. 55</option>
                        <option value="A572Gr.60">A572 Gr. 60</option>
                        <option value="A572Gr.65">A572 Gr. 65</option>
                        <option value="A588Gr.42">A588 Gr. 42</option>
                        <option value="A588Gr.46">A588 Gr. 46</option>
                        <option value="A588Gr.50">A588 Gr. 50</option>
                        <option value="A687">A687</option>
                        <option value="A992">A992</option>
                    </select>

                    <h2>HOLE</h2>
                    <label>Diameter of bolts:</label>
                    <input type="number" id="dholeA" step="0.001" placeholder="inches" required><br>
                    <label>Number of holes per column (max 6):</label>
                    <input type="number" id="nholeC" min="1" max="6" value="3"/><br>
                    <label>Number of holes per row (max 6):</label>
                    <input type="number" id="nholeR" min="1" max="6" value="3"/>

                    <h2>SHEAR LAG FACTOR</h2>
                    <select id="ulagCase">
                        <option value="1">Case 1</option>
                        <option value="2">Case 2</option>
                        <option value="7">Case 7</option>
                        <option value="8">Case 8</option>
                    </select>
                    <label>Length (in):</label>
                    <input type="number" id="lengthA" placeholder="Length">

                    <h2>STEEL</h2>
                    <label>Shape:</label>
                    <select id="shapeA">
                        <option value="W">W</option>
                    </select>
                    <label>Dimension:</label>
                    <input type="text" id="dimA" placeholder="12X45" required>

                    <div class="blockstag-column">
                        <div id="blockShearInputs" style="display:none;">
                            <label>Agv:</label><input type="number" id="Agv" placeholder="in²" step="0.001"><br>
                            <label>Anv:</label><input type="number" id="Anv" placeholder="in²" step="0.001"><br>
                            <label>Ant:</label><input type="number" id="Ant" placeholder="in²" step="0.001">
                        </div>
                    </div>

                    <h2>CHOOSE ONE OPTION ONLY</h2>
                    <label><input type="radio" name="designOption" value="none" checked> No Block Shear or Stagger</label><br>
                    <label><input type="radio" name="designOption" value="block"> Include Block Shear Only</label><br>
                    <label><input type="radio" name="designOption" value="stagger"> Include Staggered Holes Only</label><br>

                    <input type="button" class="Calculate" value="Calculate">

                </form>
                
            </div>

            <div class="AxialTenR" id="Result">
                <div class="YS"><div class="RESULT"><p class="YSt">GROSS CROSS SECTION:</p><p id="AG" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">NET AREA:</p><p id="AE" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">YIELDING IN GROSS CROSS SECTION: </p><p id="YC" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">FRACTURE IN EFFECTIVE NET AREA:</p><p id="FS" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">LRFD:</p><p id="LRFD" style="color:red;"></p></div></div>
                <div class="YS"><div class="RESULT"><p class="YSt">ASD:</p><p id="ASD" style="color:red;"></p></div></div>
                <!-- New result display for staggered hole calculations -->
                <div class="YS" id="failurePathResult" style="display:none;">
                    <div class="RESULT"><p class="YSt">ZIGZAG FAILURE PATH:</p><p id="criticalPath" style="color:red;"></p></div>
                </div>
                <div class="YS" id="staggerReductionResult" style="display:none;">
                    <div class="RESULT"><p class="YSt">STAGGER REDUCTION:</p><p id="staggerReduction" style="color:red;"></p></div>
                </div>
                <div></div>
            </div>
        </div>

        <div id="shearDiv" class="BLOCKSTAGGER" style="display:none;">
            

            <div id="column-inputs">
                <h3>Remove Specific Hole</h3>
                <div class="control-section">
                    <div class="control-group">
                        <label for="removeRow">Row (1–6):</label>
                        <input type="number" id="removeRow" min="1" max="6" placeholder="1–6">
                        
                        <label for="removeCol">Column (1–6):</label>
                        <input type="number" id="removeCol" min="1" max="6" placeholder="1–6">
                        
                        <button onclick="removeSpecificHole()">Remove Hole</button>
                    </div>
            
                    <div class="control-group">
                        <label for="removeHoleCol">Remove Entire Column (1–6):</label>
                        <input type="number" id="removeHoleCol" min="1" max="6" placeholder="Column #">
                        <button onclick="removeHoleColumn()">Remove Column</button>
                    </div>
            
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button class="restore-btn" onclick="restoreAllHoles()">Restore All Holes</button>
                    </div>
            
                    <div class="control-group">
                        <label for="spacingS">Horizontal spacing (s):</label>
                        <input type="number" id="spacingS" value="2" step="0.1" class="stagger-input"> in
            
                        <label for="spacingG">Vertical spacing (g):</label>
                        <input type="number" id="spacingG" value="1.5" step="0.1" class="gauge-input"> in
                    </div>
                </div>
            
                <div id="dynamicFlange" style="position:relative; width:400px; height:300px; border:2px solid black; background:#f0f0f0; margin-top:20px;"></div>
            </div>
        </div>
   
        <div class="DesignAxialTen">
        <hr>
        <div class="AxialD">
            <h1 style="text-align: center;">Design of Tension Member</h1>
        </div>
        <div class="DesignT">
            <div class="DesignTenData">
                
                <div>
            
                <form action="">
                    <div class="input-group">
                        <label for="designMethod">Design Method:</label>
                        <select id="designMethod">
                            <option value="LRFD">LRFD</option>
                            <option value="ASD">ASD</option>
                        </select>
                    </div>
                    
                    <label>ASTM Specification</label>
                    <select id="ASpecD" name="ASTM SPECIFICATION">
                        <option value="A36">A36</option>
                        <option value="A572Gr.42">A572 Gr. 42</option>
                        <option value="A572Gr.50">A572 Gr. 50</option>
                        <option value="A572Gr.55">A572 Gr. 55</option>
                        <option value="A572Gr.60">A572 Gr. 60</option>
                        <option value="A572Gr.65">A572 Gr. 65</option>
                        <option value="A588Gr.42">A588 Gr. 42</option>
                        <option value="A588Gr.46">A588 Gr. 46</option>
                        <option value="A588Gr.50">A588 Gr. 50</option>
                        <option value="A687">A687</option>
                        <option value="A992">A992</option>
                       
                    </select>
                </div>
                <div>
                    Shear Lag:
                    <select id="ulagCase"> 
                        <option value="1">Case 1</option>
                        <option value="2">Case 2</option>
                        <option value="7">Case 7</option>
                        <option value="8">Case 8</option>
                    </select>
                 </div>
                 <div>

                    <label for="DeadDload">Dead Load:</label>
                    <input id="Dload" type="number" placeholder="kips">
                </div>
                <div>
                    <label for="Lload">Live Load:</label>
                    <input id="Lload" type="number" placeholder="kips">
                 </div>
                 <div>
                    <label for="length">Length:</label>
                    
                    <input id="LenghtD" type="number" placeholder="ft."  step="0.001">
                </div>
                    <div>

                    <label for="dholeD"  >Diameter  of Bolts:</label>
                    <input id="dholeD" typ="numebr" placeholder="in."  step="0.001">
                    </div>  

                    
                    <div><label>number of holes</label>
                    <input class="nholeD" placeholder="in." type="number" > </div>
                    <button class="Design" id="design">DESIGN</button> 

                    
            </form>



            
            </div>
    

        </div>

    </div>
    <div class="DesignTRes">
        <div class="DesignCalcT">
            
            <h1>Design Calculation</h1>
            <div class="LRFDdis">
                <H2>Step 1: Load Combinations</H2>

            <h4>LRFD Load Combination: 1.2D + 1.6L=<p id="LRFDdesignComb"></p></h4> <h4>ASD Load Combination: 1.4D =<p id="ASDdesignComb"></p></h4>
            </div> 
        </div>    
            <div class="DesignCalcT">
            <h2>Step 2: Required Area Calculation</h2>
            <h3>For Yielding (LRFD):</h3>
            <h4>Pu ≤ φPn = φFyAg <br>
                Ag ≥ Pu / (φFy) = <p id="LRFDYielding"></p></h4>
                <h3>For Yielding (ASD):</h3>
            <h4>TnΩ = FyAg/Ω = FyAg /1.67 <br>
                Ag ≥ Pu / (φFy) = <p id="ASDYielding"></p></h4>
                <h3>For Fracture (LRFD):</h3>
                <h4>Pu ≤ φPn = φFuAe = <p id="LRFDFracture"></p></p></h4>
                <h3>For Fracture (ASD):</h3>
                <h4>Tn/Ω = FuAe/Ω = FuAe/2.00 <p id="ASDFracture"></p></p></h4>

            <H3 >Controlling Ag requirement: <p class="controlR"></p></H3>     
        </div>
                                <div class="DesignCon">
                                                     <div class="recommended-shapes">
                 <h2>Recommended W Shapes</h2>
                <p>The following shapes provide sufficient area for the tension member:</p>
                
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Shape</th>
                            <th>Area (in²)</th>
                            <th>Capacity/Demand</th>
                            <th>Weight (lb/ft)</th>
                            <th>Depth (in)</th>
                            <th>Width (in)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td id="rank1"></td>
                            <td id="Shape1"></td>
                            <td id="AreaG1"></td>
                            <td id="CD1"></td>
                            <td id="Weight1"></td>
                            <td id="Depth1"></td>
                            <td id="Width1"></td>
                        </tr>
                        <tr>
                            <td id="rank2"></td>
                            <td id="Shape2"></td>
                            <td id="AreaG2"></td>
                            <td id="CD2"></td>
                            <td id="Weight2"></td>
                            <td id="Depth2"></td>
                            <td id="Width2"></td>
                        </tr>
                        <tr>
                            <td id="rank3"></td>
                            <td id="Shape3"></td>
                            <td id="AreaG3"></td>
                            <td id="CD3"></td>
                            <td id="Weight3"></td>
                            <td id="Depth3"></td>
                            <td id="Width3"></td>
                        </tr>
                        <tr>
                            <td id="rank4"></td>
                            <td id="Shape4"></td>
                            <td id="AreaG4"></td>
                            <td id="CD4"></td>
                            <td id="Weight4"></td>
                            <td id="Depth4"></td>
                            <td id="Width4"></td>
                        </tr>
                        
                    </tbody>
                </table>
                
                
                
               
                                        </div>
                                                    </div>

        
            
 
   
   
    </div>
</div>
    <script>
    
    // Add a loading state
let dataLoaded = false;

function loadExcelData() {
    console.log("Loading Excel data...");
    dataLoaded = false;
    
    // Show loading indicator
    const loadingIndicator = document.createElement('div');
    loadingIndicator.id = 'loading-indicator';
    loadingIndicator.innerHTML = 'Loading steel section data...';
    loadingIndicator.style.position = 'fixed';
    loadingIndicator.style.top = '10px';
    loadingIndicator.style.right = '10px';
    loadingIndicator.style.padding = '5px 10px';
    loadingIndicator.style.backgroundColor = '#ffe0e0';
    loadingIndicator.style.border = '1px solid #ffcccc';
    loadingIndicator.style.borderRadius = '3px';
    loadingIndicator.style.zIndex = '1000';
    document.body.appendChild(loadingIndicator);
    
    fetch('ASTMSPEC.xlsx')
        .then(res => res.arrayBuffer())
        .then(data => {
            const workbook = XLSX.read(data, { type: 'array' });
            const shapeSheet = workbook.Sheets[workbook.SheetNames[1]];
            const shapeRows = XLSX.utils.sheet_to_json(shapeSheet);

            console.log("Excel data loaded, processing", shapeRows.length, "rows");
            
            shapeRows.forEach(row => {
                if (row["AISC_Manual_Label"]) {
                    const label = row["AISC_Manual_Label"].trim().toUpperCase().replace(/\s/g, '');
                    steelData[label] = {
                        A: parseFloat(row.A),
                        tw: parseFloat(row.tw),
                        d: parseFloat(row.d),
                        bf: parseFloat(row.bf)
                    };
                }
            });
            
            console.log("Steel data loaded:", Object.keys(steelData).length, "sections");
            dataLoaded = true;
            
            // Remove loading indicator
            document.getElementById('loading-indicator').remove();
        })
        .catch(error => {
            console.error("Error loading Excel data:", error);
            // Fallback to some default data
            steelData["W12X45"] = { A: 13.2, tw: 0.335, d: 12.1, bf: 8.05 };
            
            // Update loading indicator
            document.getElementById('loading-indicator').innerHTML = 'Failed to load data. Using defaults.';
            document.getElementById('loading-indicator').style.backgroundColor = '#ffcccc';
            
            setTimeout(() => {
                document.getElementById('loading-indicator').remove();
            }, 3000);
            
            dataLoaded = true;
        });
}


        // Add this function to debug the steel data loading
function debugSteelData(sectionKey) {
    console.log("Looking for section: " + sectionKey);
    console.log("Available steel data keys:", Object.keys(steelData));
    console.log("Found section data:", steelData[sectionKey]);
    
    // Check if we have any keys that are similar
    const similarKeys = Object.keys(steelData).filter(key => 
        key.includes(sectionKey.replace('W', '')) || 
        sectionKey.includes(key.replace('W', ''))
    );
    
    if (similarKeys.length > 0) {
        console.log("Similar keys found:", similarKeys);
    }
    
    return steelData[sectionKey];
}

// Modify the section retrieval in calculateZigzagNetArea and other functions
function getSectionData() {
    const shape = document.getElementById('shapeA').value.toUpperCase();
    const dim = document.getElementById('dimA').value.toUpperCase().replace(/\s/g, '');
    const sectionKey = shape + dim;
    
    console.log("Attempting to get section data for:", sectionKey);
    
    const section = steelData[sectionKey];
    
    // If not found, try with different formatting
    if (!section) {
        console.log("Section not found, trying alternative formats...");
        // Try alternative formats
        const altKey1 = shape + dim.replace('X', 'x');
        const altKey2 = shape + 'X' + dim.replace('X', '');
        
        if (steelData[altKey1]) {
            console.log("Found with format:", altKey1);
            return steelData[altKey1];
        } else if (steelData[altKey2]) {
            console.log("Found with format:", altKey2);
            return steelData[altKey2];
        }
        
        // Log all available keys for debugging
        console.log("Available keys:", Object.keys(steelData).join(", "));
        console.log("Using default values");
        
        // Return default values if not found
        return { 
            A: 13.2, 
            tw: 0.335, 
            d: 12.1, 
            bf: 8.05 
        };
    }
    
    console.log("Section found:", section);
    return section;
}

        // Add this function to create the interactive drawing area
function createInteractiveDrawingArea() {
    const flange = document.getElementById('dynamicFlange');
    flange.innerHTML = '';
    
    // Create a grid layout that users can click to toggle holes
    const nholeC = parseInt(document.getElementById('nholeC').value);
    const nholeR = parseInt(document.getElementById('nholeR').value);
    const s = parseFloat(document.getElementById('spacingS').value);
    const g = parseFloat(document.getElementById('spacingG').value);
    const pxPerIn = 20, leftStart = 60, topStart = 40;
    
    // Create instructions
    const instructions = document.createElement('div');
    instructions.innerHTML = '<strong>Click to add/remove holes</strong>';
    instructions.style.position = 'absolute';
    instructions.style.top = '5px';
    instructions.style.left = '5px';
    instructions.style.color = 'blue';
    flange.appendChild(instructions);
    
    // Create the grid
    for (let row = 0; row < nholeC; row++) {
        for (let col = 0; col < nholeR; col++) {
            const x = leftStart + col * s * pxPerIn;
            const y = topStart + row * g * pxPerIn;
            
            // Create grid cell background
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.style.width = '20px';
            cell.style.height = '20px';
            cell.style.border = '1px dashed #ccc';
            cell.style.position = 'absolute';
            cell.style.left = `${x - 5}px`;
            cell.style.top = `${y - 5}px`;
            cell.dataset.row = row + 1;
            cell.dataset.col = col + 1;
            flange.appendChild(cell);
            
            // Create hole (initially with full opacity)
            const hole = document.createElement('div');
            hole.className = 'hole';
            hole.style.width = '10px';
            hole.style.height = '10px';
            hole.style.borderRadius = '50%';
            hole.style.backgroundColor = 'black';
            hole.style.position = 'absolute';
            hole.style.left = `${x}px`;
            hole.style.top = `${y}px`;
            hole.dataset.row = row + 1;
            hole.dataset.col = col + 1;
            hole.dataset.active = '1'; // Default is active
            flange.appendChild(hole);
            
            // Make holes clickable
            hole.addEventListener('click', function() {
                if (this.dataset.active === '1') {
                    this.style.opacity = '0.2';
                    this.dataset.active = '0';
                    removedHoles.add(`${this.dataset.row}-${this.dataset.col}`);
                } else {
                    this.style.opacity = '1';
                    this.dataset.active = '1';
                    removedHoles.delete(`${this.dataset.row}-${this.dataset.col}`);
                }
            });
            
            // Add spacing labels
            if (row < nholeC - 1 && col === 0) {
                const label = document.createElement('div');
                label.style.position = 'absolute';
                label.style.left = `${x - 30}px`;
                label.style.top = `${y + g * pxPerIn / 2 - 8}px`;
                label.style.color = 'red';
                label.innerHTML = `${g}"`;
                flange.appendChild(label);
            }
            
            if (col < nholeR - 1 && row === 0) {
                const hLabel = document.createElement('div');
                hLabel.style.position = 'absolute';
                hLabel.style.left = `${x + s * pxPerIn / 2 - 8}px`;
                hLabel.style.top = `${y - 20}px`;
                hLabel.style.color = 'red';
                hLabel.innerHTML = `${s}"`;
                flange.appendChild(hLabel);
            }
        }
    }
    
    // Add clear and fill buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.position = 'absolute';
    buttonContainer.style.bottom = '10px';
    buttonContainer.style.right = '10px';
    
    const clearBtn = document.createElement('button');
    clearBtn.innerText = 'Clear All Holes';
    clearBtn.onclick = function() {
        document.querySelectorAll('.hole').forEach(hole => {
            hole.style.opacity = '0.2';
            hole.dataset.active = '0';
            removedHoles.add(`${hole.dataset.row}-${hole.dataset.col}`);
        });
    };
    
    const fillBtn = document.createElement('button');
    fillBtn.innerText = 'Fill All Holes';
    fillBtn.onclick = function() {
        document.querySelectorAll('.hole').forEach(hole => {
            hole.style.opacity = '1';
            hole.dataset.active = '1';
            removedHoles.delete(`${hole.dataset.row}-${hole.dataset.col}`);
        });
    };
    
    buttonContainer.appendChild(clearBtn);
    buttonContainer.appendChild(document.createTextNode(' '));
    buttonContainer.appendChild(fillBtn);
    flange.appendChild(buttonContainer);
}

// Replace updateHoleLayout with the interactive drawing version
function updateHoleLayout() {
    createInteractiveDrawingArea();
}

        // Global variables
        let removedHoles = new Set();
        let steelData = {};

        // ASTM material properties
        const astmData = {
            "A36": { Fy: 36, Fu: 58 }, 
            "A572GR42": { Fy: 42, Fu: 60 }, 
            "A572GR50": { Fy: 50, Fu: 65 },
            "A572GR55": { Fy: 55, Fu: 70 }, 
            "A572GR60": { Fy: 60, Fu: 75 }, 
            "A572GR65": { Fy: 65, Fu: 80 },
            "A588GR42": { Fy: 42, Fu: 63 }, 
            "A588GR46": { Fy: 46, Fu: 67 }, 
            "A588GR50": { Fy: 50, Fu: 70 },
            "A687": { Fy: 45, Fu: 75 }, 
            "A992": { Fy: 50, Fu: 65 }
        };


const styleElement = document.createElement('style');
styleElement.textContent = `
    .hole {
        cursor: pointer;
        transition: opacity 0.2s;
    }
    .hole:hover {
        box-shadow: 0 0 5px blue;
    }
    .grid-cell:hover {
        background-color: rgba(200, 200, 255, 0.3);
    }
    #dynamicFlange button {
        margin: 0 5px;
        padding: 5px 10px;
        background-color: #f0f0f0;
        border: 1px solid #999;
        border-radius: 3px;
        cursor: pointer;
    }
    #dynamicFlange button:hover {
        background-color: #e0e0e0;
    }
`;
document.head.appendChild(styleElement);

        // Toggle display based on design option
        function toggleShearDiv() {
    const selection = document.querySelector('input[name="designOption"]:checked').value;
    document.getElementById('shearDiv').style.display = (selection !== 'none') ? 'block' : 'none';
    document.getElementById('blockShearInputs').style.display = selection === 'block' ? 'block' : 'none';
    document.getElementById('column-inputs').style.display = selection === 'stagger' ? 'block' : 'none';
    document.getElementById('failurePathResult').style.display = selection === 'stagger' ? 'block' : 'none';
    document.getElementById('staggerReductionResult').style.display = selection === 'stagger' ? 'block' : 'none';
    
    // Initialize drawing area if stagger option is selected
    if (selection === 'stagger') {
        createInteractiveDrawingArea();
    }
}


function getHolePattern() {
    const nholeC = parseInt(document.getElementById('nholeC').value);
    const nholeR = parseInt(document.getElementById('nholeR').value);
    const pattern = [];
    
    for (let row = 0; row < nholeC; row++) {
        pattern[row] = [];
        for (let col = 0; col < nholeR; col++) {
            const holeElement = document.querySelector(`.hole[data-row="${row+1}"][data-col="${col+1}"]`);
            if (holeElement && holeElement.dataset.active === '1') {
                pattern[row][col] = 1; // Active hole
            } else {
                pattern[row][col] = 0; // Inactive hole
            }
        }
    }
      return pattern;
}

        
        // Get form input values
        function getInputValues() {
            return {
                ASTM: document.getElementById('ASpecA').value.toUpperCase().replace(/\./g, ''),
                dhole: parseFloat(document.getElementById('dholeA').value),
                nholeC: parseInt(document.getElementById('nholeC').value),
                nholeR: parseInt(document.getElementById('nholeR').value),
                spacingS: parseFloat(document.getElementById('spacingS').value),
                spacingG: parseFloat(document.getElementById('spacingG').value),
                caseId: document.getElementById('ulagCase').value,
                length: parseFloat(document.getElementById('lengthA').value),
                shape: document.getElementById('shapeA').value.toUpperCase(),
                dim: document.getElementById('dimA').value.toUpperCase().replace(/\s/g, ''),
                designOption: document.querySelector('input[name="designOption"]:checked').value
            };
        }

        // Calculate shear lag factor U
        function calculateU(caseId, xbar, length, bf, d) {
            switch (parseInt(caseId)) {
                case 1: return 1.0;
                case 2: 
                    const case2Value = 1 - (xbar / length);
                    return case2Value;
                case 7: 
                    const case2ForComp = 1 - (xbar / length);
                    return Math.max(bf / d >= 2 / 3 ? 0.9 : 0.8, case2ForComp);
                case 8: return 0.8;
                default: return 1.0;
            }
        }

        function updateColumnControls() {
    const columnInputs = document.getElementById('column-inputs');
    columnInputs.innerHTML = `
        <h3>Interactive Hole Pattern</h3>
        <div class="control-section">
            <div class="control-group">
                <label for="spacingS">Horizontal spacing (s):</label>
                <input type="number" id="spacingS" value="2" step="0.1" class="stagger-input"> in
                
                <label for="spacingG">Vertical spacing (g):</label>
                <input type="number" id="spacingG" value="1.5" step="0.1" class="gauge-input"> in
                
                <button onclick="updateGrid()">Update Grid</button>
            </div>
            
            <div class="control-group" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ccc;">
                <h4>Path Calculation Options</h4>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathAuto" name="pathMethod" value="auto" checked>
                    <label for="pathAuto">Find critical path automatically</label>
                </div>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathManual" name="pathMethod" value="manual">
                    <label for="pathManual">Specify custom path</label>
                </div>
                
                <div id="customPathContainer" style="margin-top: 10px; display: none;">
                    <label for="customPathInput">Custom Path (format: 1-1,1-2,2-3,...):</label><br>
                    <input type="text" id="customPathInput" placeholder="row-col,row-col,..." style="width: 90%; margin-top: 5px;">
                    <div style="margin-top: 5px; font-size: 0.85em; color: #666;">
                        Example: 1-1,1-2,2-3 means path from hole (1,1) → (1,2) → (2,3)
                    </div>
                    <button id="visualizePath" style="margin-top: 8px;">Visualize Path</button>
                </div>
            </div>
        </div>
        
        <div id="dynamicFlange" style="position:relative; width:400px; height:300px; border:2px solid black; background:#f0f0f0; margin-top:20px;"></div>
    `;
    
    // Add event listeners for the spacing inputs
    document.getElementById('spacingS').addEventListener('change', updateGrid);
    document.getElementById('spacingG').addEventListener('change', updateGrid);
    
    // Add event listeners for path selection
    document.getElementById('pathAuto').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'none';
    });
    
    document.getElementById('pathManual').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'block';
    });
    
    // Add event listener for path visualization
    document.getElementById('visualizePath').addEventListener('click', visualizeCustomPath);
}
    function updateGrid() {
    // Save current pattern
    const pattern = getHolePattern();
    
    // Recreate the drawing area
    createInteractiveDrawingArea();
    
    // Restore pattern
    const nholeC = parseInt(document.getElementById('nholeC').value);
    const nholeR = parseInt(document.getElementById('nholeR').value);
    
    for (let row = 0; row < Math.min(nholeC, pattern.length); row++) {
        for (let col = 0; col < Math.min(nholeR, pattern[row].length); col++) {
            if (pattern[row][col] === 0) {
                const holeElement = document.querySelector(`.hole[data-row="${row+1}"][data-col="${col+1}"]`);
                if (holeElement) {
                    holeElement.style.opacity = '0.2';
                    holeElement.dataset.active = '0';
                    removedHoles.add(`${row+1}-${col+1}`);
                }
            }
        }
    }
}

function visualizeOptimalPath() {
    // First reset all path highlights
    document.querySelectorAll('.path-highlight').forEach(el => {
        el.remove();
    });
    
    const holePattern = getHolePattern();
    const path = findOptimalStagPath(holePattern);
    
    if (path.length < 2) {
        alert("Not enough active holes to create a path");
        return;
    }
    
    // Create visualization
    const flange = document.getElementById('dynamicFlange');
    
    // Create SVG container for path lines
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.classList.add('path-overlay', 'path-highlight');
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.style.pointerEvents = 'none';
    flange.appendChild(svg);
    
    // Draw lines and markers for the path
    for (let i = 0; i < path.length; i++) {
        const [row, col] = path[i];
        
        // Get the hole element
        const hole = document.querySelector(`.hole[data-row="${row+1}"][data-col="${col+1}"]`);
        if (!hole) continue;
        
        // Get coordinates
        const holeRect = hole.getBoundingClientRect();
        const flangeRect = flange.getBoundingClientRect();
        const x = holeRect.left + holeRect.width/2 - flangeRect.left;
        const y = holeRect.top + holeRect.height/2 - flangeRect.top;
        
        // Add number marker to hole
        const marker = document.createElement('div');
        marker.classList.add('path-marker', 'path-highlight');
        marker.style.position = 'absolute';
        marker.style.left = (x - 8) + 'px';
        marker.style.top = (y - 8) + 'px';
        marker.style.width = '16px';
        marker.style.height = '16px';
        marker.style.borderRadius = '50%';
        marker.style.backgroundColor = 'rgba(255,0,0,0.2)';
        marker.style.border = '2px solid red';
        marker.style.color = 'red';
        marker.style.display = 'flex';
        marker.style.alignItems = 'center';
        marker.style.justifyContent = 'center';
        marker.style.fontWeight = 'bold';
        marker.style.fontSize = '10px';
        marker.style.zIndex = '10';
        marker.textContent = i + 1;
        flange.appendChild(marker);
        
        // Draw line to next point
        if (i < path.length - 1) {
            const [nextRow, nextCol] = path[i+1];
            const nextHole = document.querySelector(`.hole[data-row="${nextRow+1}"][data-col="${nextCol+1}"]`);
            
            if (nextHole) {
                const nextRect = nextHole.getBoundingClientRect();
                const x2 = nextRect.left + nextRect.width/2 - flangeRect.left;
                const y2 = nextRect.top + nextRect.height/2 - flangeRect.top;
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', y);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', 'red');
                line.setAttribute('stroke-width', '2');
                svg.appendChild(line);
            }
        }
    }
    
    // Set the path to the custom path input
    const customPathInput = document.getElementById('customPathInput');
    if (customPathInput) {
        const pathStr = path.map(p => `${p[0]+1}-${p[1]+1}`).join(',');
        customPathInput.value = pathStr;
    }
}


function findOptimalStagPath(holePattern) {
    const rows = holePattern.length;
    const cols = holePattern[0].length;
    const path = [];
    
    // Start searching from the top row
    for (let row = 0; row < rows; row++) {
        // First try to find a hole in column 1 for this row
        if (holePattern[row][0] === 1) {
            path.push([row, 0]);
            continue; // Move to next row
        }
        
        // If no hole in column 1, find one in any other column
        let holeFound = false;
        for (let col = 1; col < cols; col++) {
            if (holePattern[row][col] === 1) {
                path.push([row, col]);
                holeFound = true;
                break; // Only take one hole per row
            }
        }
        
        // Skip rows with no holes
        if (!holeFound) {
            continue;
        }
    }
    
    return path;
}
    





  
function calculateZigzagNetArea(Ag, holePattern, holeDia, s, g) {
    const d_hole = holeDia + 1/8; // Add 1/8" for standard hole
    const nholeC = holePattern.length; // rows
    const nholeR = holePattern[0].length; // columns
    
    // Get section properties for hole area calculation
    const sectionKey = document.getElementById('shapeA').value + document.getElementById('dimA').value.toUpperCase().replace(/\s/g, '');
    const section = steelData[sectionKey] || { tw: 0.335 }; // Use default if not found
    const tw = section.tw; // Web thickness for hole area
    
    // Calculate standard net area using the critical column approach
    const standardResult = calculateStandardNetArea(
        Ag,
        holePattern,
        holeDia,
        tw
    );
    const standardNetArea = standardResult.netArea;
    
    // Check if manual path selection is active
    const useManualPath = document.getElementById('pathManual') && 
                         document.getElementById('pathManual').checked;
    
    if (useManualPath) {
        // Use custom path from input
        const pathInput = document.getElementById('customPathInput').value.trim();
        if (!pathInput) {
            alert("Please enter a valid path or switch to automatic calculation");
            return {
                standardNetArea: standardNetArea,
                netArea: standardNetArea,
                criticalPath: "No valid path specified",
                staggerReduction: 0
            };
        }
        
        try {
            // Parse the path string into array of [row, col] coordinates
            const customPath = pathInput.split(',').map(coord => {
                const [row, col] = coord.trim().split('-').map(Number);
                if (isNaN(row) || isNaN(col) || row < 1 || col < 1 || 
                    row > nholeC || col > nholeR || holePattern[row-1][col-1] !== 1) {
                    throw new Error(`Invalid or inactive hole at position (${row},${col})`);
                }
                return [row-1, col-1]; // Convert to 0-based indexing
            });
            
            if (customPath.length < 2) {
                throw new Error("Path must contain at least 2 points");
            }
            
            // Calculate net area for this custom path
            let holeLoss = customPath.length * d_hole * tw;
            let totalStaggerReduction = 0;
            
            // Calculate stagger reduction for each diagonal segment
            for (let i = 1; i < customPath.length; i++) {
                const [prevRow, prevCol] = customPath[i-1];
                const [currRow, currCol] = customPath[i];
                
                // If moving diagonally (both row and column change)
                if (prevRow !== currRow && prevCol !== currCol) {
                    const dx = Math.abs(currCol - prevCol) * s; // Horizontal spacing
                    const dy = Math.abs(currRow - prevRow) * g; // Vertical spacing
                    const staggerReduction = Math.pow(dx, 2) / (4 * dy);
                    totalStaggerReduction += staggerReduction;
                }
            }
            
            // Calculate net area for this path
            const netArea = Ag - holeLoss + (totalStaggerReduction * tw);
            
            // Path summary for display
            let pathSummary = `Custom Path: `;
            customPath.forEach((p, idx) => {
                pathSummary += `(${p[0]+1},${p[1]+1})`;
                if (idx < customPath.length - 1) pathSummary += " → ";
            });
            
            return {
                standardNetArea: standardNetArea,
                netArea: netArea,
                criticalPath: pathSummary,
                staggerReduction: totalStaggerReduction * tw
            };
            
        } catch (error) {
            alert("Error in custom path: " + error.message);
            return {
                standardNetArea: standardNetArea,
                netArea: standardNetArea,
                criticalPath: "Error in path: " + error.message,
                staggerReduction: 0
            };
        }
    } else {
        // Use new optimized path algorithm - one hole per row prioritizing column 1
        const path = findOptimalStagPath(holePattern);
        
        if (path.length < 2) {
            return {
                standardNetArea: standardNetArea,
                netArea: standardNetArea,
                criticalPath: "Insufficient holes for stagger calculation",
                staggerReduction: 0
            };
        }
        
        // Calculate net area
        let holeLoss = path.length * d_hole * tw;
        let totalStaggerReduction = 0;
        
        // Calculate stagger reduction for each diagonal segment
        for (let i = 1; i < path.length; i++) {
            const [prevRow, prevCol] = path[i-1];
            const [currRow, currCol] = path[i];
            
            // If moving diagonally (both row and column change)
            if (prevRow !== currRow && prevCol !== currCol) {
                const dx = Math.abs(currCol - prevCol) * s; // Horizontal spacing
                const dy = Math.abs(currRow - prevRow) * g; // Vertical spacing
                const staggerReduction = Math.pow(dx, 2) / (4 * dy);
                totalStaggerReduction += staggerReduction;
            }
        }
        
        // Calculate net area for this path
        const netArea = Ag - holeLoss + (totalStaggerReduction * tw);
        
        // Path summary for display
        let pathSummary = `One-per-row Path: `;
        path.forEach((p, idx) => {
            pathSummary += `(${p[0]+1},${p[1]+1})`;
            if (idx < path.length - 1) pathSummary += " → ";
        });
        
        return {
            standardNetArea: standardNetArea,
            netArea: netArea,
            criticalPath: pathSummary,
            staggerReduction: totalStaggerReduction * tw
        };
    }
}


function updateColumnControls() {
    const columnInputs = document.getElementById('column-inputs');
    columnInputs.innerHTML = `
        <h3>Interactive Hole Pattern</h3>
        <div class="control-section">
            <div class="control-group">
                <label for="spacingS">Horizontal spacing (s):</label>
                <input type="number" id="spacingS" value="2" step="0.1" class="stagger-input"> in
                
                <label for="spacingG">Vertical spacing (g):</label>
                <input type="number" id="spacingG" value="1.5" step="0.1" class="gauge-input"> in
                
                <button onclick="updateGrid()">Update Grid</button>
            </div>
            
            <div class="control-group" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ccc;">
                <h4>Path Calculation Options</h4>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathAuto" name="pathMethod" value="auto" checked>
                    <label for="pathAuto">One hole per row (prioritize column 1)</label>
                </div>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathLegacy" name="pathMethod" value="legacy">
                    <label for="pathLegacy">Find critical zigzag path (legacy)</label>
                </div>
                
                <div style="margin: 5px 0;">
                    <input type="radio" id="pathManual" name="pathMethod" value="manual">
                    <label for="pathManual">Specify custom path</label>
                </div>
                
                <div style="margin-top: 10px;">
                    <button onclick="visualizeOptimalPath()">Preview Current Path</button>
                </div>
                
                <div id="customPathContainer" style="margin-top: 10px; display: none;">
                    <label for="customPathInput">Custom Path (format: 1-1,1-2,2-3,...):</label><br>
                    <input type="text" id="customPathInput" placeholder="row-col,row-col,..." style="width: 90%; margin-top: 5px;">
                    <div style="margin-top: 5px; font-size: 0.85em; color: #666;">
                        Example: 1-1,1-2,2-3 means path from hole (1,1) → (1,2) → (2,3)
                    </div>
                    <button id="visualizePath" style="margin-top: 8px;">Visualize Path</button>
                </div>
            </div>
        </div>
        
        <div id="dynamicFlange" style="position:relative; width:400px; height:300px; border:2px solid black; background:#f0f0f0; margin-top:20px;"></div>
    `;
    
    // Add event listeners
    document.getElementById('spacingS').addEventListener('change', updateGrid);
    document.getElementById('spacingG').addEventListener('change', updateGrid);
    
    // Add event listeners for path selection
    document.getElementById('pathAuto').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'none';
    });
    
    document.getElementById('pathLegacy').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'none';
    });
    
    document.getElementById('pathManual').addEventListener('change', function() {
        document.getElementById('customPathContainer').style.display = 'block';
    });
    
    // Add event listener for path visualization
    document.getElementById('visualizePath').addEventListener('click', visualizeCustomPath);
    
    // Initialize the drawing area
    createInteractiveDrawingArea();
}


function findAllPathsRowBased(holePattern, startRow, startCol, maxCols, maxRows) {
    // Base case: if we've reached the last row
    if (startRow === maxRows - 1) {
        // Return current position as a single-element path if there's a hole here
        return holePattern[startRow][startCol] === 1 ? [[[startRow, startCol]]] : [];
    }
    
    let paths = [];
    
    // If there's a hole at the current position
    if (holePattern[startRow][startCol] === 1) {
        // Try moving to each hole in the next row
        for (let nextCol = 0; nextCol < maxCols; nextCol++) {
            const subPaths = findAllPathsRowBased(holePattern, startRow + 1, nextCol, maxCols, maxRows);
            
            // Attach current position to each subpath
            subPaths.forEach(subPath => {
                paths.push([[startRow, startCol], ...subPath]);
            });
        }
        
        // If no valid subpaths were found, return current position as endpoint
        if (paths.length === 0) {
            paths.push([[startRow, startCol]]);
        }
    }
    
    return paths;
}




// First, let's modify the calculateStandardNetArea function to find critical rows instead of columns
function calculateStandardNetArea(Ag, holeDia, totalHoles, tw) {
    const d_hole = holeDia + 1/8; // Add 1/8" for standard hole
    
    // Calculate net area by subtracting hole area from gross area
    const holeLoss = totalHoles * d_hole * tw;
    const netArea = Ag - holeLoss;
    
    return {
        netArea: netArea,
        holesCount: totalHoles
    };
}

   function performCalculations() {
    if (!dataLoaded) {
        alert("Steel section data is still loading. Please wait a moment and try again.");
        return;
    }
    const inputValues = getInputValues();
    
    // Validate inputs
    if (isNaN(inputValues.dhole) || inputValues.dhole <= 0) {
        alert("Please enter a valid hole diameter");
        return;
    }
    
    if (isNaN(inputValues.length) || inputValues.length <= 0) {
        alert("Please enter a valid length");
        return;
    }
    
    // Get material properties
    const material = astmData[inputValues.ASTM] || { Fy: 36, Fu: 58 };
    
    // Get section properties from steel data
    const sectionKey = inputValues.shape + inputValues.dim;
    const section = steelData[sectionKey] || { A: 0, d: 0, bf: 0, tw: 0 };
    
    if (!section.A) {
        // Default value if section not found
        section.A = 13.2;
        section.d = 12.1;
        section.bf = 8.05;
        section.tw = 0.335;
        console.warn("Section not found, using default values");
    }
    
    // Gross area
    const Ag = section.A;
    document.getElementById('AG').textContent = Ag.toFixed(3) + " in²";
    
    // Variables for net area and effective net area
    let An, Ae, criticalPathText = "", staggerReductionValue = 0;
    let standardNetArea = 0;
    
    // Calculate xbar for U (simplified - center of gravity to connection)
    const xbar = section.bf / 2;
        
    // Calculate U - shear lag factor
    const U = calculateU(
        inputValues.caseId,
        xbar, 
        inputValues.length,
        section.bf,
        section.d
    );
    
    if (inputValues.designOption === 'stagger') {
        const holePattern = getHolePattern();
        
        // Check which path method is selected
        let useManualPath = false;
        let useLegacyPath = false;
        
        if (document.getElementById('pathManual') && document.getElementById('pathManual').checked) {
            useManualPath = true;
        } else if (document.getElementById('pathLegacy') && document.getElementById('pathLegacy').checked) {
            useLegacyPath = true;
        }
        
        let result;
        
        if (useLegacyPath) {
            // Use the original zigzag function
            result = calculateLegacyZigzagNetArea(
                Ag, 
                holePattern, 
                inputValues.dhole, 
                inputValues.spacingS, 
                inputValues.spacingG
            );
        } else {
            // Use our new improved calculation
            result = calculateZigzagNetArea(
                Ag, 
                holePattern, 
                inputValues.dhole, 
                inputValues.spacingS, 
                inputValues.spacingG
            );
        }
        
        // Visualize the path after calculation
        if (!useManualPath) {
            visualizeOptimalPath();
        }
        
        standardNetArea = result.standardNetArea;
        An = result.netArea;  // This is the net area without the shear lag factor
        Ae = An * U;         // Apply shear lag factor to get effective net area
        criticalPathText = result.criticalPath;
        staggerReductionValue = result.staggerReduction;
        
        document.getElementById('criticalPath').textContent = criticalPathText;
        document.getElementById('staggerReduction').textContent = staggerReductionValue.toFixed(3) + " in²";
        
        // Update results to show both values - NET AREA first
        document.getElementById('AE').textContent = 
            `${An.toFixed(3)} in² (With stagger effect)`;
            
    } else if (inputValues.designOption === 'block') {
        // Block shear calculation
        const Agv = parseFloat(document.getElementById('Agv').value) || 0;
        const Anv = parseFloat(document.getElementById('Anv').value) || 0;
        const Ant = parseFloat(document.getElementById('Ant').value) || 0;
        
        if (Agv <= 0 || Anv <= 0 || Ant <= 0) {
            alert("Please enter valid values for block shear areas");
            return;
        }
        
        // AISC Equation J4-5
        const blockShear1 = 0.60 * material.Fu * Anv + material.Fy * Agv;
        // AISC Equation J4-5 (alternative)
        const blockShear2 = 0.60 * material.Fy * Agv + material.Fu * Ant;
        
        // For block shear, An is the minimum of the two calculations
        An = Math.min(blockShear1, blockShear2);
        Ae = An;  // For block shear, we don't apply the U factor
        
        document.getElementById('AE').textContent = An.toFixed(3) + " in² (Block shear)";
        
    } 
    
    else {
    // Simple calculation with holes - just count total holes in a column
    const tw = section.tw;
    const nholeC = parseInt(document.getElementById('nholeC').value);
    
    // Use function to calculate standard net area
    const standardAreaResult = calculateStandardNetArea(
        Ag,
        inputValues.dhole,
        nholeC, // Just pass the number of holes in a column
        tw
    );
    
    An = standardAreaResult.netArea;  // This is the net area (An)
    Ae = An * U;  // The effective net area (Ae) applies the shear lag factor
    
    // Show detailed information about NET AREA
    document.getElementById('AE').textContent = 
        `${An.toFixed(3)} in² (${standardAreaResult.holesCount} holes in column)`;
}
    
    // Calculate yielding strength (uses gross area)
    const Py = material.Fy * Ag;
    
    // Calculate fracture strength (uses effective net area)
    const Pf = material.Fu * Ae;  // Use Ae (effective net area)
    
    // Determine which limit state controls
    const isYieldingControls = Py <= Pf;
    
    // Display yielding strength with highlight if it controls
    document.getElementById('YC').innerHTML = isYieldingControls 
        ? `<span style="color:green; font-weight:bold">${Py.toFixed(1)} kips (CONTROLS)</span>` 
        : `${Py.toFixed(1)} kips`;
    
    // Display fracture strength with highlight if it controls
    document.getElementById('FS').innerHTML = !isYieldingControls 
        ? `<span style="color:green; font-weight:bold">${Pf.toFixed(1)} kips (CONTROLS)</span>` 
        : `${Pf.toFixed(1)} kips`;
    
    // Nominal strength is minimum of yield and fracture
    const Pn = Math.min(Py, Pf);
    
    // LRFD design strength
    const phiPn = 0.9 * Py; // φ = 0.9 for tension yielding
    const phiPnFracture = 0.75 * Pf; // φ = 0.75 for fracture
    const phiPnFinal = Math.min(phiPn, phiPnFracture);
    
    // Add text to indicate which governs LRFD
    const lrfdGoverns = phiPn <= phiPnFracture ? "yielding" : "fracture";
    document.getElementById('LRFD').textContent = `${phiPnFinal.toFixed(1)} kips (${lrfdGoverns})`;
    
    // ASD allowable strength
    // Use appropriate safety factor based on which failure mode controls
    const safetyFactor = isYieldingControls ? 1.67 : 2.0;
    const PnASD = Pn / safetyFactor;
    document.getElementById('ASD').textContent = `${PnASD.toFixed(1)} kips (${isYieldingControls ? "yielding" : "fracture"})`;
}

        // Event listeners
        document.querySelector('.Calculate').addEventListener('click', performCalculations);

document.querySelectorAll('input[name="designOption"]').forEach(el => {
    el.addEventListener('change', function() {
        toggleShearDiv();
        if (this.value === 'stagger') {
            updateColumnControls();
            createInteractiveDrawingArea();
        }
    });
});

document.addEventListener('DOMContentLoaded', function() {
    loadExcelData();
    toggleShearDiv();
});

// JavaScript for Axial Tension Member Design Calculator with Excel Data Import

// Function to load the SheetJS library
function loadScript(url) {
    return new Promise((resolve, reject) => {
        if (document.querySelector(`script[src="${url}"]`)) {
            resolve(); // Script already loaded
            return;
        }
        const script = document.createElement('script');
        script.src = url;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

// Function to read local Excel file using File API
async function readExcelFile(filePath) {
    try {
        // Load SheetJS library if not already loaded
        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js');
        
        // This is a mock function since direct file system access isn't allowed in browsers
        // In a real implementation, you would use a server-side approach or request user to select the file
        
        // For demonstration, we'll use hardcoded data that mimics what would be in the Excel file
        return [
            { shape: "W4X13", area: 3.83, weight: 13, depth: 4.16, width: 4.06 },
            { shape: "W5X16", area: 4.71, weight: 16, depth: 5.01, width: 5.00 },
            { shape: "W6X9", area: 2.68, weight: 9, depth: 5.90, width: 3.94 },
            { shape: "W6X12", area: 3.55, weight: 12, depth: 6.03, width: 4.00 },
            { shape: "W6X15", area: 4.43, weight: 15, depth: 5.99, width: 5.99 },
            { shape: "W6X16", area: 4.74, weight: 16, depth: 6.28, width: 4.03 },
            { shape: "W8X10", area: 2.96, weight: 10, depth: 7.89, width: 3.94 },
            { shape: "W8X13", area: 3.84, weight: 13, depth: 8.00, width: 4.00 },
            { shape: "W8X15", area: 4.44, weight: 15, depth: 8.11, width: 4.01 },
            { shape: "W8X18", area: 5.26, weight: 18, depth: 8.14, width: 5.25 },
            { shape: "W8X21", area: 6.16, weight: 21, depth: 8.28, width: 5.27 },
            { shape: "W10X12", area: 3.54, weight: 12, depth: 9.87, width: 3.96 },
            { shape: "W10X15", area: 4.41, weight: 15, depth: 10.11, width: 4.00 },
            { shape: "W10X17", area: 4.99, weight: 17, depth: 10.11, width: 4.01 },
            { shape: "W10X19", area: 5.62, weight: 19, depth: 10.24, width: 4.02 },
            { shape: "W10X22", area: 6.49, weight: 22, depth: 10.17, width: 5.75 },
            { shape: "W10X26", area: 7.61, weight: 26, depth: 10.33, width: 5.77 },
            { shape: "W12X14", area: 4.16, weight: 14, depth: 11.91, width: 3.97 },
            { shape: "W12X16", area: 4.71, weight: 16, depth: 12.00, width: 3.99 },
            { shape: "W12X19", area: 5.57, weight: 19, depth: 12.16, width: 4.01 },
            { shape: "W12X22", area: 6.48, weight: 22, depth: 12.31, width: 4.03 },
            { shape: "W12X26", area: 7.65, weight: 26, depth: 12.22, width: 6.49 },
            { shape: "W12X30", area: 8.79, weight: 30, depth: 12.34, width: 6.52 },
            { shape: "W14X22", area: 6.49, weight: 22, depth: 13.74, width: 5.00 },
            { shape: "W14X26", area: 7.69, weight: 26, depth: 13.91, width: 5.03 },
            { shape: "W14X30", area: 8.85, weight: 30, depth: 13.84, width: 6.73 },
            { shape: "W14X34", area: 10.0, weight: 34, depth: 13.98, width: 6.75 },
            { shape: "W16X26", area: 7.68, weight: 26, depth: 15.69, width: 5.50 },
            { shape: "W16X31", area: 9.12, weight: 31, depth: 15.88, width: 5.53 },
            { shape: "W16X36", area: 10.6, weight: 36, depth: 15.86, width: 6.99 },
            { shape: "W16X40", area: 11.8, weight: 40, depth: 16.01, width: 7.00 },
            { shape: "W18X35", area: 10.3, weight: 35, depth: 17.70, width: 6.00 },
            { shape: "W18X40", area: 11.8, weight: 40, depth: 17.90, width: 6.02 },
            { shape: "W18X46", area: 13.5, weight: 46, depth: 17.99, width: 7.50 },
            { shape: "W18X50", area: 14.7, weight: 50, depth: 18.06, width: 7.50 },
            { shape: "W21X44", area: 13.0, weight: 44, depth: 20.66, width: 6.50 },
            { shape: "W21X50", area: 14.7, weight: 50, depth: 20.83, width: 6.53 },
            { shape: "W21X57", area: 16.7, weight: 57, depth: 21.06, width: 6.56 },
            { shape: "W21X62", area: 18.3, weight: 62, depth: 20.99, width: 8.24 },
            { shape: "W24X55", area: 16.2, weight: 55, depth: 23.57, width: 7.01 },
            { shape: "W24X62", area: 18.2, weight: 62, depth: 23.74, width: 7.04 },
            { shape: "W24X68", area: 20.1, weight: 68, depth: 23.73, width: 8.97 },
            { shape: "W24X76", area: 22.4, weight: 76, depth: 23.92, width: 8.99 }
        ];
    } catch (error) {
        console.error("Error reading Excel file:", error);
        return null;
    }
}

// Get steel properties based on ASTM specification
function getSteelProperties(astmSpec) {
    const steelProperties = {
        "A36": { Fy: 36, Fu: 58 },
        "A572Gr.42": { Fy: 42, Fu: 60 },
        "A572Gr.50": { Fy: 50, Fu: 65 },
        "A572Gr.55": { Fy: 55, Fu: 70 },
        "A572Gr.60": { Fy: 60, Fu: 75 },
        "A572Gr.65": { Fy: 65, Fu: 80 },
        "A588Gr.42": { Fy: 42, Fu: 63 },
        "A588Gr.46": { Fy: 46, Fu: 67 },
        "A588Gr.50": { Fy: 50, Fu: 70 },
        "A687": { Fy: 50, Fu: 70 },
        "A992": { Fy: 50, Fu: 65 }
    };
    
    return steelProperties[astmSpec] || { Fy: 36, Fu: 58 }; // Default to A36 if not found
}

// Calculate shear lag factor U using the provided logic
function calculateU(caseId, xbar, length, bf, d) {
    switch (parseInt(caseId)) {
        case 1: return 1.0;
        case 2: 
            const case2Value = 1 - (xbar / length);
            return case2Value;
        case 7: 
            const case2ForComp = 1 - (xbar / length);
            return Math.max(bf / d >= 2 / 3 ? 0.9 : 0.8, case2ForComp);
        case 8: return 0.8;
        default: return 1.0;
    }
}

// Calculate required area
function calculateRequiredArea(deadLoad, liveLoad, designMethod, astmSpec, shearLagCase, length, dHole, numHoles, width, depth) {
    // Get steel properties
    const { Fy, Fu } = getSteelProperties(astmSpec);
    
    // Calculate design load
    let designLoad;
    if (designMethod === 'LRFD') {
        designLoad = 1.2 * deadLoad + 1.6 * liveLoad;
    } else { // ASD
        designLoad = deadLoad + liveLoad;
    }
    
    // Update load combination display
    document.getElementById('LRFDdesignComb').textContent = (1.2 * deadLoad + 1.6 * liveLoad).toFixed(2) + " kips";
    document.getElementById('ASDdesignComb').textContent = (deadLoad + liveLoad).toFixed(2) + " kips";
    
    // Calculate x-bar (estimation for typical W shapes)
    // This would ideally come from section properties, but we'll estimate for now
    const xbar = width / 4; // Simplified estimation
    
    // Get shear lag factor using the provided function
    const U = calculateU(shearLagCase, xbar, length, width, depth);
    
    // Display the calculated U factor
    const uFactorElement = document.getElementById('uFactor');
    if (uFactorElement) {
        uFactorElement.textContent = U.toFixed(3);
    }
    
    // Calculate required area for yielding
    let requiredAreaYielding;
    
    if (designMethod === 'LRFD') {
        // φ = 0.9 for yielding
        requiredAreaYielding = designLoad / (0.9 * Fy);
        const yieldElement = document.getElementById('LRFDYielding');
        if (yieldElement) {
            yieldElement.textContent = requiredAreaYielding.toFixed(2) + " in²";
        }
    } else { // ASD
        // Ω = 1.67 for yielding
        requiredAreaYielding = designLoad * 1.67 / Fy;
        const yieldElement = document.getElementById('ASDYielding');
        if (yieldElement) {
            yieldElement.textContent = requiredAreaYielding.toFixed(2) + " in²";
        }
    }
    
    // Calculate net area considering bolt holes
    const netAreaReduction = numHoles * dHole * 0.125; // For typical bolt holes: hole diameter * plate thickness * number of holes
    
    // Calculate required area for fracture
    let requiredAreaFracture;
    
    if (designMethod === 'LRFD') {
        // φ = 0.75 for fracture
        requiredAreaFracture = designLoad / (0.75 * Fu * U);
        const fractureElement = document.getElementById('LRFDFracture');
        if (fractureElement) {
            fractureElement.textContent = requiredAreaFracture.toFixed(2) + " in²";
        }
    } else { // ASD
        // Ω = 2.0 for fracture
        requiredAreaFracture = designLoad * 2.0 / (Fu * U);
        const fractureElement = document.getElementById('ASDFracture');
        if (fractureElement) {
            fractureElement.textContent = requiredAreaFracture.toFixed(2) + " in²";
        }
    }
    
    // Determine controlling area and color-code the results
    const controllingArea = Math.max(requiredAreaYielding, requiredAreaFracture);
    
    // Color code the governing case
    if (designMethod === 'LRFD') {
        const yieldElement = document.getElementById('LRFDYielding');
        const fractureElement = document.getElementById('LRFDFracture');
        
        if (yieldElement && fractureElement) {
            if (requiredAreaYielding >= requiredAreaFracture) {
                yieldElement.style.color = 'red';  // Yielding governs
                fractureElement.style.color = 'green';
            } else {
                yieldElement.style.color = 'green';
                fractureElement.style.color = 'red';  // Fracture governs
            }
        }
    } else { // ASD
        const yieldElement = document.getElementById('ASDYielding');
        const fractureElement = document.getElementById('ASDFracture');
        
        if (yieldElement && fractureElement) {
            if (requiredAreaYielding >= requiredAreaFracture) {
                yieldElement.style.color = 'red';  // Yielding governs
                fractureElement.style.color = 'green';
            } else {
                yieldElement.style.color = 'green';
                fractureElement.style.color = 'red';  // Fracture governs
            }
        }
    }
    
    // Update the controlling required area display
    const controllingElement = document.querySelector('.controlR');
    if (controllingElement) {
        controllingElement.textContent = controllingArea.toFixed(2) + " in²";
        controllingElement.style.color = 'red'; // Highlight the controlling value
    }
    
    return controllingArea;
}

// Select appropriate W shapes based on required area
async function selectWShapes(requiredArea) {
    try {
        // Read W shapes data from Excel file
        const wShapes = await readExcelFile('./ASTMSPEC.xlsx');
        
        if (!wShapes || wShapes.length === 0) {
            console.error("No W shapes data available");
            return;
        }
        
        // Filter shapes that have sufficient area
        const suitableShapes = wShapes.filter(shape => shape.area >= requiredArea);
        
        // Sort by area (most economical first - closest to required area)
        suitableShapes.sort((a, b) => a.area - b.area);
        
        // Take the top 4 shapes or fewer if not enough available
        const recommendedShapes = suitableShapes.slice(0, 4);
        
        // Display recommended shapes
        recommendedShapes.forEach((shape, index) => {
            const rank = index + 1;
            document.getElementById(`rank${rank}`).textContent = rank;
            document.getElementById(`Shape${rank}`).textContent = shape.shape;
            document.getElementById(`AreaG${rank}`).textContent = shape.area.toFixed(2);
            document.getElementById(`CD${rank}`).textContent = (shape.area / requiredArea).toFixed(2);
            document.getElementById(`Weight${rank}`).textContent = shape.weight;
            document.getElementById(`Depth${rank}`).textContent = shape.depth.toFixed(2);
            document.getElementById(`Width${rank}`).textContent = shape.width.toFixed(2);
        });
        
        // Clear any unused rows
        for (let i = recommendedShapes.length + 1; i <= 4; i++) {
            document.getElementById(`rank${i}`).textContent = "";
            document.getElementById(`Shape${i}`).textContent = "";
            document.getElementById(`AreaG${i}`).textContent = "";
            document.getElementById(`CD${i}`).textContent = "";
            document.getElementById(`Weight${i}`).textContent = "";
            document.getElementById(`Depth${i}`).textContent = "";
            document.getElementById(`Width${i}`).textContent = "";
        }
    } catch (error) {
        console.error("Error selecting W shapes:", error);
    }
}

// Main function to run the design
async function designTensionMember() {
    // Get input values
    const designMethod = document.getElementById('designMethod').value;
    const astmSpec = document.getElementById('ASpecD').value;
    const shearLagCase = document.getElementById('ulagCase').value;
    const deadLoad = parseFloat(document.getElementById('Dload').value) || 0;
    const liveLoad = parseFloat(document.getElementById('Lload').value) || 0;
    const length = parseFloat(document.getElementById('LenghtD').value) || 0;
    const dHole = parseFloat(document.getElementById('dholeD').value) || 0;
    const numHoles = parseInt(document.querySelector('.nholeD').value) || 0;
    
    // Default width and depth values (would ideally be determined from the selected shape)
    const width = 6.0; // Default flange width
    const depth = 12.0; // Default section depth
    
    // Calculate required area with the updated parameters
    const requiredArea = calculateRequiredArea(
        deadLoad, 
        liveLoad, 
        designMethod, 
        astmSpec, 
        shearLagCase, 
        length, 
        dHole, 
        numHoles,
        width,
        depth
    );
    
    // Select and display appropriate W shapes
    await selectWShapes(requiredArea);
}

// Add event listener for the design button
document.addEventListener('DOMContentLoaded', function() {
    const designButton = document.getElementById('design');
    if (designButton) {
        designButton.addEventListener('click', function(e) {
            e.preventDefault();
            designTensionMember();
        });
    } else {
        console.error("Design button not found");
    }
});



    </script>
</body>
</html>