<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Principle of Steel  Design</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div class="header"><b>STEEL DESIGN HELPER</b></div>
    </header>
    


    <nav class="navbar">
        <div class="ADcon">
            <a class="con" id="0" href="index.html">|HOME|</a>
            <a class="con" id="1" href="Analysis and Design for Axial Tension.html">|Analysis and Design for Axial Tension|</a>
            <a class="con" id="2" href="Analysis and Design for Axial Compression.html">|Analysis and Design for Axial Compression|</a>
            <a class="con" id="active" class="active" href="Analysis and Design of Members for Bending.html">|Analysis and Design of Members for Bending|</a>
            <a class="con" id="4" href="Shear Strength of Structural Member.html">|Shear Strength of Structural Member|</a>
        </div>
    </nav>

<div class="FINALCONTAINER">
      <div class="AnalysisForBending">
          <div style="display: inline;">
              <h1>ANALYSIS OF BENDING MEMBERS</h1> 
          </div>
          <div class="InputForAnalysisBending">
              <h3></h3>
              <div>
                  <label>SHAPE</label>
                  <input id="Wshape" placeholder="W12x44" type="text">
                  
              </div>
              <div>
                  <label>ASTM Specification</label>
                  <select name="ASTMinput" id="ASTMinput">
                      <option value="A36">A36</option>
                      <option value="A572Gr.42">A572 Gr. 42</option>
                      <option value="A572Gr.50">A572 Gr. 50</option>
                      <option value="A572Gr.55">A572 Gr. 55</option>
                      <option value="A572Gr.60">A572 Gr. 60</option>
                      <option value="A572Gr.65">A572 Gr. 65</option>
                      <option value="A588Gr.42">A588 Gr. 42</option>
                      <option value="A588Gr.46">A588 Gr. 46</option>
                      <option value="A588Gr.50">A588 Gr. 50</option>
                      <option value="A687">A687</option>
                      <option value="A992">A992</option>
                  </select>
              </div>
              <div>
                  <label></label>
              </div>
              <button class="AnalyzeBending" id="AnalyzeBending">Analyze</button>
              
          </div>
          <div class="tableABending">
              <table>
                  <thead id="THB">
                      <tr>
                          <th>DESIGN METHOD</th>
                          <th> Ultimate Moment/ Applied Moment<br>(Mu/Ma)</th>
                      </tr>
                  </thead>
                  <tbody id="TBB">
                      <tr>
                          <td>LRFD</td>
                          <td id="Mu"></td>
                      </tr>
                      <tr>
                          <td>ASD</td>
                          <td id="Ma"></td>

                      </tr>
                  </tbody>
              </table>

          </div>
          <div class="ResultAnalysisBending">
              
          </div>
          
          

      </div>
    <div class="DesignForBending">
        <div style="display: inline;">
            <h1>DESIGN FOR BENDING MEMBERS</h1> 
        </div>

        <div class="InputForBendingDesign">
            <div>
                <label>ASTM Specification</label>
                <select name="ASTMinput" id="ASTMinputD">
                    <option value="A36">A36</option>
                    <option value="A572Gr.42">A572 Gr. 42</option>
                    <option value="A572Gr.50">A572 Gr. 50</option>
                    <option value="A572Gr.55">A572 Gr. 55</option>
                    <option value="A572Gr.60">A572 Gr. 60</option>
                    <option value="A572Gr.65">A572 Gr. 65</option>
                    <option value="A588Gr.42">A588 Gr. 42</option>
                    <option value="A588Gr.46">A588 Gr. 46</option>
                    <option value="A588Gr.50">A588 Gr. 50</option>
                    <option value="A687">A687</option>
                    <option value="A992">A992</option>
                </select>
            </div>
            <div>
                <label>Design Method</label>
                <select id="DesignMethod">
                    <option value="LRFD">LRFD</option>
                    <option value="ASD">ASD</option>
                </select>
            </div>
            <div>
                <label>DeadLoad:</label>
                <input id="DeadLoad" size="10" placeholder="kips">
                <label>Liveload:</label>
                <input  id="LiveLoad" size="10" placeholder="kips">
                <label>Lenght:</label>
                <input id="LenghtDC" size="10" placeholder="ft">
            </div>
            <button id="DesignBending">Design</button>

           
        </div>
        <div id="ResultBendingDesign" class="ResultBendingDesign">

        </div>
        
    </div>
   
</div>

<script>
// Global variables for data storage
let steelSpecs = [];
let sectionData = {};
let beamData = {};  // New variable to store the beam data from sheet 3
let dataLoaded = false;

// Initialize the application when the document is loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log("Initializing Bending Analysis application");
    
    // Set up event listeners
    setupEventListeners();
    
    // Try to load the data from Excel file
    loadExcelData()
        .then(() => {
            console.log("Excel data loaded successfully");
            dataLoaded = true;
            updateShapeOptions();
            updateSteelOptions();
        })
        .catch(error => {
            console.warn("Failed to load Excel data:", error);
            console.log("Using hardcoded data instead");
            useHardcodedData();
            dataLoaded = true;
            updateShapeOptions();
            updateSteelOptions();
        });
});

// Function to set up event listeners
function setupEventListeners() {
    // Add event listener to Analyze button
    const analyzeButton = document.querySelector('button.AnalyzeBending');
    if (analyzeButton) {
        analyzeButton.addEventListener('click', analyzeBending);
        console.log("Analyze button listener attached");
    } else {
        console.error("Analyze button not found");
    }
    
    // Add event listener for W-shape input to validate and auto-complete
    const wShapeInput = document.getElementById('Wshape');
    if (wShapeInput) {
        wShapeInput.addEventListener('input', function() {
            this.value = this.value.toUpperCase();
        });
    }
}

// Modified function to load Excel data using fetch API
async function loadExcelData() {
    try {
        console.log("Attempting to load Excel data...");
        
        // Use fetch API to load the Excel file as a blob
        const response = await fetch('ASTMSPEC.xlsx', {
            method: 'GET',
            mode: 'cors', // Try with cors mode
            cache: 'no-cache'
        });
        
        if (!response.ok) {
            throw new Error(`Failed to fetch Excel file: ${response.status}`);
        }
        
        // Get the file as an ArrayBuffer
        const arrayBuffer = await response.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // Parse with SheetJS
        const workbook = XLSX.read(data, { type: 'array' });
        
        // Load steel specifications from the first sheet
        const steelSheet = workbook.Sheets[workbook.SheetNames[0]];
        const rawSteelSpecs = XLSX.utils.sheet_to_json(steelSheet);
        
        // Validate steel specs data
        steelSpecs = rawSteelSpecs.filter(spec => 
            spec.Steel_name && 
            typeof spec.Fy === 'number' && 
            typeof spec.Fu === 'number'
        );
        
        if (steelSpecs.length === 0) {
            console.error("No valid steel specifications found in the Excel file");
            console.log("Raw steel specs data:", rawSteelSpecs);
            useHardcodedData();
        } else {
            console.log(`Successfully loaded ${steelSpecs.length} steel specifications`);
            steelSpecs.slice(0, 5).forEach(spec => 
                console.log(`Steel: ${spec.Steel_name}, Fy: ${spec.Fy}, Fu: ${spec.Fu}`)
            );
        }
        
        // Load section data from the second sheet
        const sectionSheet = workbook.Sheets[workbook.SheetNames[1]];
        const sectionsArray = XLSX.utils.sheet_to_json(sectionSheet);
        
        // Convert array to object with section names as keys
        sectionData = {};
        sectionsArray.forEach(section => {
            if (section.AISC_Manual_Label) {
                sectionData[section.AISC_Manual_Label] = section;
            }
        });
        
        console.log(`Loaded ${Object.keys(sectionData).length} sections`);
        
        // Update UI with loaded data
        updateShapeOptions();
        updateSteelOptions();
        
        return true;
    } catch (error) {
        console.error("Error loading Excel data:", error);
        // Use hardcoded data as fallback
        useHardcodedData();
        
        // Update UI with fallback data
        updateShapeOptions();
        updateSteelOptions();
        
        return false;
    }
}


// Modify useHardcodedData to ensure data is accessible in all scopes
function useHardcodedData() {
    // Default steel specifications
    const hardcodedSteelSpecs = [
        { Steel_name: "A36", Fy: 36, Fu: 58 },
        { Steel_name: "A572Gr.42", Fy: 42, Fu: 60 },
        { Steel_name: "A572Gr.50", Fy: 50, Fu: 65 },
        { Steel_name: "A572Gr.55", Fy: 55, Fu: 70 },
        { Steel_name: "A572Gr.60", Fy: 60, Fu: 75 },
        { Steel_name: "A572Gr.65", Fy: 65, Fu: 80 },
        { Steel_name: "A588Gr.42", Fy: 42, Fu: 63 },
        { Steel_name: "A588Gr.46", Fy: 46, Fu: 67 },
        { Steel_name: "A588Gr.50", Fy: 50, Fu: 70 },
        { Steel_name: "A687", Fy: 50, Fu: 70 },
        { Steel_name: "A992", Fy: 50, Fu: 65 }
    ];
    
    // Common W shapes with their properties
    const hardcodedSectionData = {
        "W12X45": { 
            A: 13.2, tw: 0.335, d: 12.1, bf: 8.05, Zx: 88.6, Sx: 78.0, 
            "bf/2tf": 8.5, "h/tw": 29.9, Kc: 0.707, AISC_Manual_Label: "W12X45" 
        },
        "W10X33": { 
            A: 9.71, tw: 0.29, d: 9.73, bf: 5.77, Zx: 42.1, Sx: 36.6, 
            "bf/2tf": 9.15, "h/tw": 27.9, Kc: 0.707, AISC_Manual_Label: "W10X33" 
        },
        "W8X24": { 
            A: 7.08, tw: 0.25, d: 7.93, bf: 6.5, Zx: 23.2, Sx: 20.9, 
            "bf/2tf": 10.8, "h/tw": 26.0, Kc: 0.707, AISC_Manual_Label: "W8X24" 
        },
        "W14X53": {
            A: 15.6, tw: 0.37, d: 13.9, bf: 8.06, Zx: 115, Sx: 102, 
            "bf/2tf": 7.33, "h/tw": 32.3, Kc: 0.760, AISC_Manual_Label: "W14X53"
        },
        "W16X40": {
            A: 11.8, tw: 0.305, d: 16.0, bf: 7.0, Zx: 92.0, Sx: 81.0, 
            "bf/2tf": 9.2, "h/tw": 46.2, Kc: 0.738, AISC_Manual_Label: "W16X40"
        },
        "W18X35": {
            A: 10.3, tw: 0.30, d: 17.7, bf: 6.0, Zx: 83.3, Sx: 72.7, 
            "bf/2tf": 7.5, "h/tw": 53.0, Kc: 0.724, AISC_Manual_Label: "W18X35"
        },
        "W21X44": {
            A: 13.0, tw: 0.35, d: 20.7, bf: 6.5, Zx: 126, Sx: 110, 
            "bf/2tf": 6.8, "h/tw": 54.0, Kc: 0.714, AISC_Manual_Label: "W21X44"
        },
        "W24X55": {
            A: 16.2, tw: 0.395, d: 23.6, bf: 7.0, Zx: 177, Sx: 154, 
            "bf/2tf": 7.2, "h/tw": 54.6, Kc: 0.701, AISC_Manual_Label: "W24X55"
        }
    };
    
    // Set the data in both global and window scopes to ensure access
    window.steelSpecs = hardcodedSteelSpecs;
    window.sectionData = hardcodedSectionData;
    steelSpecs = hardcodedSteelSpecs;
    sectionData = hardcodedSectionData;
    
    console.log("Using hardcoded data with", Object.keys(hardcodedSectionData).length, "sections");
}

// Function to update the shape selection options based on loaded data
function updateShapeOptions() {
    const wShapeInput = document.getElementById('Wshape');
    if (!wShapeInput) {
        console.error("Missing 'Wshape' input element");
        return;
    }
    
    // Create a datalist for W shapes
    let datalist = document.getElementById('shape-options');
    if (!datalist) {
        datalist = document.createElement('datalist');
        datalist.id = 'shape-options';
        document.body.appendChild(datalist);
        
        // Connect the input to the datalist
        wShapeInput.setAttribute('list', 'shape-options');
    }
    
    // Clear and populate datalist
    datalist.innerHTML = '';
    
    Object.keys(sectionData).forEach(key => {
        const option = document.createElement('option');
        option.value = key;
        datalist.appendChild(option);
    });
}

// Function to update steel specification options
function updateSteelOptions() {
    const steelSelect = document.getElementById('ASTMinput');
    if (!steelSelect) {
        console.error("Missing 'ASTMinput' select element");
        return;
    }
    
    // Store the currently selected value before clearing
    const currentSelection = steelSelect.value;
    
    // Clear existing options
    steelSelect.innerHTML = '';
    
    // Add new options
    if (steelSpecs && steelSpecs.length > 0) {
        console.log("Adding steel specs:", steelSpecs.length);
        
        steelSpecs.forEach((spec, index) => {
            if (spec.Steel_name) {
                const option = document.createElement('option');
                const steelValue = spec.Steel_name.replace(/\s/g, '');
                option.value = steelValue;
                option.textContent = spec.Steel_name;
                steelSelect.appendChild(option);
                
                // Debug
                console.log(`Added steel option: ${steelValue} (${spec.Fy}, ${spec.Fu})`);
            }
        });
        
        // Restore the previous selection if it exists in the new options
        if (currentSelection) {
            // Check if the option exists in the new list
            for (let i = 0; i < steelSelect.options.length; i++) {
                if (steelSelect.options[i].value === currentSelection) {
                    steelSelect.value = currentSelection;
                    break;
                }
            }
        }
    } else {
        console.warn("No steel specifications found, using defaults");
        
        // If no specs were added, add defaults
        const defaults = [
            { value: "A36", text: "A36" },
            { value: "A572Gr.50", text: "A572 Gr. 50" },
            { value: "A992", text: "A992" }
        ];
        
        defaults.forEach(def => {
            const option = document.createElement('option');
            option.value = def.value;
            option.textContent = def.text;
            steelSelect.appendChild(option);
        });
    }
}

// Function to load data from Excel file using SheetJS
async function loadExcelData() {
    try {
        // Try to fetch the Excel file
        const response = await fetch('ASTMSPEC.xlsx');
        if (!response.ok) {
            throw new Error(`Failed to fetch Excel file: ${response.status}`);
        }
        
        const arrayBuffer = await response.arrayBuffer();
        const data = new Uint8Array(arrayBuffer);
        
        // Parse the Excel file using SheetJS
        const workbook = XLSX.read(data, { type: 'array' });
        
        // Load steel specifications from the first sheet
        const steelSheet = workbook.Sheets[workbook.SheetNames[0]];
        const rawSteelSpecs = XLSX.utils.sheet_to_json(steelSheet);
        
        // Validate and clean the steel specs data
        steelSpecs = rawSteelSpecs.filter(spec => 
            spec.Steel_name && 
            typeof spec.Fy === 'number' && 
            typeof spec.Fu === 'number'
        );
        
        if (steelSpecs.length === 0) {
            console.error("No valid steel specifications found in the Excel file");
            // Log the raw data to help debug
            console.log("Raw steel specs data:", rawSteelSpecs);
            useHardcodedData();
        } else {
            console.log(`Successfully loaded ${steelSpecs.length} steel specifications`);
            // Log the first few entries to help debug
            steelSpecs.slice(0, 5).forEach(spec => 
                console.log(`Steel: ${spec.Steel_name}, Fy: ${spec.Fy}, Fu: ${spec.Fu}`)
            );
        }
        
        // Load section data from the second sheet
        const sectionSheet = workbook.Sheets[workbook.SheetNames[1]];
        const sectionsArray = XLSX.utils.sheet_to_json(sectionSheet);
        
        // Convert array to object with section names as keys
        sectionData = {};
        sectionsArray.forEach(section => {
            if (section.AISC_Manual_Label) {
                sectionData[section.AISC_Manual_Label] = section;
            }
        });
        
        console.log(`Loaded ${steelSpecs.length} steel specifications and ${Object.keys(sectionData).length} sections`);
        
        // Update UI with the loaded data
        updateShapeOptions();
        updateSteelOptions();
        
        return true;
        
    } catch (error) {
        console.error("Error loading Excel data:", error);
        // Use hardcoded data as fallback
        useHardcodedData();
        
        // Update UI with fallback data
        updateShapeOptions();
        updateSteelOptions();
        
        throw error;
    }
}


function initialize() {
    console.log("Initializing application...");
    
    // Initialize data structures using only local variables
    dataLoaded = false;
    steelSpecs = [];
    sectionData = {};
    beamData = {};  // Initialize beam data
    
    // Add SheetJS library
    addExcelLibrary()
        .then(() => {
            // Once SheetJS is loaded, try to load Excel data
            return loadExcelData();
        })
        .then((success) => {
            dataLoaded = true;
            console.log("Data loading complete, success:", success);
            
            if (success) {
                showNotification('success', 'Data loaded successfully!');
            } else {
                showNotification('warning', 'Using default values, Excel data could not be loaded.');
            }
        })
        .catch(err => {
            dataLoaded = true; // Still mark as loaded since we use fallback data
            console.error("Setup error:", err);
            showNotification('error', 'Error in setup. Using default values.');
            
            // Ensure we still have data to work with
            useHardcodedData();
            updateShapeOptions();
            updateSteelOptions();
        });
    
    // Set up event listeners
    setupEventListeners();
}
// Start initialization when DOM is fully loaded
document.addEventListener('DOMContentLoaded', initialize);

// Helper function to ensure an element exists
function ensureElementExists(id, tagName, parent) {
    let element = document.getElementById(id);
    if (!element) {
        element = document.createElement(tagName);
        element.id = id;
        parent.appendChild(element);
    }
    return element;
}


    
// Modified analyzeBending function to fix data access issues
function analyzeBending() {
    console.log("Analyze button clicked");
    
    // Create error message and results container elements if they don't exist
    const errorMessage = ensureElementExists('errorMessage', 'div', document.querySelector('.ResultAnalysisBending') || document.body);
    errorMessage.style.color = 'red';
    errorMessage.style.marginTop = '10px';
    
    const resultsContainer = ensureElementExists('resultsContainer', 'div', document.querySelector('.ResultAnalysisBending') || document.body);
    
    const wShapeInput = document.getElementById('Wshape');
    const steelSelect = document.getElementById('ASTMinput');
    
    if (!wShapeInput || !steelSelect) {
        errorMessage.textContent = 'Required input elements not found';
        return;
    }
    
    const wShape = wShapeInput.value;
    const selectedASTM = steelSelect.value;
    
    // Clear previous results and errors
    errorMessage.textContent = '';
    resultsContainer.innerHTML = '';
    
    // Clear previous table results
    const muElement = document.getElementById('Mu');
    const maElement = document.getElementById('Ma');
    if (muElement) muElement.textContent = '';
    if (maElement) maElement.textContent = '';
    
    if (!wShape) {
        errorMessage.textContent = 'Please enter a W-shape';
        return;
    }
    
    // Check if data is loaded
    if (!dataLoaded) {
        errorMessage.textContent = 'Data is still loading. Please wait...';
        return;
    }
    
    // Find section properties
    const formattedWShape = wShape.trim().toUpperCase().replace(/\s/g, '');
    console.log("Looking for section:", formattedWShape);
    console.log("Available sections:", Object.keys(sectionData).length);
    
    const section = sectionData[formattedWShape];
    
    if (!section) {
        errorMessage.textContent = `Section ${wShape} not found in database`;
        return;
    }
    
    console.log("Section found:", section);
    
    // Find steel properties
    console.log("Selected ASTM:", selectedASTM);
    console.log("Available steel specs:", steelSpecs.map(s => s.Steel_name));
    
    // Find steel properties with more flexible matching
    const steel = steelSpecs.find(item => {
        if (!item.Steel_name) return false;
        
        // Try different matching methods
        const cleanSelectedASTM = selectedASTM.replace(/\s/g, '').toUpperCase();
        const cleanItemName = item.Steel_name.replace(/\s/g, '').toUpperCase();
        
        return cleanItemName === cleanSelectedASTM;
    });
    
    // If not found with flexible matching, fallback to hardcoded values for common types
    let Fy, Fu;
    
    if (steel) {
        console.log("Steel found:", steel);
        Fy = steel.Fy;
        Fu = steel.Fu;
    } else {
        console.warn(`Steel specification ${selectedASTM} not found, using fallback values`);
        
        // Fallback values for common steel types
        if (selectedASTM.includes('A36')) {
            Fy = 36;
            Fu = 58;
        } else if (selectedASTM.includes('A572') && selectedASTM.includes('50')) {
            Fy = 50;
            Fu = 65;
        } else if (selectedASTM.includes('A992')) {
            Fy = 50;
            Fu = 65;
        } else {
            // Default values if no match
            errorMessage.textContent = `Steel specification ${selectedASTM} not found in database`;
            return;
        }
    }
    
    console.log(`Using steel properties: Fy = ${Fy}, Fu = ${Fu}`);
    
    // Rest of the function remains the same...
    // Extract required values
    const bf_2tf = section["bf/2tf"]; // Flange slenderness ratio
    const h_tw = section["h/tw"];    // Web slenderness ratio
    const Zx = section.Zx;         // Plastic section modulus
    const Sx = section.Sx;         // Elastic section modulus
    const Kc = section.Kc || 0.707; // Web coefficient (default to 0.707 if not provided)
    
    // Check section classification
    // Compact section limits for flanges and web (AISC Table B4.1b)
    const lambdaPf = 0.38 * Math.sqrt(29000 / Fy); // Flange
    const lambdaPw = 3.76 * Math.sqrt(29000 / Fy); // Web
    
    // Non-compact section limits
    const lambdaRf = 1.0 * Math.sqrt(29000 / Fy);  // Flange
    const lambdaRw = 5.70 * Math.sqrt(29000 / Fy); // Web
    
    let sectionClass = "";
    let flangeClass = "";
    let webClass = "";
    
    // Determine flange classification
    if (bf_2tf <= lambdaPf) {
        flangeClass = "Compact";
    } else if (bf_2tf <= lambdaRf) {
        flangeClass = "Non-compact";
    } else {
        flangeClass = "Slender";
    }
    
    // Determine web classification
    if (h_tw <= lambdaPw) {
        webClass = "Compact";
    } else if (h_tw <= lambdaRw) {
        webClass = "Non-compact";
    } else {
        webClass = "Slender";
    }
    
    // Overall section classification (controls)
    if (flangeClass === "Slender" || webClass === "Slender") {
        sectionClass = "Slender";
    } else if (flangeClass === "Non-compact" || webClass === "Non-compact") {
        sectionClass = "Non-compact";
    } else {
        sectionClass = "Compact";
    }
    
    // Calculate nominal moment capacity (Mn)
    let Mn = 0;
    
    // For compact sections
    if (sectionClass === "Compact") {
        // Plastic moment capacity
        Mn = Zx * Fy;
    }
    // For non-compact sections
    else if (sectionClass === "Non-compact") {
        // Interpolate between plastic moment and yield moment
        if (flangeClass === "Non-compact") {
            const Mp = Zx * Fy;
            const My = Sx * Fy;
            Mn = Mp - (Mp - My) * ((bf_2tf - lambdaPf) / (lambdaRf - lambdaPf));
        } else {
            const Mp = Zx * Fy;
            const My = Sx * Fy;
            Mn = Mp - (Mp - My) * ((h_tw - lambdaPw) / (lambdaRw - lambdaPw));
        }
    }
    // For slender sections
    else {
        // Conservative approach - yield moment
        Mn = Sx * Fy;
    }
    
    // Convert to kip-ft (from kip-in)
    Mn = Mn / 12;
    
    // Calculate design strengths
    const phi = 0.9; // LRFD resistance factor for flexure
    const omega = 1.67; // ASD safety factor for flexure
    const LRFDMoment = phi * Mn;
    const ASDMoment = Mn / omega;
    
    console.log("Analysis complete, displaying results");
    
    // Update table results
    if (muElement) muElement.textContent = LRFDMoment.toFixed(2) + " kip-ft";
    if (maElement) maElement.textContent = ASDMoment.toFixed(2) + " kip-ft";
    
    // Create results object
    const results = {
        section: wShape,
        steelSpec: selectedASTM,
        Fy,
        Fu,
        flangeRatio: bf_2tf,
        webRatio: h_tw,
        flangeClass,
        webClass,
        sectionClass,
        Zx,
        Sx,
        Mn,
        LRFDMoment,
        ASDMoment
    };
    
    // Display detailed results
    displayResults(results);
    
    // Show success notification
    showNotification('success', 'Analysis completed successfully!');
}

// Function to display the results
function displayResults(results) {
    const resultsContainer = document.getElementById('resultsContainer');
    if (!resultsContainer) {
        console.error("Missing 'resultsContainer' element");
        return;
    }
    
    // Create detailed results HTML
    let html = `
        <div class="results-container" style="margin-top: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 5px;">
            <h3 style="margin-top: 0;">Analysis Results</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <p><strong>Section:</strong> ${results.section}</p>
                    <p><strong>Steel Specification:</strong> ${results.steelSpec}</p>
                    <p><strong>Yield Strength (Fy):</strong> ${results.Fy} ksi</p>
                    <p><strong>Ultimate Strength (Fu):</strong> ${results.Fu} ksi</p>
                    <p><strong>Section Classification:</strong> ${results.sectionClass}</p>
                </div>
                <div>
                    <p><strong>Flange Ratio (bf/2tf):</strong> ${results.flangeRatio.toFixed(2)}</p>
                    <p><strong>Flange Classification:</strong> ${results.flangeClass}</p>
                    <p><strong>Web Ratio (h/tw):</strong> ${results.webRatio.toFixed(2)}</p>
                    <p><strong>Web Classification:</strong> ${results.webClass}</p>
                    <p><strong>Nominal Moment (Mn):</strong> ${results.Mn.toFixed(2)} kip-ft</p>
                </div>
            </div>
            
            <div style="margin-top: 20px;">
                <h4>Design Strength</h4>
                <p><strong>LRFD Design Strength (φMn):</strong> ${results.LRFDMoment.toFixed(2)} kip-ft &nbsp; (φ = 0.9)</p>
                <p><strong>ASD Design Strength (Mn/Ω):</strong> ${results.ASDMoment.toFixed(2)} kip-ft &nbsp; (Ω = 1.67)</p>
            </div>
            
            <div style="margin-top: 20px;">
                <h4>AISC Classification Limits</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr 2fr; gap: 10px; margin-top: 10px;">
                    <div style="font-weight: bold;">Element</div>
                    <div style="font-weight: bold;">Actual Ratio</div>
                    <div style="font-weight: bold;">Limit Ratios</div>
                    
                    <div>Flange (bf/2tf)</div>
                    <div>${results.flangeRatio.toFixed(2)}</div>
                    <div>
                        λp = ${(0.38 * Math.sqrt(29000 / results.Fy)).toFixed(2)}, 
                        λr = ${(1.0 * Math.sqrt(29000 / results.Fy)).toFixed(2)}
                    </div>
                    
                    <div>Web (h/tw)</div>
                    <div>${results.webRatio.toFixed(2)}</div>
                    <div>
                        λp = ${(3.76 * Math.sqrt(29000 / results.Fy)).toFixed(2)}, 
                        λr = ${(5.70 * Math.sqrt(29000 / results.Fy)).toFixed(2)}
                    </div>
                </div>
            </div>
        </div>
    `;
    
    resultsContainer.innerHTML = html;
}

// Function to show notifications
function showNotification(type, message) {
    // Create notification element if it doesn't exist
    let notificationElement = document.getElementById('notification');
    if (!notificationElement) {
        notificationElement = document.createElement('div');
        notificationElement.id = 'notification';
        notificationElement.style.position = 'fixed';
        notificationElement.style.top = '20px';
        notificationElement.style.right = '20px';
        notificationElement.style.padding = '15px 20px';
        notificationElement.style.borderRadius = '5px';
        notificationElement.style.zIndex = '1000';
        notificationElement.style.transition = 'opacity 0.3s ease';
        document.body.appendChild(notificationElement);
    }
    
    // Set notification content and style
    notificationElement.className = `notification notification-${type}`;
    notificationElement.textContent = message;
    
    if (type === 'success') {
        notificationElement.style.backgroundColor = '#4CAF50';
        notificationElement.style.color = 'white';
    } else if (type === 'error') {
        notificationElement.style.backgroundColor = '#f44336';
        notificationElement.style.color = 'white';
    } else {
        notificationElement.style.backgroundColor = '#2196F3';
        notificationElement.style.color = 'white';
    }
    
    notificationElement.style.display = 'block';
    notificationElement.style.opacity = '1';
    
    // Auto-hide after 3 seconds
    setTimeout(() => {
        notificationElement.style.opacity = '0';
        setTimeout(() => {
            notificationElement.style.display = 'none';
        }, 300);
    }, 3000);
}

// Function to add Excel library to the page
function addExcelLibrary() {
    return new Promise((resolve, reject) => {
        // Check if SheetJS is already loaded
        if (window.XLSX) {
            console.log("SheetJS already loaded");
            resolve();
            return;
        }
        
        console.log("Loading SheetJS...");
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js';
        script.onload = () => {
            console.log("SheetJS loaded successfully");
            resolve();
        };
        script.onerror = () => {
            console.error("Failed to load SheetJS");
            reject(new Error("Failed to load SheetJS library"));
        };
        document.head.appendChild(script);
    });
}
// Add necessary CSS
function addStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .notification {
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .notification-success {
            background-color: #4CAF50;
            color: white;
        }
        .notification-error {
            background-color: #f44336;
            color: white;
        }
        .results-container {
            background-color: #f9f9f9;
        }
        .tableABending table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .tableABending th, .tableABending td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .tableABending th {
            background-color: #f2f2f2;
        }
        .InputForAnalysisBending {
            margin-bottom: 20px;
        }
        .InputForAnalysisBending div {
            margin-bottom: 10px;
        }
        .InputForAnalysisBending label {
            display: inline-block;
            width: 150px;
        }
        .InputForAnalysisBending input, .InputForAnalysisBending select {
            padding: 5px;
            width: 200px;
        }
        button.AnalyzeBending {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button.AnalyzeBending:hover {
            background-color: #45a049;
        }
    `;
    document.head.appendChild(styleElement);
}

// Load SheetJS and add styles when the page loads
addExcelLibrary()
    .then(() => {
        console.log("SheetJS library loaded");
    })
    .catch(error => {
        console.error("Failed to load SheetJS library:", error);
    });

addStyles();


// Add event listener to Design button
document.addEventListener('DOMContentLoaded', function() {
    const designButton = document.getElementById('DesignBending');
    if (designButton) {
        designButton.addEventListener('click', designBendingMember);
        console.log("Design button listener attached");
    } else {
        console.error("Design button not found");
    }
});

// Main function to design a bending member
function designBendingMember() {
    console.log("Starting bending member design...");
    
    // Get input values
    const deadLoad = parseFloat(document.getElementById('DeadLoad').value);
    const liveLoad = parseFloat(document.getElementById('LiveLoad').value);
    const length = parseFloat(document.getElementById('LenghtDC').value);
    const designMethod = document.getElementById('DesignMethod').value;
    const steelType = document.getElementById('ASTMinputD').value;
    
    // Validate inputs
    if (isNaN(deadLoad) || isNaN(liveLoad) || isNaN(length) || length <= 0) {
        document.getElementById('ResultBendingDesign').innerHTML = 
            '<p class="error">Please enter valid values for all inputs.</p>';
        return;
    }
    
    // Find the selected steel specification
    const selectedSteel = findSteelSpec(steelType);
    if (!selectedSteel) {
        document.getElementById('ResultBendingDesign').innerHTML = 
            '<p class="error">Selected steel specification not found.</p>';
        return;
    }
    
    // Initialize results output
    let resultsHTML = '<h2>Bending Member Design Results</h2>';
    resultsHTML += `<p><strong>Design Method:</strong> ${designMethod}</p>`;
    resultsHTML += `<p><strong>Steel:</strong> ${selectedSteel.Steel_name} (Fy = ${selectedSteel.Fy} ksi, Fu = ${selectedSteel.Fu} ksi)</p>`;
    resultsHTML += `<p><strong>Loads:</strong> Dead Load = ${deadLoad} kips, Live Load = ${liveLoad} kips, Length = ${length} ft</p>`;
    
    // Step 1: Calculate total factored load based on design method
    let totalLoad;
    if (designMethod === 'LRFD') {
        totalLoad = 1.2 * deadLoad + 1.6 * liveLoad;
        resultsHTML += `<p><strong>Load Combination (LRFD):</strong> 1.2D + 1.6L = 1.2 × ${deadLoad} + 1.6 × ${liveLoad} = ${totalLoad.toFixed(2)} kips</p>`;
    } else { // ASD
        totalLoad = deadLoad + liveLoad;
        resultsHTML += `<p><strong>Load Combination (ASD):</strong> D + L = ${deadLoad} + ${liveLoad} = ${totalLoad.toFixed(2)} kips</p>`;
    }
    
    // Step 2: Calculate initial moment (without beam weight)
    const initialMoment = (totalLoad * length * length) / 8;
    resultsHTML += `<p><strong>Initial Moment:</strong> M = WL²/8 = ${totalLoad.toFixed(2)} × ${length}² / 8 = ${initialMoment.toFixed(2)} kip-ft</p>`;
    
    // Step 3: Calculate required plastic section modulus (Zx)
    let requiredZx;
    if (designMethod === 'LRFD') {
        requiredZx = (initialMoment * 12) / (0.9 * selectedSteel.Fy);
        resultsHTML += `<p><strong>Required Zx (LRFD):</strong> Zx = Mu×12/(ΦbFy) = ${initialMoment.toFixed(2)}×12/(0.9×${selectedSteel.Fy}) = ${requiredZx.toFixed(2)} in³</p>`;
    } else { // ASD
        requiredZx = (initialMoment * 12) / (0.6 * selectedSteel.Fy);
        resultsHTML += `<p><strong>Required Zx (ASD):</strong> Zx = M×12/(0.6×Fy) = ${initialMoment.toFixed(2)}×12/(0.6×${selectedSteel.Fy}) = ${requiredZx.toFixed(2)} in³</p>`;
    }
    
    // Step 4: Find suitable beam sections
    const suitableBeams = findSuitableBeams(requiredZx);
    if (suitableBeams.length === 0) {
        resultsHTML += `<p class="error">No suitable beams found for the required Zx = ${requiredZx.toFixed(2)} in³.</p>`;
        document.getElementById('ResultBendingDesign').innerHTML = resultsHTML;
        return;
    }
    
    resultsHTML += `<p><strong>Initial Selection:</strong> Finding beams with Zx ≥ ${requiredZx.toFixed(2)} in³</p>`;
    
    // Step 5: Calculate required moment of inertia for deflection control
    // Calculate uniform load per length
    const uniformLoad = totalLoad / length; // kips/ft
    
    // Calculate required Ix for deflection limit L/360
    const deflectionLimit = (length * 12) / 360; // in
    const E = 29000; // ksi
    const requiredIx = (5 * uniformLoad * Math.pow(length * 12, 3)) / (384 * E * deflectionLimit);
    
    resultsHTML += `<p><strong>Deflection Control:</strong> Required Ix for L/360 = ${requiredIx.toFixed(2)} in⁴</p>`;
    
    // Step 5: Detailed design check for each suitable beam
    resultsHTML += '<h3>Detailed Design Checks</h3>';
    
    // Array to store valid beams after checking
    const validBeams = [];
    
    // Check each beam
    for (let i = 0; i < Math.min(5, suitableBeams.length); i++) {
        const beam = suitableBeams[i];
        resultsHTML += `<div class="beam-check">`;
        resultsHTML += `<h4>Check for ${beam.AISC_Manual_Label}</h4>`;
        
        // Calculate beam weight and add to total load
        // Get beam weight from sectionData and convert to kips
        const beamWeight = beam.W / 1000; // Convert from lb/ft to kip/ft
        const beamWeightTotal = beamWeight * length; // Total beam weight in kips
        
        // Recalculate total load with beam weight
        let totalLoadWithBeam;
        if (designMethod === 'LRFD') {
            totalLoadWithBeam = 1.2 * (deadLoad + beamWeightTotal) + 1.6 * liveLoad;
            resultsHTML += `<p>Load with beam weight (LRFD): 1.2(${deadLoad} + ${beamWeightTotal.toFixed(3)}) + 1.6(${liveLoad}) = ${totalLoadWithBeam.toFixed(2)} kips</p>`;
        } else { // ASD
            totalLoadWithBeam = deadLoad + beamWeightTotal + liveLoad;
            resultsHTML += `<p>Load with beam weight (ASD): ${deadLoad} + ${beamWeightTotal.toFixed(3)} + ${liveLoad} = ${totalLoadWithBeam.toFixed(2)} kips</p>`;
        }
        
        // Calculate moment with beam weight
        const momentWithBeam = (totalLoadWithBeam * length * length) / 8;
        resultsHTML += `<p>Moment with beam weight: M = WL²/8 = ${totalLoadWithBeam.toFixed(2)} × ${length}² / 8 = ${momentWithBeam.toFixed(2)} kip-ft</p>`;
        
        // Check if section is compact, non-compact, or slender
        const flangeBF2TF = beam["bf/2tf"];
        const webHW = beam["h/tw"];
        
        // Calculate limiting width-thickness ratios for the flange
        const lambdaPF = 0.38 * Math.sqrt(29000 / selectedSteel.Fy);
        const lambdaRF = 1.0 * Math.sqrt(29000 / selectedSteel.Fy);
        
        // Calculate limiting width-thickness ratios for the web
        const lambdaPW = 3.76 * Math.sqrt(29000 / selectedSteel.Fy);
        const lambdaRW = 5.70 * Math.sqrt(29000 / selectedSteel.Fy);
        
        // Determine section classification
        let sectionType = "";
        let momentCapacity = 0;
        
        if (flangeBF2TF <= lambdaPF && webHW <= lambdaPW) {
            sectionType = "Compact";
            // For compact sections Mp = Fy * Zx
            if (designMethod === 'LRFD') {
                momentCapacity = 0.9 * selectedSteel.Fy * beam.Zx / 12; // Convert to kip-ft
            } else { // ASD
                momentCapacity = 0.6 * selectedSteel.Fy * beam.Zx / 12; // Convert to kip-ft
            }
        } else if (flangeBF2TF <= lambdaRF && webHW <= lambdaRW) {
            sectionType = "Non-compact";
            // For non-compact sections, linear interpolation between Mp and Mr
            // This is a simplified approach - in practice, would need more detailed calculations
            const Mp = selectedSteel.Fy * beam.Zx;
            const Mr = selectedSteel.Fy * beam.Sx;
            
            const flangeRatio = (flangeBF2TF - lambdaPF) / (lambdaRF - lambdaPF);
            const webRatio = (webHW - lambdaPW) / (lambdaRW - lambdaPW);
            const worstRatio = Math.max(flangeRatio, webRatio);
            
            const Mn = Mp - worstRatio * (Mp - Mr);
            
            if (designMethod === 'LRFD') {
                momentCapacity = 0.9 * Mn / 12; // Convert to kip-ft
            } else { // ASD
                momentCapacity = 0.6 * Mn / 12; // Convert to kip-ft
            }
        } else {
            sectionType = "Slender";
            // For slender sections, would need more complex calculations
            // Using a conservative estimate of 0.9 * Mr for this example
            if (designMethod === 'LRFD') {
                momentCapacity = 0.9 * 0.9 * selectedSteel.Fy * beam.Sx / 12; // Convert to kip-ft
            } else { // ASD
                momentCapacity = 0.6 * 0.9 * selectedSteel.Fy * beam.Sx / 12; // Convert to kip-ft
            }
        }
        
        resultsHTML += `<p>Section Classification: <strong>${sectionType}</strong></p>`;
        resultsHTML += `<p>Flange b/2tf = ${flangeBF2TF.toFixed(2)}, λp = ${lambdaPF.toFixed(2)}, λr = ${lambdaRF.toFixed(2)}</p>`;
        resultsHTML += `<p>Web h/tw = ${webHW.toFixed(2)}, λp = ${lambdaPW.toFixed(2)}, λr = ${lambdaRW.toFixed(2)}</p>`;
        
        // Calculate capacity
        resultsHTML += `<p>Moment Capacity: ${momentCapacity.toFixed(2)} kip-ft</p>`;
        
        // Check if moment capacity is adequate
        const isAdequate = momentWithBeam <= momentCapacity;
        if (isAdequate) {
            resultsHTML += `<p class="success"><strong>SAFE:</strong> Demand (${momentWithBeam.toFixed(2)} kip-ft) < Capacity (${momentCapacity.toFixed(2)} kip-ft). The section ${beam.AISC_Manual_Label} is adequate.</p>`;
        } else {
            resultsHTML += `<p class="error"><strong>UNSAFE:</strong> Demand (${momentWithBeam.toFixed(2)} kip-ft) > Capacity (${momentCapacity.toFixed(2)} kip-ft). The section ${beam.AISC_Manual_Label} is NOT adequate.</p>`;
        }
        
        // Calculate and check deflection
        const w = totalLoadWithBeam / length; // kips/ft
        const actualIx = beam.Ix; // in^4
        const actualDeflection = (5 * w * Math.pow(length * 12, 3)) / (384 * E * actualIx); // inches
        const serviceabilityLimit = (length * 12) / 360; // L/360 is common serviceability limit
        
        resultsHTML += `<p><strong>Deflection Check:</strong></p>`;
        resultsHTML += `<p>Allowable Deflection = L/360 = (${length * 12}) / 360 = ${serviceabilityLimit.toFixed(3)} in</p>`;
        resultsHTML += `<p>Required Ix = (5 * w * L³) / (384 * E * Δallowable) = ${requiredIx.toFixed(2)} in⁴</p>`;
        resultsHTML += `<p>Actual Ix for ${beam.AISC_Manual_Label} = ${actualIx.toFixed(2)} in⁴</p>`;
        
        const isDeflectionOK = actualIx >= requiredIx;
        if (isDeflectionOK) {
            resultsHTML += `<p class="success"><strong>DEFLECTION OK:</strong> Available Ix (${actualIx.toFixed(2)} in⁴) ≥ Required Ix (${requiredIx.toFixed(2)} in⁴)</p>`;
           
        } else {
            resultsHTML += `<p class="warning"><strong>EXCESSIVE DEFLECTION:</strong> Available Ix (${actualIx.toFixed(2)} in⁴) < Required Ix (${requiredIx.toFixed(2)} in⁴)</p>`;
            
        }
        
        if (isAdequate && isDeflectionOK) {
            validBeams.push({
                shape: beam.AISC_Manual_Label,
                capacity: momentCapacity,
                demand: momentWithBeam,
                actualIx: actualIx,
                requiredIx: requiredIx,
                deflection: actualDeflection
            });
        }
        
        resultsHTML += `</div>`;
        
        // If we found 3 valid beams, stop checking
        if (validBeams.length >= 3) break;
    }
    
    // Step 6: Summarize results
    resultsHTML += '<h3>Design Summary</h3>';
    
    if (validBeams.length > 0) {
        // Sort valid beams by weight (most efficient first)
        validBeams.sort((a, b) => {
            const weightA = getBeamWeight(a.shape);
            const weightB = getBeamWeight(b.shape);
            return weightA - weightB;
        });
        
        resultsHTML += '<p>The following sections are adequate for the design:</p>';
        resultsHTML += '<ul>';
        validBeams.forEach(beam => {
            resultsHTML += `<li>${beam.shape} (Capacity: ${beam.capacity.toFixed(2)} kip-ft, Required moment: ${beam.demand.toFixed(2)} kip-ft, Ix: ${beam.actualIx.toFixed(2)} in⁴, Deflection: ${beam.deflection.toFixed(3)} in)</li>`;
        });
        resultsHTML += '</ul>';
        
        resultsHTML += `<p class="recommendation"><strong>Recommended Section:</strong> ${validBeams[0].shape} (lightest adequate section)</p>`;
    } else {
        resultsHTML += '<p class="error">No adequate sections found from the checked beams. Consider using larger sections or reducing the loads.</p>';
    }
    
    // Display the final results
    document.getElementById('ResultBendingDesign').innerHTML = resultsHTML;
}


// Helper function to find a steel specification by name
function findSteelSpec(steelName) {
    for (let i = 0; i < steelSpecs.length; i++) {
        const spec = steelSpecs[i];
        if (spec.Steel_name && spec.Steel_name.replace(/\s/g, '') === steelName) {
            return spec;
        }
    }
    
    // If not found, use hardcoded values as fallback
    const hardcodedSpecs = {
        "A36": { Steel_name: "A36", Fy: 36, Fu: 58 },
        "A572Gr.42": { Steel_name: "A572 Gr. 42", Fy: 42, Fu: 60 },
        "A572Gr.50": { Steel_name: "A572 Gr. 50", Fy: 50, Fu: 65 },
        "A572Gr.55": { Steel_name: "A572 Gr. 55", Fy: 55, Fu: 70 },
        "A572Gr.60": { Steel_name: "A572 Gr. 60", Fy: 60, Fu: 75 },
        "A572Gr.65": { Steel_name: "A572 Gr. 65", Fy: 65, Fu: 80 },
        "A588Gr.42": { Steel_name: "A588 Gr. 42", Fy: 42, Fu: 63 },
        "A588Gr.46": { Steel_name: "A588 Gr. 46", Fy: 46, Fu: 67 },
        "A588Gr.50": { Steel_name: "A588 Gr. 50", Fy: 50, Fu: 70 },
        "A687": { Steel_name: "A687", Fy: 50, Fu: 70 },
        "A992": { Steel_name: "A992", Fy: 50, Fu: 65 }
    };
    
    return hardcodedSpecs[steelName];
}

// Helper function to find suitable beams based on required Zx
function findSuitableBeams(requiredZx) {
    const suitable = [];
    
    // Convert section data object to array for easier sorting
    const sections = Object.values(sectionData);
    
    // Filter sections that have sufficient Zx
    const eligibleSections = sections.filter(section => 
        section.AISC_Manual_Label && 
        section.AISC_Manual_Label.startsWith('W') && 
        section.Zx && 
        section.Zx >= requiredZx
    );
    
    // Sort by Zx (ascending - most efficient first)
    eligibleSections.sort((a, b) => a.Zx - b.Zx);
    
    return eligibleSections;
}

// Helper function to get beam weight in pounds per foot
function getBeamWeight(shapeName) {
    if (!shapeName) return 0;
    
    // Get weight directly from sectionData
    if (sectionData[shapeName] && sectionData[shapeName].W) {
        return sectionData[shapeName].W;
    }
    
    // Extract weight from shape name as fallback (e.g., "W12X45" has weight of 45 lbs/ft)
    const parts = shapeName.split('X');
    if (parts.length === 2) {
        const weight = parseFloat(parts[1]);
        if (!isNaN(weight)) {
            return weight;
        }
    }
    
    // Fallback: estimate based on section area
    if (sectionData[shapeName] && sectionData[shapeName].A) {
        // Rough estimate: steel density ≈ 490 lbs/ft³, and A is in in²
        return sectionData[shapeName].A * 3.4; // Approximate conversion
    }
    
    return 0; // Default if all else fails
}

// Add some CSS styles for the results
const style = document.createElement('style');
style.innerHTML = `
    #ResultBendingDesign {
        margin-top: 20px;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        max-height: 1400px;
        overflow-y: auto;
    }
    #ResultBendingDesign h2 {
        margin-top: 0;
        color: #333;
    }
    #ResultBendingDesign h3 {
        margin-top: 15px;
        color: #444;
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
    }
    #ResultBendingDesign h4 {
        margin-top: 10px;
        color: #555;
    }
    .beam-check {
        margin-bottom: 20px;
        padding: 10px;
        background-color: #f9f9f9;
        border-radius: 4px;
    }
    .success {
        color: green;
        font-weight: bold;
    }
    .error {
        color: red;
        font-weight: bold;
    }
    .warning {
        color: orange;
        font-weight: bold;
    }
    .recommendation {
        font-size: 18px;
        padding: 10px;
        background-color: #e9f7ef;
        border-left: 5px solid #27ae60;
        margin: 15px 0;
    }
`;
document.head.appendChild(style);

</script>
    
</body>
</html> 