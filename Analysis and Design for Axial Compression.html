<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Principle of Steel  Design</title>
    <link rel="stylesheet" href="style.css">
   
</head>
<body>
    <header>
        <div class="header"><b>STEEL DESIGN HELPER</b></div>
    </header>

    <nav class="navbar">
        <div class="ADcon">
            <a class="con" id="0" href="index.html">|HOME|</a>
            <a class="con" id="1" href="Analysis and Design for Axial Tension.html">|Analysis and Design for Axial Tension|</a>
            <a class="con" class="active" id="active" href="Analysis and Design for Axial Compression.html">|Analysis and Design for Axial Compression|</a>
            <a class="con" id="3" href="Analysis and Design of Members for Bending.html">|Analysis and Design of Members for Bending|</a>
            <a class="con" id="4" href="Shear Strength of Structural Member.html">|Shear Strength of Structural Member|</a>
             </div>
            </nav>

<div class="FINALCONTAINER">
    <div class="HeaderforCompression">
        <H1 style="display: block;">
            ANALYSIS FOR COMPRESSION MEMBER
        </H1>
        
    </div>
    <div class="COMPRESSIONA">
        <div class="CalcComp">
            <div class="ANALYSISINPUT">
                <H3>STEEL CHARACTERISTIC</H3>
                <div id="ASTM">
                    <label id="ASTMI">ASTM  Specification:</label>
                    <select name="ASTMinput" id="ASTMinput">
                        <option value="A36">A36</option>
                        <option value="A572Gr.42">A572 Gr. 42</option>
                        <option value="A572Gr.50">A572 Gr. 50</option>
                        <option value="A572Gr.55">A572 Gr. 55</option>
                        <option value="A572Gr.60">A572 Gr. 60</option>
                        <option value="A572Gr.65">A572 Gr. 65</option>
                        <option value="A588Gr.42">A588 Gr. 42</option>
                        <option value="A588Gr.46">A588 Gr. 46</option>
                        <option value="A588Gr.50">A588 Gr. 50</option>
                        <option value="A687">A687</option>
                        <option value="A992">A992</option>
                    </select>
                    

                    

                </div>
                <div id="DataInputs">
                    <label>Shape:</label>
                            <select id="shapeA">
                                <option value="W">W</option>
                            </select>
                            <label>Dimension:</label>
                            <input type="text" id="dimA" placeholder="12X45" required size="10">
                </div>
                <div>
                    <label for="lenght">Lenght:</label>
                    <input id="Lenght" size="10" placeholder="ft">
                </div>
                <div>
                    <h3>TOP-BOT END</h3>
                    <div>
                        <label><B>TOP</B></label><br>
                    <label>Fixed:</label>
                    <input type="radio" name="top" id="topfixed"><br>
                    <label>Pinned:</label>
                    <input type="radio" name="top" id="toppinned"><br>
                    <label>Free:</label>
                    <input type="radio" name="top" id="topfree"><br>
                    </div>
                    <div>
                        <label><B>BOT</B></label><br>
                    <label>Fixed:</label>
                    <input type="radio" name="bot" id="botfixed"><br>
                    <label>Pinned:</label>
                    <input type="radio" name="bot" id="botpinned"><br>
                    <label>Free:</label>
                    <input type="radio" name="bot" id="botfree"><br>
                    </div>
                </div>

                <div>
                <H3>LATERAL SUPPORTS OPTION</H3>
                <label for="load">No Support</label>
                    <input type="radio" name="pinned" id="Nosupport">
                    <label for="load">With Lateral Support</label>
                    <input type="radio" name="pinned" id="support">
                    
                </div>
                <div id="SupportA" class="SupportA" style="display: none;">
                    <h3>Lateral Support</h3>
                    <label>Amount of supports:</label>
                    <input type="number" id="supprtamount" placeholder="0" size="1" max="3" min="0" step="1">

                    <div id="support1">
                    <p><b>Support 1</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support1" id="pinned1">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support1" id="fixed1">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support1" id="Free1"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location1" placeholder="ft" size="1" >
                    </div>
                    <div id="support2">
                        <p><b>Support 2</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support2" id="pinned2">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support2" id="fixed2">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support2" id="Free2"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location2" placeholder="ft" size="1" >
                    </div>
                    <div id="support3">
                        <p><b>Support 3</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support3" id="pinned3">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support3" id="fixed3">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support3" id="Free3"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location3" placeholder="ft" size="1" >
            
                    </div>
                    
                
                    
                    
                        
                </div>
                <button id="calculate" class="AnalyzeC">Analyze</button>
            </div>
            <div class="INTERACTIVECOLUMN"> 
                    
            </div>
        </div>
        <div class="RESULTSCOMPRESSION">
            <div class="TableR">
                <h3></h3>
                <table>
                    <thead>
                        <tr>
                            <th>Element</th>
                            <th>Lenght</th>
                            <th>K</th>
                            <th>r</th>
                            <th>K/Lr</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr id="X">
                            <td>X</td>
                            <td id="topL"></td>
                            <td id="topK"></td>
                            <td id="topr"></td>
                            <td id="topKLr"></td>
                        </tr>
                        <tr id="Y">
                            <td>Y</td>
                            <td id="botL"></td>
                            <td id="botK"></td>
                            <td id="botr"></td>
                            <td id="botKLr"></td>
                        </tr> 
                        <tr id="y1">
                            <td>Y1</td>
                            <td id="sup1L"></td>
                            <td id="sup1K"></td>
                            <td id="sup1r"></td>
                            <td id="sup1KLr"></td>
                        </tr>
                        <tr id="y2">
                            <td>Y2</td>
                            <td id="sup2L"></td>
                            <td id="sup2K"></td>
                            <td id="sup2r"></td>
                            <td id="sup2KLr"></td>
                        </tr>
                        <tr id="y3">
                            <td>Y3</td>
                            <td id="sup3L"></td>
                            <td id="sup3K"></td>
                            <td id="sup3r"></td>
                            <td id="sup3KLr"></td> 
                        </tr>
                        <tr id="y4">
                            <td>Y4</td>
                            <td id="sup4L"></td>
                            <td id="sup4K"></td>
                            <td id="sup4r"></td>
                            <td id="sup4KLr"></td>
                        </tr>
                        <tr id="y5">
                            <td>Y5</td>
                            <td id="sup5L"></td>
                            <td id="sup5K"></td>
                            <td id="sup5r"></td>
                            <td id="sup5KLr"></td>
                        </tr>
                    </tbody>
                </table>
                
                
            </div>

            <div id="ResultComp">
                

            </div>
            <div id="AISCCURVE">
                
            </div>
        
        </div>
    </div>
    <div class="DESIGNCOMPRESS">
        <div>
            <H1>DESIGN FOR COMPRESSION MEMBER</H1>
        </div>
        <div class="INPUTCOMPRESS">
            <div>
                <label id="ASTMC">ASTM  Specification:</label>
                    <select name="ASTMinputC" id="ASTMinputC">
                        <option value="A36">A36</option>
                        <option value="A572Gr.42">A572 Gr. 42</option>
                        <option value="A572Gr.50">A572 Gr. 50</option>
                        <option value="A572Gr.55">A572 Gr. 55</option>
                        <option value="A572Gr.60">A572 Gr. 60</option>
                        <option value="A572Gr.65">A572 Gr. 65</option>
                        <option value="A588Gr.42">A588 Gr. 42</option>
                        <option value="A588Gr.46">A588 Gr. 46</option>
                        <option value="A588Gr.50">A588 Gr. 50</option>
                        <option value="A687">A687</option>
                        <option value="A992">A992</option>
                    </select>    
            </div>
            <div class="DesignMethod">
                <label for="designMethod">Design Method:</label>
                <select id="designMethod">
                    <option value="LRFD">LRFD</option>
                    <option value="ASD">ASD</option>
                </select>
            </div>
            <div>
                <label>DeadLoad:</label>
                <input id="DeadLoad" size="10" placeholder="kips">
                <label>Liveload:</label>
                <input  id="LiveLoad" size="10" placeholder="kips">
                <label>Lenght:</label>
                <input id="LenghtDC" size="10" placeholder="ft">
            </div>
             <button id="DesignC" class="DesignC">Design</button>

        </div> 
        <div class="LateralSupportC">
            <div class="TOPBOT">
                
                    <h3>TOP-BOT END</h3>
                        <div>
                            <label><B>TOP</B></label><br>
                        <label>Fixed:</label>
                        <input type="radio" name="top" id="topfixedC"><br>
                        <label>Pinned:</label>
                        <input type="radio" name="top" id="toppinnedC"><br>
                        <label>Free:</label>
                        <input type="radio" name="top" id="topfreeC"><br>
                        </div>
                        <div>
                            <label><B>BOT</B></label><br>
                        <label>Fixed:</label>
                        <input type="radio" name="bot" id="botfixedC"><br>
                        <label>Pinned:</label>
                        <input type="radio" name="bot" id="botpinnedC"><br>
                        <label>Free:</label>
                        <input type="radio" name="bot" id="botfreeC"><br>
                        </div>
                    
             
                <h3>Lateral Support</h3>
                <label>No support:</label>
                <input id="NosupportC" type="radio" name="pinnedC">
                <label>With Lateral Support:</label>
                <input id="supportC" type="radio" name="pinnedC">
                <div id="SupportC" style="display: none;">
                    <label>Amount of supports:</label>
                    <input type="number" id="supprtamountC" placeholder="0" size="1" max="3" min="0" step="1">
                    </div>
                         <div id="support1C">
                        <p><b>Support 1</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support1C" id="pinned1C">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support1C" id="fixed1C">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support1C" id="Free1C"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location1C" placeholder="ft" size="1" >
                         </div>
                          <div id="support2C">
                        <p><b>Support 2</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support2C" id="pinned2C">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support2C" id="fixed2C">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support2C" id="Free2C"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location2C" placeholder="ft" size="1" >
                            </div>
                            <div id="support3C">
                        <p><b>Support 3</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support3C" id="pinned3C">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support3C" id="fixed3C">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support3C" id="Free3C"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location3C" placeholder="" size="1" >
                    </div>


            </div>
            <div class="ResultCalcC">

                <div class="GraphicalColumn">
                    
                    
                    
                    
                </div>
                

               
                
            </div>
            
            
        </div>  
        <div class="ResultofallCD">
            <div class="TableR">
                <table>
                    <thead>
                        <tr>
                            <th>ELement</th>
                            <th>Length</th>
                            <th>K</th>
                            <th>K/L</th>
                            <th>Governing</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>X</td>
                            <td id="L1"></td>
                            <td id="K1"> </td>
                            <td dir="K/L1"></td>
                            <td id="G1"></td>
                        </tr>
                        <tr>
                            <td>Y</td>
                            <td id="L2"></td>
                            <td id="K2"> </td>
                            <td dir="K/L2"></td>
                            <td id="G2"></td>
                        </tr>
                        <tr>
                            <td>Y1</td>
                            <td id="L3"></td>
                            <td id="K3"> </td>
                            <td dir="K/L3"></td>
                            <td id="G3"></td>
                        </tr>
                        <tr>
                            <td>Y2</td>
                            <td id="L4"></td>
                            <td id="K4"> </td>
                            <td dir="K/L4"></td>
                            <td id="G4"></td>
                        </tr>
                    </tbody>
                </table>
                
                

                
            </div>
            <div class="TableR1">
                <table>
                    <thead>
                        <tr>
                            <th id="CompShape">W-SHAPE</th>
                            <th id="pupa">Table 3-6 (continued)
                                Maximum Total 
                               Uniform Load</th>
                            <th id="Weight">W</th>
                            <th id="rxry">rx/ry</th>
                            <th id="Best">Best</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td id="W14"></td>
                            <td id="pupa1"></td>
                            <td id="Weight1"></td>
                            <td id="rxry1"></td>
                            <td id="Best1"></td>
                            
                            
                        </tr>
                        <tr>
                            <td id="W12"></td>
                            <td id="pupa2"></td>
                            <td id="Weight2"></td>
                            <td id="rxry2"></td>
                            <td id="Best2"></td>

                          
                        </tr>
                        <tr>
                            <td id="W10"></td>
                            <td id="pupa3"></td>
                            <td id="Weight3"></td>
                            <td id="rxry3"></td>
                            <td id="Best3"></td>
                          
                        </tr>
                        <tr>
                            <td id="W8"></td>
                            <td id="pupa4"></td>
                            <td id="Weight4"></td>
                            <td id="rxry4"></td>
                            <td id="Best4"></td>
                        </tr>
                    </tbody>
                </table>
                
                

                
            </div>
            <div class="    " >
                
            </div>

        </div>
     </div>


        
        
 
        
    

    
</div>




<script>
// Function to handle the visibility of the SupportA container
function handleSupportVisibility() {
  // Get the radio buttons and the SupportA container
  const supportRadio = document.getElementById('support');
  const noSupportRadio = document.getElementById('Nosupport');
  const supportContainer = document.getElementById('SupportA');
  
  // Show the SupportA container if the support radio is checked
  if (supportRadio.checked) {
    supportContainer.style.display = 'block';
  }
  // Hide the SupportA container if the Nosupport radio is checked
  else if (noSupportRadio.checked) {
    supportContainer.style.display = 'none';
  }
}

// Add event listeners to both radio buttons
document.getElementById('support').addEventListener('change', handleSupportVisibility);
document.getElementById('Nosupport').addEventListener('change', handleSupportVisibility);

// Run the function once when the page loads to set the initial state
document.addEventListener('DOMContentLoaded', function() {
  // Check the initial state of the radio buttons and set visibility accordingly
  handleSupportVisibility();
});

document.addEventListener("DOMContentLoaded", function() {
    // Get references to DOM elements
    const noSupportRadio = document.getElementById("Nosupport");
    const withSupportRadio = document.getElementById("support");
    const supportADiv = document.getElementById("SupportA");
    const supportAmountInput = document.getElementById("supprtamount");
    const support1Div = document.getElementById("support1");
    const support2Div = document.getElementById("support2");
    const support3Div = document.getElementById("support3");

    // Initially hide all support divs
    support1Div.style.display = "none";
    support2Div.style.display = "none";
    support3Div.style.display = "none";

    // Show/hide SupportA div based on radio button selection
    noSupportRadio.addEventListener("change", function() {
        if (this.checked) {
            supportADiv.style.display = "none";
        }
    });

    withSupportRadio.addEventListener("change", function() {
        if (this.checked) {
            supportADiv.style.display = "block";
            // When support is initially shown, update which support divs are visible
            updateSupportDivs();
        }
    });

    // Listen for changes to the support amount input
    supportAmountInput.addEventListener("input", updateSupportDivs);

    function updateSupportDivs() {
        const amount = parseInt(supportAmountInput.value) || 0;
        
        // Show/hide support divs based on amount
        support1Div.style.display = amount >= 1 ? "block" : "none";
        support2Div.style.display = amount >= 2 ? "block" : "none";
        support3Div.style.display = amount >= 3 ? "block" : "none";
    }

    // Initialize state based on initial values
    if (withSupportRadio.checked) {
        supportADiv.style.display = "block";
        updateSupportDivs();
    } else {
        supportADiv.style.display = "none";
    }
});

document.addEventListener("DOMContentLoaded", function() {
    // Add containers for both visualizations after the "INTERACTIVECOLUMN" div
    const interactiveColumn = document.querySelector(".INTERACTIVECOLUMN");
    interactiveColumn.innerHTML = `
        <div style="display: flex; flex-wrap: wrap; gap: 20px; margin-top: 20px;">
            <!-- Y-axis visualization (with lateral supports) -->
            <div class="visualization-container" style="flex: 1; min-width: 300px; height: 500px; border: 1px solid #ccc; position: relative; overflow: hidden;">
                <h3 style="text-align: center; margin: 5px 0;">Y-Axis Visualization (Lateral Supports)</h3>
                <div id="beam-visualization-y" style="width: 100%; height: 450px; position: relative;">
                    <!-- SVG will be inserted here -->
                </div>
            </div>
            
            <!-- X-axis visualization (without lateral supports) -->
            <div class="visualization-container" style="flex: 1; min-width: 300px; height: 500px; border: 1px solid #ccc; position: relative; overflow: hidden;">
                <h3 style="text-align: center; margin: 5px 0;">X-Axis Visualization (Full Length)</h3>
                <div id="beam-visualization-x" style="width: 100%; height: 450px; position: relative;">
                    <!-- SVG will be inserted here -->
                </div>
            </div>
        </div>
    `;

    // Get all the input elements we need to monitor
    const lengthInput = document.getElementById("Lenght");
    const supportRadio = document.getElementById("support");
    const noSupportRadio = document.getElementById("Nosupport");
    const supportAmountInput = document.getElementById("supprtamount");
    const locationInputs = [
        document.getElementById("location1"),
        document.getElementById("location2"),
        document.getElementById("location3")
    ];
    
    // Top support options
    const topFixed = document.getElementById("topfixed");
    const topPinned = document.getElementById("toppinned");
    const topFree = document.getElementById("topfree");
    
    // Bottom support options
    const botFixed = document.getElementById("botfixed");
    const botPinned = document.getElementById("botpinned");
    const botFree = document.getElementById("botfree");
    
    // Lateral support options
    const lateralSupportTypes = [
        {
            pinned: document.getElementById("pinned1"),
            fixed: document.getElementById("fixed1"),
            free: document.getElementById("Free1")
        },
        {
            pinned: document.getElementById("pinned2"),
            fixed: document.getElementById("fixed2"),
            free: document.getElementById("Free2")
        },
        {
            pinned: document.getElementById("pinned3"),
            fixed: document.getElementById("fixed3"),
            free: document.getElementById("Free3")
        }
    ];

    // Analyze button
    const analyzeButton = document.getElementById("calculate");

    // Initial drawing
    drawBeamColumns();

    // Add event listeners to all inputs that should trigger a redraw
    lengthInput.addEventListener("input", drawBeamColumns);
    supportRadio.addEventListener("change", drawBeamColumns);
    noSupportRadio.addEventListener("change", drawBeamColumns);
    supportAmountInput.addEventListener("input", drawBeamColumns);
    
    for (let i = 0; i < locationInputs.length; i++) {
        locationInputs[i].addEventListener("input", drawBeamColumns);
    }
    
    // Top support options
    topFixed.addEventListener("change", drawBeamColumns);
    topPinned.addEventListener("change", drawBeamColumns);
    topFree.addEventListener("change", drawBeamColumns);
    
    // Bottom support options
    botFixed.addEventListener("change", drawBeamColumns);
    botPinned.addEventListener("change", drawBeamColumns);
    botFree.addEventListener("change", drawBeamColumns);
    
    // Lateral support options
    for (let i = 0; i < lateralSupportTypes.length; i++) {
        lateralSupportTypes[i].pinned.addEventListener("change", drawBeamColumns);
        lateralSupportTypes[i].fixed.addEventListener("change", drawBeamColumns);
        lateralSupportTypes[i].free.addEventListener("change", drawBeamColumns);
    }
    
    analyzeButton.addEventListener("click", drawBeamColumns);

    function drawBeamColumns() {
        // Draw both visualizations
        drawYAxisBeam();
        drawXAxisBeam();
    }

    function drawYAxisBeam() {
        const beamVisualization = document.getElementById("beam-visualization-y");
        if (!beamVisualization) return;

        // Get the current values from the form
        const columnLength = parseFloat(lengthInput.value) || 16; // Default to 16 if not specified
        const hasLateralSupports = supportRadio.checked;
        const supportCount = hasLateralSupports ? parseInt(supportAmountInput.value) || 0 : 0;
        
        // Get support locations and sort them by position
        const supportLocations = [];
        if (hasLateralSupports) {
            for (let i = 0; i < supportCount && i < 3; i++) {
                const location = parseFloat(locationInputs[i].value) || 0;
                if (location > 0 && location < columnLength) {
                    supportLocations.push({
                        position: location,
                        type: lateralSupportTypes[i].fixed.checked ? "fixed" :
                              lateralSupportTypes[i].pinned.checked ? "pinned" : "free",
                        index: i + 1
                    });
                }
            }
        }
        
        // Sort support locations by position
        supportLocations.sort((a, b) => a.position - b.position);
        
        // Get end supports
        const topSupport = topFixed.checked ? "fixed" : topPinned.checked ? "pinned" : "free";
        const botSupport = botFixed.checked ? "fixed" : botPinned.checked ? "pinned" : "free";

        // Calculate dimensions
        const svgWidth = beamVisualization.clientWidth;
        const svgHeight = beamVisualization.clientHeight;
        const margin = { top: 20, right: 40, bottom: 40, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        
        // Scale factors
        const yScale = height / columnLength;
        
        // Determine segment points (top, all supports, bottom)
        const segmentPoints = [0, ...supportLocations.map(s => s.position), columnLength];
        
        // Create the SVG
        const svg = `
            <svg width="${svgWidth}" height="${svgHeight}">
                <g transform="translate(${margin.left}, ${margin.top})">
                    <!-- Column shaft (W-shape) showing front and side view -->
                    <!-- Front view (Y-axis) -->
                    <path d="M ${width/2-15} 0 
                             L ${width/2-15} ${columnLength * yScale}
                             M ${width/2+15} 0
                             L ${width/2+15} ${columnLength * yScale}
                             M ${width/2-25} 0
                             L ${width/2+25} 0
                             M ${width/2-25} ${columnLength * yScale}
                             L ${width/2+25} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                    
                    <!-- "Y" label below the beam -->
                    <text x="${width/2}" y="${columnLength * yScale + 35}" 
                          text-anchor="middle" font-size="16" font-weight="bold">
                        Y
                    </text>
                    
                    <!-- Top support -->
                    ${renderSupport(width/2, 0, topSupport, "top")}
                    
                    <!-- Bottom support -->
                    ${renderSupport(width/2, columnLength * yScale, botSupport, "bottom")}
                    
                    <!-- Lateral supports -->
                    ${supportLocations.map(support => 
                        renderLateralSupport(width/2, support.position * yScale, support.type)
                    ).join('')}
                    
                    <!-- Column height label -->
                    <text x="${40}" y="${columnLength * yScale / 2}" 
                          transform="rotate(360, ${width/2 + 40}, ${columnLength * yScale / 2})"
                          text-anchor="middle" dominant-baseline="middle" font-size="12">
                        ${columnLength}' Column Length
                    </text>
                    
                    <!-- Support location labels -->
                    ${supportLocations.map((support) => `
                        <text x="${width/2 - 40}" y="${support.position * yScale}"
                              text-anchor="end" dominant-baseline="middle" font-size="12">
                            Support ${support.index}: ${support.position}'
                        </text>
                    `).join('')}
                    
                    <!-- Segment labels (y1, y2, etc.) -->
                    ${segmentPoints.slice(0, -1).map((startPoint, i) => {
                        const endPoint = segmentPoints[i + 1];
                        const segmentLength = endPoint - startPoint;
                        const midPoint = (startPoint + endPoint) / 2;
                        
                        return `
                            <!-- y${i+1} segment label -->
                            <text x="${width/2 + 30}" y="${(startPoint + (segmentLength/2)) * yScale}"
                                  text-anchor="start" dominant-baseline="middle" font-size="14" fill="blue" font-weight="bold">
                                y${i+1} = ${segmentLength.toFixed(2)}'
                            </text>
                            
                            <!-- Segment marker lines -->
                            <line x1="${width/2 + 15}" y1="${startPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${startPoint * yScale}"
                                  stroke="blue" stroke-width="1" />
                            <line x1="${width/2 + 15}" y1="${endPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${endPoint * yScale}"
                                  stroke="blue" stroke-width="1" />
                            
                            <!-- Connecting line for segment -->
                            <line x1="${width/2 + 25}" y1="${startPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${endPoint * yScale}"
                                  stroke="blue" stroke-width="1" stroke-dasharray="4,2" />
                        `;
                    }).join('')}
                </g>
            </svg>
        `;
        
        beamVisualization.innerHTML = svg;
    }
    
    function drawXAxisBeam() {
        const beamVisualization = document.getElementById("beam-visualization-x");
        if (!beamVisualization) return;

        // Get the current values from the form
        const columnLength = parseFloat(lengthInput.value) || 16; // Default to 16 if not specified
        
        // Get end supports
        const topSupport = topFixed.checked ? "fixed" : topPinned.checked ? "pinned" : "free";
        const botSupport = botFixed.checked ? "fixed" : botPinned.checked ? "pinned" : "free";

        // Calculate dimensions
        const svgWidth = beamVisualization.clientWidth;
        const svgHeight = beamVisualization.clientHeight;
        const margin = { top: 20, right: 40, bottom: 40, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        
        // Scale factors
        const yScale = height / columnLength;
        
        // Create the SVG - showing the beam from the side (X-axis view)
        const svg = `
            <svg width="${svgWidth}" height="${svgHeight}">
                <g transform="translate(${margin.left}, ${margin.top})">
                    <!-- Column shaft (W-shape) - side view (X-axis) -->
                    <path d="M ${width/2-25} 0 
                             L ${width/2-25} ${columnLength * yScale}
                             M ${width/2+25} 0
                             L ${width/2+25} ${columnLength * yScale}
                             M ${width/2-25} 0
                             L ${width/2+25} 0
                             M ${width/2-25} ${columnLength * yScale}
                             L ${width/2+25} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                          
                    <!-- Web of the W-shape (showing flange depth) -->
                    <path d="M ${width/2-10} 0 
                             L ${width/2-10} ${columnLength * yScale}
                             M ${width/2+10} 0
                             L ${width/2+10} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                    
                    <!-- "X" label below the beam -->
                    <text x="${width/2}" y="${columnLength * yScale + 35}" 
                          text-anchor="middle" font-size="16" font-weight="bold">
                        X
                    </text>
                    
                    <!-- Top support -->
                    ${renderSupport(width/2, 0, topSupport, "top")}
                    
                    <!-- Bottom support -->
                    ${renderSupport(width/2, columnLength * yScale, botSupport, "bottom")}
                    
                    <!-- Full column length label -->
                    <text x="${32}" y="${columnLength * yScale / 2}" 
                          transform="rotate(360, ${width/2 + 40}, ${columnLength * yScale / 2})"
                          text-anchor="middle" dominant-baseline="middle" font-size="12">
                        ${columnLength}' Column Length
                    </text>
                    
                    <!-- Main segment label for X-axis view -->
                    <text x="${width/2 + 30}" y="${columnLength * yScale / 2}"
                          text-anchor="start" dominant-baseline="middle" font-size="14" fill="blue" font-weight="bold">
                        y1 = ${columnLength.toFixed(2)}'
                    </text>
                    
                    <!-- Segment marker lines -->
                    <line x1="${width/2 + 25}" y1="0" 
                          x2="${width/2 + 35}" y2="0"
                          stroke="blue" stroke-width="1" />
                    <line x1="${width/2 + 25}" y1="${columnLength * yScale}" 
                          x2="${width/2 + 35}" y2="${columnLength * yScale}"
                          stroke="blue" stroke-width="1" />
                    
                    <!-- Connecting line for segment -->
                    <line x1="${width/2 + 35}" y1="0" 
                          x2="${width/2 + 35}" y2="${columnLength * yScale}"
                          stroke="blue" stroke-width="1" stroke-dasharray="4,2" />
                </g>
            </svg>
        `;
        
        beamVisualization.innerHTML = svg;
    }
    
    function renderSupport(x, y, type, position) {
        if (type === "fixed") {
            // Fixed support (triangle with hatching)
            const direction = position === "top" ? -1 : 1;
            return `
                <path d="M ${x-30} ${y + (direction * 10)} 
                         L ${x+30} ${y + (direction * 10)}
                         L ${x} ${y}"
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching lines for fixed support -->
                ${Array.from({length: 7}, (_, i) => 
                    `<line x1="${x-25 + i*10}" y1="${y + (direction * 10)}" 
                           x2="${x-25 + i*10}" y2="${y + (direction * 5)}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
            `;
        } else if (type === "pinned") {
            // Pinned support (triangle)
            const direction = position === "top" ? -1 : 1;
            return `
                <path d="M ${x-30} ${y + (direction * 10)} 
                         L ${x+30} ${y + (direction * 10)}
                         L ${x} ${y}"
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Circles to represent pins -->
                <circle cx="${x}" cy="${y}" r="3" fill="black" />
            `;
        } else { // free
            // Free end (nothing)
            return '';
        }
    }
    
    function renderLateralSupport(x, y, type) {
        if (type === "fixed") {
            // Fixed lateral support (square block with hatching)
            return `
                <rect x="${x+20}" y="${y-10}" width="20" height="20" 
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching for fixed support -->
                ${Array.from({length: 4}, (_, i) => 
                    `<line x1="${x+20}" y1="${y-10 + i*5}" 
                           x2="${x+40}" y2="${y-10 + i*5}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
                <!-- Line connecting to column -->
                <line x1="${x+15}" y1="${y}" x2="${x+20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                
                <!-- Left side support - mirror image -->
                <rect x="${x-40}" y="${y-10}" width="20" height="20" 
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching for fixed support -->
                ${Array.from({length: 4}, (_, i) => 
                    `<line x1="${x-40}" y1="${y-10 + i*5}" 
                           x2="${x-20}" y2="${y-10 + i*5}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
                <!-- Line connecting to column -->
                <line x1="${x-15}" y1="${y}" x2="${x-20}" y2="${y}"
                      stroke="black" stroke-width="2" />
            `;
        } else if (type === "pinned") {
            // Pinned lateral support (roller)
            return `
                <!-- Right side -->
                <circle cx="${x+30}" cy="${y}" r="10" 
                        stroke="black" stroke-width="2" fill="none" />
                <!-- Line connecting to column -->
                <line x1="${x+15}" y1="${y}" x2="${x+20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                <!-- Small circle for pin -->
                <circle cx="${x+20}" cy="${y}" r="3" fill="black" />
                
                <!-- Left side - mirror image -->
                <circle cx="${x-30}" cy="${y}" r="10" 
                        stroke="black" stroke-width="2" fill="none" />
                <!-- Line connecting to column -->
                <line x1="${x-15}" y1="${y}" x2="${x-20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                <!-- Small circle for pin -->
                <circle cx="${x-20}" cy="${y}" r="3" fill="black" />
            `;
        } else { // free
            // Free lateral support (just a line to indicate position)
            return `
                <line x1="${x-40}" y1="${y}" x2="${x+40}" y2="${y}"
                      stroke="blue" stroke-width="1" stroke-dasharray="5,5" />
            `;
        }
    }
});

// Steel Properties Database - Simplified version
// This would normally be loaded from ASTMSPEC.xlsx sheets
const steelProperties = {
    "A36": { Fy: 36, Fu: 58, E: 29000 },
    "A572Gr.42": { Fy: 42, Fu: 60, E: 29000 },
    "A572Gr.50": { Fy: 50, Fu: 65, E: 29000 },
    "A572Gr.55": { Fy: 55, Fu: 70, E: 29000 },
    "A572Gr.60": { Fy: 60, Fu: 75, E: 29000 },
    "A572Gr.65": { Fy: 65, Fu: 80, E: 29000 },
    "A588Gr.42": { Fy: 42, Fu: 63, E: 29000 },
    "A588Gr.46": { Fy: 46, Fu: 67, E: 29000 },
    "A588Gr.50": { Fy: 50, Fu: 70, E: 29000 },
    "A687": { Fy: 50, Fu: 70, E: 29000 },
    "A992": { Fy: 50, Fu: 65, E: 29000 }
};

// W-Shape Properties Database - Simplified with commonly used sections
const wShapeProperties = {
    "W10X77": {
        A: 22.7, d: 10.6, bf: 10.1, tf: 0.870, tw: 0.530,
        Ix: 455, Zx: 99.1, Sx: 85.9, rx: 4.49,
        Iy: 152, Zy: 45.3, Sy: 30.1, ry: 2.60,
        h: 8.86, J: 4.89, Cw: 3680
    },
    "W12X45": {
        A: 13.2, d: 11.9, bf: 8.0, tf: 0.576, tw: 0.335,
        Ix: 270, Zx: 51.7, Sx: 45.6, rx: 4.51,
        Iy: 88.6, Zy: 22.2, Sy: 22.1, ry: 2.59,
        h: 10.748, J: 1.24, Cw: 1260
    },
    // Add more sections as needed
};

// Main analysis function
document.addEventListener('DOMContentLoaded', function() {
    // Get elements
    const calculateBtn = document.getElementById('calculate');
    const resultDiv = document.getElementById('ResultComp');
    const supportRadio = document.getElementById('support');
    const noSupportRadio = document.getElementById('Nosupport');
    const supportAmountInput = document.getElementById('supprtamount');
    const supportDiv = document.getElementById('SupportA');
    
    // Show/hide support options based on radio selection
    supportRadio.addEventListener('change', function() {
        if (this.checked) {
            supportDiv.style.display = 'block';
        }
    });
    
    noSupportRadio.addEventListener('change', function() {
        if (this.checked) {
            supportDiv.style.display = 'none';
            supportAmountInput.value = '';
        }
    });
    
    // Analyze button click event
    calculateBtn.addEventListener('click', function() {
        analyzeCompression();
    });
    
    function analyzeCompression() {
        // Get inputs
        const astmSpec = document.getElementById('ASTMinput').value;
        const shapeDim = document.getElementById('dimA').value.toUpperCase();
        const columnLength = parseFloat(document.getElementById('Lenght').value) * 12; // Convert ft to inches
        
        // Get steel properties
        const steel = steelProperties[astmSpec];
        if (!steel) {
            resultDiv.innerHTML = `<div class="error">Error: Steel specification ${astmSpec} not found.</div>`;
            return;
        }
        
        // Get shape properties
        const shape = wShapeProperties[`W${shapeDim}`];
        if (!shape) {
            resultDiv.innerHTML = `<div class="error">Error: Shape W${shapeDim} not found.</div>`;
            return;
        }
        
        // Calculate effective length factor (K)
        let kx = 1.0; // Default value
        let ky = 1.0; // Default value
        
        // Determine K based on end conditions
        if (document.getElementById('topfixed').checked && document.getElementById('botfixed').checked) {
            kx = ky = 0.65; // Fixed-Fixed
        } else if (document.getElementById('topfixed').checked && document.getElementById('botpinned').checked) {
            kx = ky = 0.80; // Fixed-Pinned
        } else if (document.getElementById('toppinned').checked && document.getElementById('botpinned').checked) {
            kx = ky = 1.0; // Pinned-Pinned
        } else if ((document.getElementById('topfixed').checked && document.getElementById('botfree').checked) ||
                   (document.getElementById('topfree').checked && document.getElementById('botfixed').checked)) {
            kx = ky = 2.1; // Fixed-Free
        } else if ((document.getElementById('toppinned').checked && document.getElementById('botfree').checked) ||
                   (document.getElementById('topfree').checked && document.getElementById('botpinned').checked)) {
            kx = ky = 2.0; // Pinned-Free
        }
        
        // Calculate slenderness ratios
        const KLrx = (kx * columnLength) / shape.rx;
        const KLry = (ky * columnLength) / shape.ry;
        const KLr = Math.max(KLrx, KLry); // Critical KL/r
        
        // Update table
        document.getElementById('topL').textContent = (columnLength / 12).toFixed(2) + ' ft';
        document.getElementById('topK').textContent = kx.toFixed(2);
        document.getElementById('topr').textContent = shape.rx.toFixed(2);
        document.getElementById('topKLr').textContent = KLrx.toFixed(2);
        
        document.getElementById('sup1L').textContent = '-';
        document.getElementById('sup1K').textContent = '-';
        document.getElementById('sup1r').textContent = '-';
        document.getElementById('sup1KLr').textContent = '-';
        
        document.getElementById('sup2L').textContent = '-';
        document.getElementById('sup2K').textContent = '-';
        document.getElementById('sup2r').textContent = '-';
        document.getElementById('sup2KLr').textContent = '-';
        
        document.getElementById('sup3L').textContent = '-';
        document.getElementById('sup3K').textContent = '-';
        document.getElementById('sup3r').textContent = '-';
        document.getElementById('sup3KLr').textContent = '-';

        document.getElementById('sup4L').textContent = '-';
        document.getElementById('sup4K').textContent = '-';
        document.getElementById('sup4r').textContent = '-';
        document.getElementById('sup4KLr').textContent = '-';

        document.getElementById('sup5L').textContent = '-';
        document.getElementById('sup5K').textContent = '-';
        document.getElementById('sup5r').textContent = '-';
        document.getElementById('sup5KLr').textContent = '-';
        
        // Check if compact or slender
        // Flange check
        const lambdaFlange = shape.bf / (2 * shape.tf);
        const lambdaFlangeLimit = 0.56 * Math.sqrt(steel.E / steel.Fy);
        const isCompactFlange = lambdaFlange <= lambdaFlangeLimit;
        
        // Web check
        const lambdaWeb = shape.h / shape.tw;
        const lambdaWebLimit = 1.49 * Math.sqrt(steel.E / steel.Fy);
        const isCompactWeb = lambdaWeb <= lambdaWebLimit;
        
        // Calculate critical stress
        let Fcr;
        const Fe = (Math.pow(Math.PI, 2) * steel.E) / Math.pow(KLr, 2); // Elastic buckling stress
        
        if (KLr <= 4.71 * Math.sqrt(steel.E / steel.Fy)) {
            // Inelastic buckling
            Fcr = 0.658 ** (steel.Fy / Fe) * steel.Fy;
        } else {
            // Elastic buckling
            Fcr = 0.877 * Fe;
        }
        
        // Calculate nominal compression strength
        const Pn = shape.A * Fcr;
        
        // Calculate design strength (LRFD)
        const phi = 0.9; // Resistance factor for compression
        const Pu = phi * Pn;
        
        // Calculate available strength (ASD)
        const omega = 1.67; // Safety factor for compression
        const Pa = Pn / omega;
        
        // Format results for display
        let resultsHTML = `
            <h2>Compression Analysis Results for W${shapeDim} (${astmSpec})</h2>
            <div class="results-section">
                <h3>1. Section Classification</h3>
                <div class="result-item">
                    <strong>Flange:</strong>  = ${lambdaFlange.toFixed(2)}, r = ${lambdaFlangeLimit.toFixed(2)}  ${isCompactFlange ? "Compact" : "Slender"}
                </div>
                <div class="result-item">
                    <strong>Web:</strong>  = ${lambdaWeb.toFixed(2)}, r = ${lambdaWebLimit.toFixed(2)}  ${isCompactWeb ? "Compact" : "Slender"}
                </div>
                <div class="result-item">
                    <strong>Section:</strong> ${(isCompactFlange && isCompactWeb) ? "Compact Section" : "Non-Compact Section"}
                </div>
            </div>
            
            <div class="results-section">
                <h3>2. Critical Slenderness</h3>
                <div class="result-item">
                    <strong>X-axis:</strong> KL/r = ${KLrx.toFixed(2)}
                </div>
                <div class="result-item">
                    <strong>Y-axis:</strong> KL/r = ${KLry.toFixed(2)}
                </div>
                <div class="result-item">
                    <strong>Critical:</strong> KL/r = ${KLr.toFixed(2)}
                </div>
            </div>
            
            <div class="results-section">
                <h3>3. Buckling Stress and Strength</h3>
                <div class="result-item">
                    <strong>Elastic Buckling Stress (Fe):</strong> ${Fe.toFixed(2)} ksi
                </div>
                <div class="result-item">
                    <strong>Critical Stress (Fcr):</strong> ${Fcr.toFixed(2)} ksi
                </div>
                <div class="result-item">
                    <strong>Nominal Strength (Pn):</strong> ${Pn.toFixed(2)} kips
                </div>
            </div>
            
            <div class="results-section">
                <h3>4. Design Strength</h3>
                <div class="result-item">
                    <strong>LRFD (Pn):</strong> ${Pu.toFixed(2)} kips
                </div>
                <div class="result-item">
                    <strong>ASD (Pn/):</strong> ${Pa.toFixed(2)} kips
                </div>
            </div>
        `;
        
        resultDiv.innerHTML = resultsHTML;
    }
});


const E = 29000; // ksi - Modulus of elasticity
const PI = Math.PI;

// Global variables to store data from Excel
let astmData = {};
let wShapesData = {};
let dataLoaded = false;

// Function to load data from Excel
async function loadExcelData() {
    try {
        // Use SheetJS to parse the Excel file
        // This assumes the ASTMSPEC.xlsx file is available
        const response = await fetch('ASTMSPEC.xlsx');
        const data = await response.arrayBuffer();
        const workbook = XLSX.read(data, { type: 'array' });
        
        console.log("Excel workbook loaded. Sheet names:", workbook.SheetNames);
        
        // Sheet 1: Steel name, Fy, Fu
        const sheet1 = workbook.Sheets[workbook.SheetNames[0]];
        const steelData = XLSX.utils.sheet_to_json(sheet1);
        
        console.log("Steel data sample:", steelData.slice(0, 3));
        
        // Process steel data into our format
        steelData.forEach(row => {
            if (row['Steel name']) {
                astmData[row['Steel name']] = {
                    Fy: row['Fy'] || 0,
                    Fu: row['Fu'] || 0
                };
            }
        });
        
        console.log("Processed ASTM data:", Object.keys(astmData));
        
        // Sheet 2: W-shape properties
        const sheet2 = workbook.Sheets[workbook.SheetNames[1]];
        const shapeData = XLSX.utils.sheet_to_json(sheet2);
        
        console.log("Shape data sample:", shapeData.slice(0, 3));
        console.log("Shape data columns:", Object.keys(shapeData[0] || {}));
        
        // Process shape data into our format
        shapeData.forEach(row => {
            // Check if it's a W-shape by the AISC_Manual_Label or some other field
            let shapeLabel = row['AISC_Manual_Label'] || row['W_shape'] || '';
            
            // Some Excel files might use different column names - try to detect them
            if (!shapeLabel) {
                // Look for any key that might contain shape information
                for (const key in row) {
                    if (typeof row[key] === 'string' && row[key].startsWith('W')) {
                        shapeLabel = row[key];
                        break;
                    }
                }
            }
            
            // Remove any spaces and convert to uppercase for consistency
            shapeLabel = shapeLabel.toString().replace(/\s+/g, '').toUpperCase();
            
            if (shapeLabel && shapeLabel.startsWith('W')) {
                wShapesData[shapeLabel] = {
                    A: row['A'] || 0,
                    d: row['d'] || 0,
                    tw: row['tw'] || 0,
                    bf: row['bf'] || 0,
                    tf: row['tf'] || 0,
                    htw: row['h/tw'] || 0,
                    Ix: row['Ix'] || 0,
                    Zx: row['Zx'] || 0,
                    Sx: row['Sx'] || 0,
                    rx: row['rx'] || 0,
                    Iy: row['Iy'] || 0,
                    Zy: row['Zy'] || 0,
                    Sy: row['Sy'] || 0,
                    ry: row['ry'] || 0
                };
            }
        });
        
        console.log("Processed W-shapes data:", Object.keys(wShapesData));
        
        dataLoaded = true;
        console.log("Excel data loaded successfully!");
        
        // Populate dropdown with ASTM specs
        const astmSelect = document.getElementById('ASTMinput');
        astmSelect.innerHTML = '';
        
        Object.keys(astmData).forEach(spec => {
            const option = document.createElement('option');
            option.value = spec;
            option.textContent = spec;
            astmSelect.appendChild(option);
        });
        
        // Enable the analyze button
        document.getElementById('calculate').disabled = false;
        
    } catch (error) {
        console.error("Error loading Excel data:", error);
        // If Excel loading fails, use hardcoded default data
        useDefaultData();
    }
}

// Fallback function to use hardcoded data if Excel loading fails
function useDefaultData() {
    console.log("Using default hardcoded data");
    
    // Default ASTM data
    astmData = {
        "A36": { Fy: 36, Fu: 58 },
        "A572Gr.50": { Fy: 50, Fu: 65 },
        "A992": { Fy: 50, Fu: 65 }
    };
    
    // Default W shape data (limited set)
    wShapesData = {
        "W12X14": {
            A: 4.16, d: 11.91, tw: 0.170, bf: 3.97, tf: 0.225, htw: 66.8, 
            Ix: 88.6, Zx: 17.3, Sx: 14.9, rx: 4.62, 
            Iy: 2.36, Zy: 1.19, Sy: 0.766, ry: 0.754
        },
        "W12X26": {
            A: 7.65, d: 12.22, tw: 0.230, bf: 6.49, tf: 0.380, htw: 50.1, 
            Ix: 204, Zx: 37.2, Sx: 33.4, rx: 5.17, 
            Iy: 21.3, Zy: 6.58, Sy: 4.22, ry: 1.67
        },
        "W12X45": {
            A: 13.2, d: 12.06, tw: 0.335, bf: 8.05, tf: 0.575, htw: 33.0, 
            Ix: 348, Zx: 64.2, Sx: 57.7, rx: 5.13, 
            Iy: 56.3, Zy: 14.0, Sy: 9.08, ry: 2.06
        }
    };
    
    dataLoaded = true;
    document.getElementById('calculate').disabled = false;
}

// Event listeners
document.addEventListener('DOMContentLoaded', function() {
    // Add SheetJS library
    const sheetJsScript = document.createElement('script');
    sheetJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
    document.head.appendChild(sheetJsScript);
    
    sheetJsScript.onload = function() {
        // Try to load Excel data once SheetJS is loaded
        loadExcelData();
    };
    
    // Disable calculate button until data is loaded
    document.getElementById('calculate').disabled = true;
    
    // Hide support options initially
    document.getElementById('SupportA').style.display = 'none';
    
    // Support radio button event listeners
    document.getElementById('Nosupport').addEventListener('change', toggleSupportOptions);
    document.getElementById('support').addEventListener('change', toggleSupportOptions);
    
    // Calculate button event listener
    document.getElementById('calculate').addEventListener('click', analyzeColumn);
    
    // Amount of supports input listener
    document.getElementById('supprtamount').addEventListener('input', function() {
        updateSupportInputs(this.value);
    });
});

// Function to toggle support options visibility
function toggleSupportOptions() {
    const supportDiv = document.getElementById('SupportA');
    if (document.getElementById('support').checked) {
        supportDiv.style.display = 'block';
    } else {
        supportDiv.style.display = 'none';
    }
}

// Function to show/hide support input fields based on quantity
function updateSupportInputs(amount) {
    // Hide all support divs first
    document.getElementById('support1').style.display = 'none';
    document.getElementById('support2').style.display = 'none';
    document.getElementById('support3').style.display = 'none';
    
    // Show divs based on amount
    for (let i = 1; i <= amount && i <= 5; i++) {
        document.getElementById('support' + i).style.display = 'block';
    }
}

// Main analysis function
function analyzeColumn() {
    if (!dataLoaded) {
        alert("Steel data is still loading. Please wait.");
        return;
    }
    
    // Get shape and material properties
    const astmSpec = document.getElementById('ASTMinput').value;
    const shapeDim = document.getElementById('dimA').value.toUpperCase();
    const shapeType = document.getElementById('shapeA').value + shapeDim;
    
    // Get material properties
    const material = astmData[astmSpec];
    if (!material) {
        alert(`Steel specification ${astmSpec} not found in database.`);
        return;
    }
    
    // Check if the shape exists in our database
    if (!wShapesData[shapeType]) {
        alert(`Shape ${shapeType} not found in database. Try another shape like W12X45.`);
        return;
    }
    
    // Get shape properties
    const shape = wShapesData[shapeType];
    
    // Get member length
    const lengthFt = parseFloat(document.getElementById('Lenght').value);
    if (isNaN(lengthFt) || lengthFt <= 0) {
        alert('Please enter a valid length.');
        return;
    }
    const lengthIn = lengthFt * 12;
    
    // Determine end conditions
    const topEnd = getEndCondition('top');
    const botEnd = getEndCondition('bot');
    
    // Calculate K factors for strong (x) and weak (y) axes
    const Kx = calculateKFactor(topEnd, botEnd);
    const Ky = calculateKFactor(topEnd, botEnd);
    
    // Calculate slenderness ratios for both axes
    const KLrx = (Kx * lengthIn) / shape.rx;
    const KLry = (Ky * lengthIn) / shape.ry;
    
    // Determine governing slenderness ratio
    const governingKLr = Math.max(KLrx, KLry);
    const governingAxis = (KLrx > KLry) ? 'X' : 'Y';
    
    // Populate the main table results
    document.getElementById('topL').textContent = lengthFt.toFixed(2);
    document.getElementById('topK').textContent = Kx.toFixed(2);
    document.getElementById('topr').textContent = shape.rx.toFixed(2);
    document.getElementById('topKLr').textContent = KLrx.toFixed(2);
    
    document.getElementById('botL').textContent = lengthFt.toFixed(2);
    document.getElementById('botK').textContent = Ky.toFixed(2);
    document.getElementById('botr').textContent = shape.ry.toFixed(2);
    document.getElementById('botKLr').textContent = KLry.toFixed(2);
    
    // Handle lateral supports if selected
    if (document.getElementById('support').checked) {
        const supportsAmount = parseInt(document.getElementById('supprtamount').value) || 0;
        
        // Create array to store support locations
        const supportLocations = [];
        
        // Get and validate support locations
        for (let i = 1; i <= supportsAmount && i <= 3; i++) {
            const locationInput = document.getElementById('location' + i);
            if (locationInput && locationInput.value) {
                const location = parseFloat(locationInput.value);
                if (!isNaN(location) && location > 0 && location < lengthFt) {
                    supportLocations.push(location);
                }
            }
        }
        
        // Sort support locations in ascending order
        supportLocations.sort((a, b) => a - b);
        
        // Calculate segment lengths (y1, y2, y3, y4, y5)
        const segments = [];
        
        // First segment (from start to first support)
        if (supportLocations.length > 0) {
            segments.push({
                start: 0,
                end: supportLocations[0],
                length: supportLocations[0]
            });
            
            // Middle segments (between supports)
            for (let i = 0; i < supportLocations.length - 1; i++) {
                segments.push({
                    start: supportLocations[i],
                    end: supportLocations[i + 1],
                    length: supportLocations[i + 1] - supportLocations[i]
                });
            }
            
            // Last segment (from last support to end)
            segments.push({
                start: supportLocations[supportLocations.length - 1],
                end: lengthFt,
                length: lengthFt - supportLocations[supportLocations.length - 1]
            });
        } else {
            // If no supports, just one segment for the full length
            segments.push({
                start: 0,
                end: lengthFt,
                length: lengthFt
            });
        }
        
        // Display segment information in the table
        for (let i = 0; i < segments.length && i < 5; i++) {
            const segmentRow = document.getElementById('y' + (i + 1));
            if (segmentRow) {
                segmentRow.style.display = 'table-row';
                
                const segLength = segments[i].length;
                const segK = Ky; // Using the same K factor for Y-axis
                
                document.getElementById('sup' + (i + 1) + 'L').textContent = segLength.toFixed(2);
                document.getElementById('sup' + (i + 1) + 'K').textContent = segK.toFixed(2);
                document.getElementById('sup' + (i + 1) + 'r').textContent = shape.ry.toFixed(2);
                document.getElementById('sup' + (i + 1) + 'KLr').textContent = 
                    (segK * segLength * 12 / shape.ry).toFixed(2);
            }
        }
        
        // Hide unused segment rows
        for (let i = segments.length + 1; i <= 5; i++) {
            const segmentRow = document.getElementById('y' + i);
            if (segmentRow) {
                segmentRow.style.display = 'none';
            }
        }
    } else {
        // No lateral supports
        // Display only one segment for the full length
        document.getElementById('y1').style.display = 'table-row';
        document.getElementById('sup1L').textContent = lengthFt.toFixed(2);
        document.getElementById('sup1K').textContent = Ky.toFixed(2);
        document.getElementById('sup1r').textContent = shape.ry.toFixed(2);
        document.getElementById('sup1KLr').textContent = KLry.toFixed(2);
        
        // Hide other segment rows
        for (let i = 2; i <= 5; i++) {
            const segmentRow = document.getElementById('y' + i);
            if (segmentRow) {
                segmentRow.style.display = 'none';
            }
        }
    }
    // Highlight governing row
    if (KLrx > KLry) {
        document.getElementById('X').style.backgroundColor = '#ffcccb';
        document.getElementById('Y').style.backgroundColor = '';
    } else {
        document.getElementById('X').style.backgroundColor = '';
        document.getElementById('Y').style.backgroundColor = '#ffcccb';
    }
    
    // Calculate Euler and AISC column strength
    const Fe = calculateEulerBuckling(governingKLr);
    const FcrAISC = calculateAISCStrength(material.Fy, governingKLr);
    
    // Calculate nominal strength
    const Pn = shape.A * FcrAISC;
    
    // Calculate LRFD and ASD design strength
    const phiPn = 0.9 * Pn; // LRFD design strength ( = 0.9)
    const PnOmega = Pn / 1.67; // ASD allowable strength ( = 1.67)
    
    // Check compactness criteria
    const webCompactness = checkWebCompactness(shape.htw, material.Fy);
    const flangeCompactness = checkFlangeCompactness(shape.bf / (2 * shape.tf), material.Fy);
    
    // Generate HTML output for the results
    const resultHTML = generateResultHTML(
        astmSpec, 
        material, 
        shapeType, 
        shape, 
        governingKLr, 
        governingAxis, 
        Fe,
        FcrAISC, 
        Pn,
        phiPn,
        PnOmega,
        webCompactness, 
        flangeCompactness
    );
    
    document.getElementById('ResultComp').innerHTML = resultHTML;
    
    // Generate the AISC column curve visualization
    generateColumnCurve(material.Fy, governingKLr, Fe, FcrAISC);
}

// Function to determine end condition based on selected radio button
function getEndCondition(position) {
    if (document.getElementById(position + 'fixed').checked) {
        return 'fixed';
    } else if (document.getElementById(position + 'pinned').checked) {
        return 'pinned';
    } else if (document.getElementById(position + 'free').checked) {
        return 'free';
    }
    return 'pinned'; // Default to pinned if nothing selected
}

// Function to get end condition by support ID
function getEndConditionById(supportId) {
    if (document.getElementById('fixed' + supportId.charAt(supportId.length - 1)).checked) {
        return 'fixed';
    } else if (document.getElementById('pinned' + supportId.charAt(supportId.length - 1)).checked) {
        return 'pinned';
    } else if (document.getElementById('Free' + supportId.charAt(supportId.length - 1)).checked) {
        return 'free';
    }
    return 'pinned'; // Default to pinned if nothing selected
}

// Calculate effective length factor K based on end conditions
function calculateKFactor(topEnd, botEnd) {
    // These values are simplified approximations
    if (topEnd === 'fixed' && botEnd === 'fixed') {
        return 0.65;
    } else if ((topEnd === 'fixed' && botEnd === 'pinned') || 
               (topEnd === 'pinned' && botEnd === 'fixed')) {
        return 0.80;
    } else if (topEnd === 'pinned' && botEnd === 'pinned') {
        return 1.0;
    } else if ((topEnd === 'fixed' && botEnd === 'free') || 
               (topEnd === 'free' && botEnd === 'fixed')) {
        return 2.0;
    } else {
        return 1.0; // Default
    }
}

// Calculate K factor for a segment based on support type
function getSegmentK(supportType) {
    if (supportType === 'fixed') {
        return 0.65;
    } else if (supportType === 'pinned') {
        return 1.0;
    } else {
        return 1.0; // Default
    }
}

// Calculate elastic buckling stress using Euler's formula
function calculateEulerBuckling(KLr) {
    return (Math.PI * Math.PI * E) / (KLr * KLr);
}

// Calculate column strength per AISC
function calculateAISCStrength(Fy, KLr) {
    // Calculate Euler buckling stress
    const Fe = calculateEulerBuckling(KLr);
    
    if (KLr <= 4.71 * Math.sqrt(E / Fy)) {
        // Inelastic buckling
        const Fcr = Math.pow(0.658, Fy/Fe) * Fy;
        return Fcr;
    } else {
        // Elastic buckling
        const Fcr = 0.877 * Fe;
        return Fcr;
    }
}

// Check web compactness
function checkWebCompactness(htwRatio, Fy) {
    const lambdaP = 1.49 * Math.sqrt(E / Fy);
    const lambdaR = 1.98 * Math.sqrt(E / Fy);
    
    if (htwRatio <= lambdaP) {
        return { status: "Compact", ratio: htwRatio, limit: lambdaP };
    } else if (htwRatio <= lambdaR) {
        return { status: "Non-compact", ratio: htwRatio, limit: lambdaR };
    } else {
        return { status: "Slender", ratio: htwRatio, limit: lambdaR };
    }
}

// Check flange compactness
function checkFlangeCompactness(bftfRatio, Fy) {
    const lambdaP = 0.38 * Math.sqrt(E / Fy);
    const lambdaR = 0.84 * Math.sqrt(E / Fy);
    
    if (bftfRatio <= lambdaP) {
        return { status: "Compact", ratio: bftfRatio, limit: lambdaP };
    } else if (bftfRatio <= lambdaR) {
        return { status: "Non-compact", ratio: bftfRatio, limit: lambdaR };
    } else {
        return { status: "Slender", ratio: bftfRatio, limit: lambdaR };
    }
}

// Generate HTML for results display
function generateResultHTML(astmSpec, material, shapeType, shape, governingKLr, governingAxis, 
                          Fe, Fcr, Pn, phiPn, PnOmega, webCompactness, flangeCompactness) {
    return `
        <h3>Column Analysis Results</h3>
        <h4>Material Properties (${astmSpec})</h4>
        <p>Yield Stress (Fy): ${material.Fy} ksi</p>
        <p>Ultimate Stress (Fu): ${material.Fu} ksi</p>
        
        <h4>Shape Properties (${shapeType})</h4>
        <p>Area: ${shape.A.toFixed(2)} in</p>
        <p>Depth: ${shape.d.toFixed(2)} in</p>
        <p>Web Thickness: ${shape.tw.toFixed(3)} in</p>
        <p>Flange Width: ${shape.bf.toFixed(2)} in</p>
        <p>Flange Thickness: ${shape.tf.toFixed(3)} in</p>
        <p>h/tw Ratio: ${shape.htw.toFixed(1)}</p>
        
        <h4>Compactness Check</h4>
        <p>Web: ${webCompactness.status} (h/tw = ${webCompactness.ratio.toFixed(1)}, Limit = ${webCompactness.limit.toFixed(1)})</p>
        <p>Flange: ${flangeCompactness.status} (bf/2tf = ${(shape.bf/(2*shape.tf)).toFixed(1)}, Limit = ${flangeCompactness.limit.toFixed(1)})</p>
        
        <h4>Column Strength</h4>
        <p>Governing Slenderness Ratio (KL/r): ${governingKLr.toFixed(2)} (${governingAxis}-axis)</p>
        <p>Elastic Buckling Stress (Fe): ${Fe.toFixed(2)} ksi</p>
        <p>Critical Stress (Fcr): ${Fcr.toFixed(2)} ksi</p>
        <p>Nominal Strength (Pn): ${Pn.toFixed(2)} kips</p>
        
        <h4>Design Strength</h4>
        <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
            <tr style="background-color: #f2f2f2;">
                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Design Method</th>
                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Factor</th>
                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Design Strength</th>
            </tr>
            <tr>
                <td style="padding: 8px; border: 1px solid #ddd;">LRFD (Pn)</td>
                <td style="padding: 8px; border: 1px solid #ddd;"> = 0.9</td>
                <td style="padding: 8px; border: 1px solid #ddd;">${phiPn.toFixed(2)} kips</td>
            </tr>
            <tr>
                <td style="padding: 8px; border: 1px solid #ddd;">ASD (Pn/)</td>
                <td style="padding: 8px; border: 1px solid #ddd;"> = 1.67</td>
                <td style="padding: 8px; border: 1px solid #ddd;">${PnOmega.toFixed(2)} kips</td>
            </tr>
        </table>
        
        <div id="columnCurveGraph" style="width: 100%; height: 300px;"></div>
    `;
}


// Function to generate AISC column curve visualization
function generateColumnCurve(Fy, actualKLr, actualFcr) {
    // Create canvas for visualization
    const canvas = document.createElement('canvas');
    canvas.width = 600;
    canvas.height = 400;
    canvas.style.width = '100%';
    canvas.style.height = '300px';
    
    const div = document.getElementById('columnCurveGraph');
    div.innerHTML = '';
    div.appendChild(canvas);
    
    const ctx = canvas.getContext('2d');
    
    // Calculate points for the column curve
    const points = [];
    const maxKLr = Math.max(200, actualKLr * 1.2);
    
    for (let KLr = 0; KLr <= maxKLr; KLr += 5) {
        const Fe = (Math.PI * Math.PI * E) / (KLr * KLr);
        let Fcr;
        
        if (KLr <= 4.71 * Math.sqrt(E / Fy)) {
            // Inelastic buckling
            Fcr = Math.pow(0.658, Fy/Fe) * Fy;
        } else {
            // Elastic buckling
            Fcr = 0.877 * Fe;
        }
        
        points.push({ x: KLr, y: Fcr });
    }
    
    // Draw the graph
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw axes
    ctx.beginPath();
    ctx.moveTo(50, 350);
    ctx.lineTo(550, 350);
    ctx.moveTo(50, 350);
    ctx.lineTo(50, 50);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Draw labels
    ctx.font = '12px Arial';
    ctx.fillStyle = '#000';
    ctx.fillText('KL/r', 300, 380);
    
    // Y-axis label
    ctx.save();
    ctx.translate(20, 200);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('Fcr (ksi)', 0, 0);
    ctx.restore();
    
    // Draw title
    ctx.font = '16px Arial';
    ctx.fillText('AISC Column Curve', 220, 30);
    
    // Scale factors
    const xScale = 500 / maxKLr;
    const yScale = 300 / Fy;
    
    // Draw the curve
    ctx.beginPath();
    ctx.moveTo(50 + points[0].x * xScale, 350 - points[0].y * yScale);
    
    for (let i = 1; i < points.length; i++) {
        ctx.lineTo(50 + points[i].x * xScale, 350 - points[i].y * yScale);
    }
    
    ctx.strokeStyle = '#0066cc';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Draw transition point (4.71(E/Fy))
    const transitionKLr = 4.71 * Math.sqrt(E / Fy);
    const transitionX = 50 + transitionKLr * xScale;
    
    ctx.beginPath();
    ctx.moveTo(transitionX, 350);
    ctx.lineTo(transitionX, 50);
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Add text for transition point
    ctx.font = '12px Arial';
    ctx.fillStyle = '#666';
    ctx.fillText(`Transition KL/r = ${transitionKLr.toFixed(1)}`, transitionX - 80, 40);
    
    // Draw the actual point on the curve
    ctx.beginPath();
    ctx.arc(50 + actualKLr * xScale, 350 - actualFcr * yScale, 6, 0, 2 * Math.PI);
    ctx.fillStyle = 'red';
    ctx.fill();
    
    // Add text for the actual point
    ctx.fillStyle = '#000';
    ctx.fillText(`Current: KL/r = ${actualKLr.toFixed(1)}, Fcr = ${actualFcr.toFixed(1)} ksi`, 
                 50 + actualKLr * xScale - 100, 350 - actualFcr * yScale - 15);
    
    // Add legend for AISC column curve regions
    ctx.font = '12px Arial';
    ctx.fillStyle = '#333';
    ctx.fillText('Inelastic Buckling', transitionX - 200, 70);
    ctx.fillText('Elastic Buckling', transitionX + 50, 70);
}

// Function to handle uploading actual ASTMSPEC.xlsx file
function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        
        // Process Sheet 1 - ASTM data
        const sheet1 = workbook.Sheets[workbook.SheetNames[0]];
        const steelData = XLSX.utils.sheet_to_json(sheet1);
        
        astmData = {};
        steelData.forEach(row => {
            if (row['Steel name']) {
                astmData[row['Steel name']] = {
                    Fy: row['Fy'] || 0,
                    Fu: row['Fu'] || 0
                };
            }
        });
        
        // Process Sheet 2 - W-shape data
        const sheet2 = workbook.Sheets[workbook.SheetNames[1]];
        const shapeData = XLSX.utils.sheet_to_json(sheet2);
        
        wShapesData = {};
        shapeData.forEach(row => {
            if (row['AISC_Manual_Label']) {
                wShapesData[row['AISC_Manual_Label']] = {
                    A: row['A'] || 0,
                    d: row['d'] || 0,
                    tw: row['tw'] || 0,
                    bf: row['bf'] || 0,
                    tf: row['tf'] || 0,
                    htw: row['h/tw'] || 0,
                    Ix: row['Ix'] || 0,
                    Zx: row['Zx'] || 0,
                    Sx: row['Sx'] || 0,
                    rx: row['rx'] || 0,
                    Iy: row['Iy'] || 0,
                    Zy: row['Zy'] || 0,
                    Sy: row['Sy'] || 0,
                    ry: row['ry'] || 0
                };
            }
        });
        
        dataLoaded = true;
        alert("Excel data loaded successfully!");
        
        // Update UI with available shapes
        updateShapeOptions();
    };
    
    reader.readAsArrayBuffer(file);
}

// Function to update the shape selection options based on loaded data
function updateShapeOptions() {
    const dimInput = document.getElementById('dimA');
    
    // Create a datalist for shape dimensions
    let datalist = document.getElementById('shape-dimensions');
    if (!datalist) {
        datalist = document.createElement('datalist');
        datalist.id = 'shape-dimensions';
        document.body.appendChild(datalist);
        
        // Connect the input to the datalist
        dimInput.setAttribute('list', 'shape-dimensions');
    }
    
    // Clear and populate datalist
    datalist.innerHTML = '';
    
    // Extract just the dimensions part from shape names (e.g., "12X45" from "W12X45")
    const dimensions = Object.keys(wShapesData)
        .map(key => key.substring(1)) // Remove the "W" prefix
        .filter((value, index, self) => self.indexOf(value) === index); // Unique values
    
    // Add options to datalist
    dimensions.forEach(dim => {
        const option = document.createElement('option');
        option.value = dim;
        datalist.appendChild(option);
    });
}



// Function to handle the visibility of the SupportA container
function handleSupportVisibility() {
    // Get the radio buttons and the SupportA container
    const supportRadio = document.getElementById('supportC');
    const noSupportRadio = document.getElementById('NosupportC');
    const supportContainer = document.getElementById('SupportC');
    
    // Show the SupportA container if the support radio is checked
    if (supportRadio.checked) {
      supportContainer.style.display = 'block';
    }
    // Hide the SupportA container if the Nosupport radio is checked
    else if (noSupportRadio.checked) {
      supportContainer.style.display = 'none';
    }
  }
  
 
// Function to handle the visibility of the SupportC container
function handleSupportVisibilityC() {
  // Get the radio buttons and the SupportC container
  const supportRadio = document.getElementById('supportC');
  const noSupportRadio = document.getElementById('NosupportC');
  const supportContainer = document.getElementById('SupportC');
  
  // Show the SupportC container if the support radio is checked
  if (supportRadio.checked) {
    supportContainer.style.display = 'block';
  }
  // Hide the SupportC container if the Nosupport radio is checked
  else if (noSupportRadio.checked) {
    supportContainer.style.display = 'none';
  }
}

// Add event listeners to both radio buttons
document.getElementById('supportC').addEventListener('change', handleSupportVisibilityC);
document.getElementById('NosupportC').addEventListener('change', handleSupportVisibilityC);

// Run the function once when the page loads to set the initial state
document.addEventListener('DOMContentLoaded', function() {
  // Check the initial state of the radio buttons and set visibility accordingly
  handleSupportVisibilityC();
});

document.addEventListener("DOMContentLoaded", function() {
    // Get references to DOM elements
    const noSupportRadio = document.getElementById("NosupportC");
    const withSupportRadio = document.getElementById("supportC");
    const supportCDiv = document.getElementById("SupportC");
    const supportAmountInput = document.getElementById("supprtamountC");
    const support1Div = document.getElementById("support1C");
    const support2Div = document.getElementById("support2C");
    const support3Div = document.getElementById("support3C");

    // Initially hide all support divs
    support1Div.style.display = "none";
    support2Div.style.display = "none";
    support3Div.style.display = "none";

    // Show/hide SupportC div based on radio button selection
    noSupportRadio.addEventListener("change", function() {
        if (this.checked) {
            supportCDiv.style.display = "none";
        }
    });

    withSupportRadio.addEventListener("change", function() {
        if (this.checked) {
            supportCDiv.style.display = "block";
            // When support is initially shown, update which support divs are visible
            updateSupportDivs();
        }
    });

    // Listen for changes to the support amount input
    supportAmountInput.addEventListener("input", updateSupportDivs);

    function updateSupportDivs() {
        const amount = parseInt(supportAmountInput.value) || 0;
        
        // Show/hide support divs based on amount
        support1Div.style.display = amount >= 1 ? "block" : "none";
        support2Div.style.display = amount >= 2 ? "block" : "none";
        support3Div.style.display = amount >= 3 ? "block" : "none";
    }

    // Initialize state based on initial values
    if (withSupportRadio.checked) {
        supportCDiv.style.display = "block";
        updateSupportDivs();
    } else {
        supportCDiv.style.display = "none";
    }
});

document.addEventListener("DOMContentLoaded", function() {
    // Add containers for both visualizations after the page loads
    const graphicalColumnContainer = document.querySelector('.GraphicalColumn');
   
    
    graphicalColumnContainer.innerHTML = `
        <div style="display: flex; flex-wrap: wrap; gap: 20px; margin-top: 20px;">
            <!-- Y-axis visualization (with lateral supports) -->
            <div class="visualization-container" style="flex: 1; min-width: 300px; height: 500px; border: 1px solid #ccc; position: relative; overflow: hidden;">
                <h3 style="text-align: center; margin: 5px 0;">Y-Axis Visualization (Lateral Supports)</h3>
                <div id="beam-visualization-y-c" style="width: 100%; height: 450px; position: relative;">
                    <!-- SVG will be inserted here -->
                </div>
            </div>
            
            <!-- X-axis visualization (without lateral supports) -->
            <div class="visualization-container" style="flex: 1; min-width: 300px; height: 500px; border: 1px solid #ccc; position: relative; overflow: hidden;">
                <h3 style="text-align: center; margin: 5px 0;">X-Axis Visualization (Full Length)</h3>
                <div id="beam-visualization-x-c" style="width: 100%; height: 450px; position: relative;">
                    <!-- SVG will be inserted here -->
                </div>
            </div>
        </div>
    `;
    

    // Get all the input elements we need to monitor
    const lengthInput = document.getElementById("LenghtDC");
    const supportRadio = document.getElementById("supportC");
    const noSupportRadio = document.getElementById("NosupportC");
    const supportAmountInput = document.getElementById("supprtamountC");
    const locationInputs = [
        document.getElementById("location1C"),
        document.getElementById("location2C"),
        document.getElementById("location3C")
    ];
    
    // Top support options
    const topFixed = document.getElementById("topfixedC");
    const topPinned = document.getElementById("toppinnedC");
    const topFree = document.getElementById("topfreeC");
    
    // Bottom support options
    const botFixed = document.getElementById("botfixedC");
    const botPinned = document.getElementById("botpinnedC");
    const botFree = document.getElementById("botfreeC");
    
    // Lateral support options
    const lateralSupportTypes = [
        {
            pinned: document.getElementById("pinned1C"),
            fixed: document.getElementById("fixed1C"),
            free: document.getElementById("Free1C")
        },
        {
            pinned: document.getElementById("pinned2C"),
            fixed: document.getElementById("fixed2C"),
            free: document.getElementById("Free2C")
        },
        {
            pinned: document.getElementById("pinned3C"),
            fixed: document.getElementById("fixed3C"),
            free: document.getElementById("Free3C")
        }
    ];

    // Design button
    

    // Initial drawing
    drawBeamColumns();

    // Add event listeners to all inputs that should trigger a redraw
    lengthInput.addEventListener("input", drawBeamColumns);
    supportRadio.addEventListener("change", drawBeamColumns);
    noSupportRadio.addEventListener("change", drawBeamColumns);
    supportAmountInput.addEventListener("input", drawBeamColumns);
    
    for (let i = 0; i < locationInputs.length; i++) {
        if (locationInputs[i]) {
            locationInputs[i].addEventListener("input", drawBeamColumns);
        }
    }
    
    // Top support options
    if (topFixed) topFixed.addEventListener("change", drawBeamColumns);
    if (topPinned) topPinned.addEventListener("change", drawBeamColumns);
    if (topFree) topFree.addEventListener("change", drawBeamColumns);
    
    // Bottom support options
    if (botFixed) botFixed.addEventListener("change", drawBeamColumns);
    if (botPinned) botPinned.addEventListener("change", drawBeamColumns);
    if (botFree) botFree.addEventListener("change", drawBeamColumns);
    
    // Lateral support options
    for (let i = 0; i < lateralSupportTypes.length; i++) {
        if (lateralSupportTypes[i].pinned) lateralSupportTypes[i].pinned.addEventListener("change", drawBeamColumns);
        if (lateralSupportTypes[i].fixed) lateralSupportTypes[i].fixed.addEventListener("change", drawBeamColumns);
        if (lateralSupportTypes[i].free) lateralSupportTypes[i].free.addEventListener("change", drawBeamColumns);
    }
    
    if (designButtonc) {
        designButtonc.addEventListener("click", drawBeamColumns);
    }

    function drawBeamColumns() {
        // Draw both visualizations
        drawYAxisBeam();
        drawXAxisBeam();
    }

    function drawYAxisBeam() {
        const beamVisualization = document.getElementById("beam-visualization-y-c");
        if (!beamVisualization) return;

        // Get the current values from the form
        const columnLength = parseFloat(lengthInput.value) || 16; // Default to 16 if not specified
        const hasLateralSupports = supportRadio && supportRadio.checked;
        const supportCount = hasLateralSupports ? parseInt(supportAmountInput.value) || 0 : 0;
        
        // Get support locations and sort them by position
        const supportLocations = [];
        if (hasLateralSupports) {
            for (let i = 0; i < supportCount && i < 3; i++) {
                if (locationInputs[i]) {
                    const location = parseFloat(locationInputs[i].value) || 0;
                    if (location > 0 && location < columnLength) {
                        supportLocations.push({
                            position: location,
                            type: lateralSupportTypes[i].fixed && lateralSupportTypes[i].fixed.checked ? "fixed" :
                                  lateralSupportTypes[i].pinned && lateralSupportTypes[i].pinned.checked ? "pinned" : "free",
                            index: i + 1
                        });
                    }
                }
            }
        }
        
        // Sort support locations by position
        supportLocations.sort((a, b) => a.position - b.position);
        
        // Get end supports
        const topSupport = topFixed && topFixed.checked ? "fixed" : 
                          topPinned && topPinned.checked ? "pinned" : "free";
        const botSupport = botFixed && botFixed.checked ? "fixed" : 
                          botPinned && botPinned.checked ? "pinned" : "free";

        // Calculate dimensions
        const svgWidth = beamVisualization.clientWidth;
        const svgHeight = beamVisualization.clientHeight;
        const margin = { top: 20, right: 40, bottom: 40, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        
        // Scale factors
        const yScale = height / columnLength;
        
        // Determine segment points (top, all supports, bottom)
        const segmentPoints = [0, ...supportLocations.map(s => s.position), columnLength];
        
        // Create the SVG
        const svg = `
            <svg width="${svgWidth}" height="${svgHeight}">
                <g transform="translate(${margin.left}, ${margin.top})">
                    <!-- Column shaft (W-shape) showing front and side view -->
                    <!-- Front view (Y-axis) -->
                    <path d="M ${width/2-15} 0 
                             L ${width/2-15} ${columnLength * yScale}
                             M ${width/2+15} 0
                             L ${width/2+15} ${columnLength * yScale}
                             M ${width/2-25} 0
                             L ${width/2+25} 0
                             M ${width/2-25} ${columnLength * yScale}
                             L ${width/2+25} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                    
                    <!-- "Y" label below the beam -->
                    <text x="${width/2}" y="${columnLength * yScale + 35}" 
                          text-anchor="middle" font-size="16" font-weight="bold">
                        Y
                    </text>
                    
                    <!-- Top support -->
                    ${renderSupport(width/2, 0, topSupport, "top")}
                    
                    <!-- Bottom support -->
                    ${renderSupport(width/2, columnLength * yScale, botSupport, "bottom")}
                    
                    <!-- Lateral supports -->
                    ${supportLocations.map(support => 
                        renderLateralSupport(width/2, support.position * yScale, support.type)
                    ).join('')}
                    
                    <!-- Column height label -->
                    <text x="${width/3  }" y="${columnLength * yScale / 2}" 
                          transform="rotate(360, ${width/2 + 40}, ${columnLength * yScale / 2})"
                          text-anchor="middle" dominant-baseline="middle" font-size="12">
                        ${columnLength}' Column Length
                    </text>
                    
                    <!-- Support location labels -->
                    ${supportLocations.map((support) => `
                        <text x="${width/2 - 40}" y="${support.position * yScale}"
                              text-anchor="end" dominant-baseline="middle" font-size="12">
                            Support ${support.index}: ${support.position}'
                        </text>
                    `).join('')}
                    
                    <!-- Segment labels (y1, y2, etc.) -->
                    ${segmentPoints.slice(0, -1).map((startPoint, i) => {
                        const endPoint = segmentPoints[i + 1];
                        const segmentLength = endPoint - startPoint;
                        const midPoint = (startPoint + endPoint) / 2;
                        
                        return `
                            <!-- y${i+1} segment label -->
                            <text x="${width/2 + 30}" y="${(startPoint + (segmentLength/2)) * yScale}"
                                  text-anchor="start" dominant-baseline="middle" font-size="14" fill="blue" font-weight="bold">
                                y${i+1} = ${segmentLength.toFixed(2)}'
                            </text>
                            
                            <!-- Segment marker lines -->
                            <line x1="${width/2 + 15}" y1="${startPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${startPoint * yScale}"
                                  stroke="blue" stroke-width="1" />
                            <line x1="${width/2 + 15}" y1="${endPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${endPoint * yScale}"
                                  stroke="blue" stroke-width="1" />
                            
                            <!-- Connecting line for segment -->
                            <line x1="${width/2 + 25}" y1="${startPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${endPoint * yScale}"
                                  stroke="blue" stroke-width="1" stroke-dasharray="4,2" />
                        `;
                    }).join('')}
                </g>
            </svg>
        `;
        
        beamVisualization.innerHTML = svg;
    }
    
    function drawXAxisBeam() {
        const beamVisualization = document.getElementById("beam-visualization-x-c");
        if (!beamVisualization) return;

        // Get the current values from the form
        const columnLength = parseFloat(lengthInput.value) || 16; // Default to 16 if not specified
        
        // Get end supports
        const topSupport = topFixed && topFixed.checked ? "fixed" : 
                          topPinned && topPinned.checked ? "pinned" : "free";
        const botSupport = botFixed && botFixed.checked ? "fixed" : 
                          botPinned && botPinned.checked ? "pinned" : "free";

        // Calculate dimensions
        const svgWidth = beamVisualization.clientWidth;
        const svgHeight = beamVisualization.clientHeight;
        const margin = { top: 20, right: 40, bottom: 40, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        
        // Scale factors
        const yScale = height / columnLength;
        
        // Create the SVG - showing the beam from the side (X-axis view)
        const svg = `
            <svg width="${svgWidth}" height="${svgHeight}">
                <g transform="translate(${margin.left}, ${margin.top})">
                    <!-- Column shaft (W-shape) - side view (X-axis) -->
                    <path d="M ${width/2-25} 0 
                             L ${width/2-25} ${columnLength * yScale}
                             M ${width/2+25} 0
                             L ${width/2+25} ${columnLength * yScale}
                             M ${width/2-25} 0
                             L ${width/2+25} 0
                             M ${width/2-25} ${columnLength * yScale}
                             L ${width/2+25} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                          
                    <!-- Web of the W-shape (showing flange depth) -->
                    <path d="M ${width/2-10} 0 
                             L ${width/2-10} ${columnLength * yScale}
                             M ${width/2+10} 0
                             L ${width/2+10} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                    
                    <!-- "X" label below the beam -->
                    <text x="${width/2}" y="${columnLength * yScale + 35}" 
                          text-anchor="middle" font-size="16" font-weight="bold">
                        X
                    </text>
                    
                    <!-- Top support -->
                    ${renderSupport(width/2, 0, topSupport, "top")}
                    
                    <!-- Bottom support -->
                    ${renderSupport(width/2, columnLength * yScale, botSupport, "bottom")}
                    
                    <!-- Full column length label -->
                    <text x="${width/3 }" y="${columnLength * yScale / 2}" 
                          transform="rotate(360, ${width/2 + 40}, ${columnLength * yScale / 2})"
                          text-anchor="middle" dominant-baseline="middle" font-size="12">
                        ${columnLength}' Column Length
                    </text>
                    
                    <!-- Main segment label for X-axis view -->
                    <text x="${width/2 + 30}" y="${columnLength * yScale / 2}"
                          text-anchor="start" dominant-baseline="middle" font-size="14" fill="blue" font-weight="bold">
                        y1 = ${columnLength.toFixed(2)}'
                    </text>
                    
                    <!-- Segment marker lines -->
                    <line x1="${width/2 + 25}" y1="0" 
                          x2="${width/2 + 35}" y2="0"
                          stroke="blue" stroke-width="1" />
                    <line x1="${width/2 + 25}" y1="${columnLength * yScale}" 
                          x2="${width/2 + 35}" y2="${columnLength * yScale}"
                          stroke="blue" stroke-width="1" />
                    
                    <!-- Connecting line for segment -->
                    <line x1="${width/2 + 35}" y1="0" 
                          x2="${width/2 + 35}" y2="${columnLength * yScale}"
                          stroke="blue" stroke-width="1" stroke-dasharray="4,2" />
                </g>
            </svg>
        `;
        
        beamVisualization.innerHTML = svg;
    }
    
    function renderSupport(x, y, type, position) {
        if (type === "fixed") {
            // Fixed support (triangle with hatching)
            const direction = position === "top" ? -1 : 1;
            return `
                <path d="M ${x-30} ${y + (direction * 10)} 
                         L ${x+30} ${y + (direction * 10)}
                         L ${x} ${y}"
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching lines for fixed support -->
                ${Array.from({length: 7}, (_, i) => 
                    `<line x1="${x-25 + i*10}" y1="${y + (direction * 10)}" 
                           x2="${x-25 + i*10}" y2="${y + (direction * 5)}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
            `;
        } else if (type === "pinned") {
            // Pinned support (triangle)
            const direction = position === "top" ? -1 : 1;
            return `
                <path d="M ${x-30} ${y + (direction * 10)} 
                         L ${x+30} ${y + (direction * 10)}
                         L ${x} ${y}"
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Circles to represent pins -->
                <circle cx="${x}" cy="${y}" r="3" fill="black" />
            `;
        } else { // free
            // Free end (nothing)
            return '';
        }
    }
    
    function renderLateralSupport(x, y, type) {
        if (type === "fixed") {
            // Fixed lateral support (square block with hatching)
            return `
                <rect x="${x+20}" y="${y-10}" width="20" height="20" 
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching for fixed support -->
                ${Array.from({length: 4}, (_, i) => 
                    `<line x1="${x+20}" y1="${y-10 + i*5}" 
                           x2="${x+40}" y2="${y-10 + i*5}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
                <!-- Line connecting to column -->
                <line x1="${x+15}" y1="${y}" x2="${x+20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                
                <!-- Left side support - mirror image -->
                <rect x="${x-40}" y="${y-10}" width="20" height="20" 
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching for fixed support -->
                ${Array.from({length: 4}, (_, i) => 
                    `<line x1="${x-40}" y1="${y-10 + i*5}" 
                           x2="${x-20}" y2="${y-10 + i*5}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
                <!-- Line connecting to column -->
                <line x1="${x-15}" y1="${y}" x2="${x-20}" y2="${y}"
                      stroke="black" stroke-width="2" />
            `;
        } else if (type === "pinned") {
            // Pinned lateral support (roller)
            return `
                <!-- Right side -->
                <circle cx="${x+30}" cy="${y}" r="10" 
                        stroke="black" stroke-width="2" fill="none" />
                <!-- Line connecting to column -->
                <line x1="${x+15}" y1="${y}" x2="${x+20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                <!-- Small circle for pin -->
                <circle cx="${x+20}" cy="${y}" r="3" fill="black" />
                
                <!-- Left side - mirror image -->
                <circle cx="${x-30}" cy="${y}" r="10" 
                        stroke="black" stroke-width="2" fill="none" />
                <!-- Line connecting to column -->
                <line x1="${x-15}" y1="${y}" x2="${x-20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                <!-- Small circle for pin -->
                <circle cx="${x-20}" cy="${y}" r="3" fill="black" />
            `;
        } else { // free
            // Free lateral support (just a line to indicate position)
            return `
                <line x1="${x-40}" y1="${y}" x2="${x+40}" y2="${y}"
                      stroke="blue" stroke-width="1" stroke-dasharray="5,5" />
            `;
        }
    }
});

// Column Load Capacity Calculator - Fixed Version
document.addEventListener("DOMContentLoaded", function() {
    // Initialize the application with error handling
    initializeColumnCalculator();
});

// Main initialization function
function initializeColumnCalculator() {
    try {
        console.log("Initializing Column Load Capacity Calculator...");
        
        // Get references to input elements with error checking
        const designButton = getRequiredElement("DesignC", "Design button");
        const astmSelect = getRequiredElement("ASTMinputC", "ASTM specification selector");
        const designMethodSelect = getRequiredElement("designMethod", "Design method selector");
        const deadLoadInput = getRequiredElement("DeadLoad", "Dead load input");
        const liveLoadInput = getRequiredElement("LiveLoad", "Live load input");
        const lengthInput = getRequiredElement("LenghtDC", "Column length input");
        
        // Get references to support options
        const topFixed = document.getElementById("topfixedC");
        const topPinned = document.getElementById("toppinnedC");
        const topFree = document.getElementById("topfreeC");
        const botFixed = document.getElementById("botfixedC");
        const botPinned = document.getElementById("botpinnedC");
        const botFree = document.getElementById("botfreeC");
        const noSupport = document.getElementById("NosupportC");
        const withSupport = document.getElementById("supportC");
        const supportAmountInput = document.getElementById("supprtamountC");
        
        // Get references to lateral support options
        const lateralSupportTypes = [
            {
                fixed: document.getElementById("fixed1C"),
                pinned: document.getElementById("pinned1C"),
                free: document.getElementById("Free1C"),
                location: document.getElementById("location1C")
            },
            {
                fixed: document.getElementById("fixed2C"),
                pinned: document.getElementById("pinned2C"),
                free: document.getElementById("Free2C"),
                location: document.getElementById("location2C")
            },
            {
                fixed: document.getElementById("fixed3C"),
                pinned: document.getElementById("pinned3C"),
                free: document.getElementById("Free3C"),
                location: document.getElementById("location3C")
            }
        ];
        
        // Set up event listeners
        setupEventListeners(designButton, noSupport, withSupport);
        
        console.log("Column Calculator initialized successfully");
    } catch (error) {
        console.error("Error initializing Column Calculator:", error);
        displayErrorMessage("Failed to initialize the column calculator. Please check console for details.");
    }
}

// Helper function to get required DOM elements
function getRequiredElement(id, description) {
    const element = document.getElementById(id);
    if (!element) {
        throw new Error(`Required ${description} (ID: ${id}) not found in document`);
    }
    return element;
}

// Function to set up event listeners
function setupEventListeners(designButton, noSupport, withSupport) {
    // Add event listener to design button
    if (designButton) {
        designButton.addEventListener("click", performDesign);
        console.log("Design button event listener attached");
    } else {
        console.warn("Design button not found, calculation functionality will be limited");
    }
    
    // Add event listeners to support radio buttons
    if (noSupport) {
        noSupport.addEventListener("change", handleSupportVisibilityC);
    }
    if (withSupport) {
        withSupport.addEventListener("change", handleSupportVisibilityC);
    }
    
    // Call support visibility handler to set initial state
    handleSupportVisibilityC();
}

// Display error message to user
function displayErrorMessage(message) {
    // Create error message element
    const errorDiv = document.createElement("div");
    errorDiv.className = "error-message";
    errorDiv.style.color = "red";
    errorDiv.style.padding = "10px";
    errorDiv.style.marginBottom = "10px";
    errorDiv.style.backgroundColor = "#ffeeee";
    errorDiv.style.border = "1px solid red";
    errorDiv.style.borderRadius = "5px";
    errorDiv.textContent = message;
    
    // Find a good place to display it
    const resultDiv = document.querySelector(".Result123");
    if (resultDiv) {
        resultDiv.prepend(errorDiv);
    } else {
        // If result div not found, insert at beginning of body
        const body = document.querySelector("body");
        if (body && body.firstChild) {
            body.insertBefore(errorDiv, body.firstChild);
        }
    }
}

// Handle lateral support visibility
function handleSupportVisibilityC() {
    try {
        const supportCDiv = document.getElementById("SupportC");
        const withSupport = document.getElementById("supportC");
        
        if (supportCDiv) {
            if (withSupport && withSupport.checked) {
                supportCDiv.style.display = "block";
            } else {
                supportCDiv.style.display = "none";
            }
        } else {
            console.warn("Support div container not found");
        }
    } catch (error) {
        console.error("Error handling support visibility:", error);
    }
}

// Database of W-shapes
const wShapeDatabase = {
    "W14": [
        ["W14X730", 730, 215, 22.4, 1.88, 17.9, 3.07, 4, 1.5, 7.5, 9.80, 5.81, 1830, 838, 1550, 546, 6.29, 16.2, 2590, 98800, 205, 7720, 545, 1.88, 273, 633, 5500, 3700],
        ["W14X605", 605, 178, 21.6, 1.56, 17.4, 2.59, 3.5, 1.5, 7.5, 9.43, 5.64, 1460, 675, 1240, 441, 6.10, 16.4, 1470, 73400, 169, 6220, 437, 1.56, 212, 483, 4600, 3100],
        ["W14X500", 500, 147, 20.7, 1.31, 16.9, 2.19, 3, 1.5, 7.5, 9.09, 5.49, 1170, 545, 991, 356, 5.94, 16.3, 887, 56000, 142, 4960, 351, 1.31, 169, 379, 3800, 2500],
        ["W14X398", 398, 117, 19.7, 1.06, 16.5, 1.77, 2.5, 1.5, 7.5, 8.75, 5.38, 901, 431, 763, 279, 5.82, 16.2, 456, 42000, 116, 3820, 269, 1.06, 134, 297, 3000, 2000],
        ["W14X283", 283, 83.3, 18.0, 0.938, 15.9, 1.56, 2.25, 1, 6, 8.22, 5.16, 613, 302, 515, 195, 5.55, 14.9, 184, 26200, 84.7, 2570, 196, 0.938, 92.5, 194, 2100, 1400],
        ["W14X211", 211, 62.0, 16.5, 0.75, 15.6, 1.31, 2, 1, 6, 7.83, 5.06, 445, 227, 373, 146, 5.43, 13.9, 91.7, 18000, 65.1, 1870, 146, 0.75, 69.1, 144, 1600, 1050]
    ],
    "W12": [
        ["W12X336", 336, 98.8, 16.8, 1.09, 13.4, 1.94, 2.5, 1, 5.5, 7.17, 4.22, 674, 291, 564, 187, 4.64, 12.9, 175, 14600, 75.8, 2250, 187, 1.09, 93.7, 245, 2500, 1700],
        ["W12X279", 279, 82.0, 16.1, 0.938, 13.1, 1.66, 2.25, 1, 5.5, 6.98, 4.14, 543, 237, 454, 152, 4.54, 12.8, 110, 11500, 65.2, 1810, 156, 0.938, 75.9, 197, 2100, 1400],
        ["W12X230", 230, 67.7, 15.4, 0.812, 12.8, 1.44, 2, 1, 5.5, 6.83, 4.08, 435, 193, 362, 124, 4.47, 12.5, 68.0, 8950, 55.4, 1450, 125, 0.812, 62.1, 159, 1700, 1150],
        ["W12X190", 190, 55.8, 14.7, 0.75, 12.5, 1.25, 1.75, 0.75, 5.5, 6.65, 4.01, 348, 157, 289, 101, 4.36, 12.2, 42.4, 6780, 47.3, 1160, 101, 0.75, 50.5, 128, 1400, 950],
        ["W12X152", 152, 44.7, 14.0, 0.625, 12.2, 1.06, 1.5, 0.75, 5.5, 6.49, 3.95, 275, 125, 229, 80.7, 4.28, 11.9, 24.5, 5260, 39.7, 914, 80.6, 0.625, 40.3, 102, 1150, 750],
        ["W12X120", 120, 35.3, 13.4, 0.55, 12.0, 0.9, 1.25, 0.75, 5.5, 6.41, 3.9, 214, 99.3, 177, 63.8, 4.21, 11.6, 15.1, 4000, 32.8, 710, 63.7, 0.55, 31.9, 80.4, 900, 600]
    ],
    "W10": [
        ["W10X112", 112, 33.0, 11.4, 0.755, 10.4, 1.25, 1.75, 0.75, 5.5, 4.98, 3.03, 170, 78.9, 146, 60.0, 3.43, 8.89, 11.5, 1660, 28.3, 583, 60.0, 0.755, 30.0, 66.5, 850, 550],
        ["W10X100", 100, 29.4, 11.1, 0.68, 10.3, 1.12, 1.5, 0.75, 5.5, 4.91, 3.01, 150, 77.7, 129, 53.1, 3.39, 8.86, 8.36, 1450, 28.9, 518, 53.0, 0.68, 26.5, 58.6, 750, 500],
        ["W10X88", 88, 25.9, 10.8, 0.605, 10.1, 0.99, 1.25, 0.75, 5.5, 4.85, 2.99, 131, 68.0, 112, 46.3, 3.36, 8.83, 5.95, 1260, 26.1, 449, 46.3, 0.605, 23.2, 51.0, 650, 450],
        ["W10X77", 77, 22.6, 10.6, 0.53, 10.1, 0.87, 1.25, 0.75, 5.5, 4.83, 2.98, 114, 59.6, 97.7, 40.5, 3.35, 8.86, 4.06, 1100, 23.2, 391, 40.5, 0.53, 20.3, 44.4, 600, 400],
        ["W10X68", 68, 20.0, 10.4, 0.47, 10.0, 0.77, 1, 0.75, 5.5, 4.82, 2.97, 101, 52.6, 85.9, 35.7, 3.33, 8.86, 2.87, 970, 20.7, 345, 35.7, 0.47, 17.9, 39.0, 500, 350],
        ["W10X60", 60, 17.6, 10.2, 0.42, 10.0, 0.68, 1, 0.75, 5.5, 4.82, 2.97, 88.7, 46.4, 75.7, 31.3, 3.32, 8.84, 2.00, 844, 18.5, 303, 31.3, 0.42, 15.7, 34.2, 450, 300]
    ],
    "W8": [
        ["W8X67", 67, 19.7, 9.0, 0.57, 8.28, 0.935, 1.25, 0.75, 4.5, 3.81, 2.14, 82.8, 39.6, 70.4, 26.7, 2.48, 7.13, 3.71, 386, 17.3, 282, 26.7, 0.57, 13.3, 30.6, 500, 350],
        ["W8X58", 58, 17.1, 8.75, 0.51, 8.22, 0.81, 1, 0.75, 4.5, 3.76, 2.12, 70.7, 33.8, 60.0, 22.8, 2.45, 7.13, 2.45, 325, 15.1, 240, 22.8, 0.51, 11.4, 26.0, 450, 300],
        ["W8X48", 48, 14.1, 8.5, 0.4, 8.11, 0.685, 1, 0.75, 4.5, 3.74, 2.11, 58.1, 27.9, 49.0, 18.7, 2.43, 7.13, 1.41, 269, 12.5, 196, 18.7, 0.4, 9.38, 21.4, 350, 250],
        ["W8X40", 40, 11.7, 8.25, 0.36, 8.07, 0.56, 0.75, 0.75, 4.5, 3.7, 2.08, 47.3, 22.5, 39.8, 15.2, 2.39, 7.13, 0.794, 213, 10.5, 159, 15.2, 0.36, 7.59, 17.4, 300, 200],
        ["W8X35", 35, 10.3, 8.12, 0.31, 8.02, 0.495, 0.75, 0.75, 4.5, 3.69, 2.08, 41.3, 19.7, 34.7, 13.3, 2.38, 7.13, 0.536, 185, 9.27, 139, 13.3, 0.31, 6.66, 15.2, 250, 170],
        ["W8X31", 31, 9.13, 8.0, 0.285, 8.0, 0.435, 0.75, 0.75, 4.5, 3.67, 2.08, 36.1, 17.3, 30.4, 11.6, 2.37, 7.13, 0.363, 160, 8.21, 122, 11.6, 0.285, 5.83, 13.2, 230, 150]
    ]
};

// ASTM Steel specification properties
const astmSpecs = {
    "A36": { Fy: 36, Fu: 58, E: 29000 },
    "A572Gr.42": { Fy: 42, Fu: 60, E: 29000 },
    "A572Gr.50": { Fy: 50, Fu: 65, E: 29000 },
    "A572Gr.55": { Fy: 55, Fu: 70, E: 29000 },
    "A572Gr.60": { Fy: 60, Fu: 75, E: 29000 },
    "A572Gr.65": { Fy: 65, Fu: 80, E: 29000 },
    "A588Gr.42": { Fy: 42, Fu: 63, E: 29000 },
    "A588Gr.46": { Fy: 46, Fu: 67, E: 29000 },
    "A588Gr.50": { Fy: 50, Fu: 70, E: 29000 },
    "A687": { Fy: 50, Fu: 70, E: 29000 },
    "A992": { Fy: 50, Fu: 65, E: 29000 }
};

// Main design function
function performDesign() {
    try {
        console.log("Performing column design calculation...");
        
        // Get required DOM elements
        const astmSelect = getRequiredElement("ASTMinputC", "ASTM specification selector");
        const designMethodSelect = getRequiredElement("designMethod", "Design method selector");
        const deadLoadInput = getRequiredElement("DeadLoad", "Dead load input");
        const liveLoadInput = getRequiredElement("LiveLoad", "Live load input");
        const lengthInput = getRequiredElement("LenghtDC", "Column length input");
        
        // Get input values
        const astmSpec = astmSelect.value;
        const designMethod = designMethodSelect.value;
        const deadLoad = parseFloat(deadLoadInput.value) || 0;
        const liveLoad = parseFloat(liveLoadInput.value) || 0;
        const columnLength = parseFloat(lengthInput.value) || 0;
        
        // Check if inputs are valid
        if (columnLength <= 0) {
            throw new Error("Column length must be greater than zero");
        }
        
        // Get end support conditions
        const topFixed = document.getElementById("topfixedC");
        const topPinned = document.getElementById("toppinnedC");
        const topFree = document.getElementById("topfreeC");
        const botFixed = document.getElementById("botfixedC");
        const botPinned = document.getElementById("botpinnedC");
        const botFree = document.getElementById("botfreeC");
        
        const topSupportType = topFixed && topFixed.checked ? "fixed" : 
                              topPinned && topPinned.checked ? "pinned" : "free";
        const botSupportType = botFixed && botFixed.checked ? "fixed" : 
                              botPinned && botPinned.checked ? "pinned" : "free";
        
        // Get lateral support information
        const noSupport = document.getElementById("NosupportC");
        const withSupport = document.getElementById("supportC");
        const supportAmountInput = document.getElementById("supprtamountC");
        
        const hasLateralSupports = withSupport && withSupport.checked;
        const supportCount = hasLateralSupports ? parseInt(supportAmountInput.value) || 0 : 0;
        
        // Get lateral support locations and types
        const lateralSupports = [];
        if (hasLateralSupports) {
            for (let i = 0; i < supportCount && i < 3; i++) {
                const fixedElement = document.getElementById(`fixed${i+1}C`);
                const pinnedElement = document.getElementById(`pinned${i+1}C`);
                const locationElement = document.getElementById(`location${i+1}C`);
                
                if (locationElement) {
                    const location = parseFloat(locationElement.value) || 0;
                    const type = fixedElement && fixedElement.checked ? "fixed" :
                                pinnedElement && pinnedElement.checked ? "pinned" : "free";
                    
                    if (location > 0 && location < columnLength) {
                        lateralSupports.push({
                            position: location,
                            type: type
                        });
                    }
                }
            }
        }
        
        // Sort lateral supports by position
        lateralSupports.sort((a, b) => a.position - b.position);
        
        // Calculate effective length factors
        const { Kx, Ky, segmentsY } = calculateEffectiveLengthFactors(
            columnLength, 
            topSupportType, 
            botSupportType, 
            lateralSupports
        );
        
        // Calculate effective lengths
        const Klx = Kx * columnLength * 12; // Convert to inches
        const Kly = Ky * columnLength * 12; // Convert to inches
        
        // Determine governing effective length
        const governingKl = Math.max(Klx, Kly);
        const isYGoverning = Kly >= Klx;
        
        // Calculate required capacity
        const totalLoad = calculateTotalLoad(deadLoad, liveLoad, designMethod);
        
        // Find suitable W-shapes
        const suitableShapes = findSuitableShapes(
            governingKl, 
            totalLoad, 
            designMethod, 
            wShapeDatabase,
            astmSpec
        );
        
        // Display results
        displayResults(
            suitableShapes, 
            Klx, 
            Kly, 
            isYGoverning, 
            totalLoad, 
            astmSpec, 
            designMethod, 
            segmentsY
        );
        
        console.log("Design calculation completed successfully");
    } catch (error) {
        console.error("Error in design calculation:", error);
        displayErrorMessage(`Design calculation error: ${error.message}`);
    }
}

// Calculate effective length factors based on support conditions
function calculateEffectiveLengthFactors(length, topSupport, botSupport, lateralSupports) {
    // Default K factors for different end conditions
    const endConditionFactors = {
        'fixed-fixed': 0.5,
        'fixed-pinned': 0.7,
        'fixed-free': 2.0,
        'pinned-pinned': 1.0,
        'pinned-fixed': 0.7,
        'pinned-free': 2.0,
        'free-fixed': 2.0,
        'free-pinned': 2.0,
        'free-free': 10.0 // Effectively unstable
    };
    
    // For X-axis: we only consider end supports
    const endConditionX = `${topSupport}-${botSupport}`;
    const Kx = endConditionFactors[endConditionX] || 1.0; // Default to 1.0 if condition not found
    
    // For Y-axis: consider both end supports and lateral bracing
    let Ky = Kx; // Start with the same factor as X-axis
    
    // If we have lateral supports, we need to consider their effect
    const segmentsY = [];
    
    if (lateralSupports.length > 0) {
        // Create segments based on supports
        let startPoint = 0;
        let previousType = topSupport;
        
        // Process each lateral support
        for (const support of lateralSupports) {
            const segmentLength = support.position - startPoint;
            const endCondition = `${previousType}-${support.type}`;
            const segmentK = endConditionFactors[endCondition] || 1.0;
            
            segmentsY.push({
                startPoint: startPoint,
                endPoint: support.position,
                length: segmentLength,
                K: segmentK
            });
            
            startPoint = support.position;
            previousType = support.type;
        }
        
        // Add final segment to bottom
        const finalSegmentLength = length - startPoint;
        const finalEndCondition = `${previousType}-${botSupport}`;
        const finalSegmentK = endConditionFactors[finalEndCondition] || 1.0;
        
        segmentsY.push({
            startPoint: startPoint,
            endPoint: length,
            length: finalSegmentLength,
            K: finalSegmentK
        });
        
        // Find the maximum effective length factor among segments
        let maxSegmentKL = 0;
        for (const segment of segmentsY) {
            const segmentKL = segment.K * segment.length;
            if (segmentKL > maxSegmentKL) {
                maxSegmentKL = segmentKL;
            }
        }
        
        // Calculate the overall effective length factor for Y-axis
        Ky = maxSegmentKL / length;
    }
    
    return { Kx, Ky, segmentsY };
}

// Calculate total load based on design method
function calculateTotalLoad(deadLoad, liveLoad, designMethod) {
    if (designMethod === "LRFD") {
        // LRFD load combinations
        return 1.2 * deadLoad + 1.6 * liveLoad;
    } else {
        // ASD load combinations
        return deadLoad + liveLoad;
    }
}


</script>

</body>
</html>