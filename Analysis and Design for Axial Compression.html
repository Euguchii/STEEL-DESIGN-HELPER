<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Principle of Steel  Design</title>
    <link rel="stylesheet" href="style.css">
   
</head>
<body>
    <header>
        <div class="header"><b>STEEL DESIGN HELPER</b></div>
    </header>

    <nav class="navbar">
        <div class="ADcon">
            <a class="con" id="0" href="index.html">|HOME|</a>
            <a class="con" id="1" href="Analysis and Design for Axial Tension.html">|Analysis and Design for Axial Tension|</a>
            <a class="con" class="active" id="active" href="Analysis and Design for Axial Compression.html">|Analysis and Design for Axial Compression|</a>
            <a class="con" id="3" href="Analysis and Design of Members for Bending.html">|Analysis and Design of Members for Bending|</a>
            <a class="con" id="4" href="Shear Strength of Structural Member.html">|Shear Strength of Structural Member|</a>
             </div>
            </nav>

<div class="FINALCONTAINER">
    <div class="HeaderforCompression">
        <H1 style="display: block;">
            ANALYSIS FOR COMPRESSION MEMBER
        </H1>
        
    </div>
    <div class="COMPRESSIONA">
        <div class="CalcComp">
            <div class="ANALYSISINPUT">
                <H3>STEEL CHARACTERISTIC</H3>
                <div id="ASTM">
                    <label id="ASTMI">ASTM  Specification:</label>
                    <select name="ASTMinput" id="ASTMinput">
                        <option value="A36">A36</option>
                        <option value="A572Gr.42">A572 Gr. 42</option>
                        <option value="A572Gr.50">A572 Gr. 50</option>
                        <option value="A572Gr.55">A572 Gr. 55</option>
                        <option value="A572Gr.60">A572 Gr. 60</option>
                        <option value="A572Gr.65">A572 Gr. 65</option>
                        <option value="A588Gr.42">A588 Gr. 42</option>
                        <option value="A588Gr.46">A588 Gr. 46</option>
                        <option value="A588Gr.50">A588 Gr. 50</option>
                        <option value="A687">A687</option>
                        <option value="A992">A992</option>
                    </select>
                    

                    

                </div>
                <div id="DataInputs">
                    <label>Shape:</label>
                            <select id="shapeA">
                                <option value="W">W</option>
                            </select>
                            <label>Dimension:</label>
                            <input type="text" id="dimA" placeholder="12X45" required size="10">
                </div>
                <div>
                    <label for="lenght">Lenght:</label>
                    <input id="Lenght" size="10" placeholder="ft">
                </div>
                <div>
                    <h3>TOP-BOT END</h3>
                    <div>
                        <label><B>TOP</B></label><br>
                    <label>Fixed:</label>
                    <input type="radio" name="top" id="topfixed"><br>
                    <label>Pinned:</label>
                    <input type="radio" name="top" id="toppinned"><br>
                    <label>Free:</label>
                    <input type="radio" name="top" id="topfree"><br>
                    </div>
                    <div>
                        <label><B>BOT</B></label><br>
                    <label>Fixed:</label>
                    <input type="radio" name="bot" id="botfixed"><br>
                    <label>Pinned:</label>
                    <input type="radio" name="bot" id="botpinned"><br>
                    <label>Free:</label>
                    <input type="radio" name="bot" id="botfree"><br>
                    </div>
                </div>

                <div>
                <H3>LATERAL SUPPORTS OPTION</H3>
                <label for="load">No Support</label>
                    <input type="radio" name="pinned" id="Nosupport">
                    <label for="load">With Lateral Support</label>
                    <input type="radio" name="pinned" id="support">
                    
                </div>
                <div id="SupportA" class="SupportA" style="display: none;">
                    <h3>Lateral Support</h3>
                    <label>Amount of supports:</label>
                    <input type="number" id="supprtamount" placeholder="0" size="1" max="3" min="0" step="1">

                    <div id="support1">
                    <p><b>Support 1</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support1" id="pinned1">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support1" id="fixed1">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support1" id="Free1"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location1" placeholder="ft" size="1" >
                    </div>
                    <div id="support2">
                        <p><b>Support 2</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support2" id="pinned2">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support2" id="fixed2">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support2" id="Free2"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location2" placeholder="ft" size="1" >
                    </div>
                    <div id="support3">
                        <p><b>Support 3</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support3" id="pinned3">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support3" id="fixed3">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support3" id="Free3"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location3" placeholder="ft" size="1" >
            
                    </div>
                    
                
                    
                    
                        
                </div>
                <button id="calculate" class="AnalyzeC">Analyze</button>
            </div>
            <div class="INTERACTIVECOLUMN"> 
                    
            </div>
        </div>
        <div class="RESULTSCOMPRESSION">
            <div class="TableR">
                <h3></h3>
                <table>
                    <thead>
                        <tr>
                            <th>Element</th>
                            <th>Lenght</th>
                            <th>K</th>
                            <th>r</th>
                            <th>K/Lr</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr id="X">
                            <td>X</td>
                            <td id="topL"></td>
                            <td id="topK"></td>
                            <td id="topr"></td>
                            <td id="topKLr"></td>
                        </tr>
                        <tr id="Y">
                            <td>Y</td>
                            <td id="botL"></td>
                            <td id="botK"></td>
                            <td id="botr"></td>
                            <td id="botKLr"></td>
                        </tr> 
                        <tr id="y1">
                            <td>Y1</td>
                            <td id="sup1L"></td>
                            <td id="sup1K"></td>
                            <td id="sup1r"></td>
                            <td id="sup1KLr"></td>
                        </tr>
                        <tr id="y2">
                            <td>Y2</td>
                            <td id="sup2L"></td>
                            <td id="sup2K"></td>
                            <td id="sup2r"></td>
                            <td id="sup2KLr"></td>
                        </tr>
                        <tr id="y3">
                            <td>Y3</td>
                            <td id="sup3L"></td>
                            <td id="sup3K"></td>
                            <td id="sup3r"></td>
                            <td id="sup3KLr"></td> 
                        </tr>
                        <tr id="y4">
                            <td>Y4</td>
                            <td id="sup4L"></td>
                            <td id="sup4K"></td>
                            <td id="sup4r"></td>
                            <td id="sup4KLr"></td>
                        </tr>
                        <tr id="y5">
                            <td>Y5</td>
                            <td id="sup5L"></td>
                            <td id="sup5K"></td>
                            <td id="sup5r"></td>
                            <td id="sup5KLr"></td>
                        </tr>
                    </tbody>
                </table>
                
                
            </div>

            <div id="ResultComp">
                

            </div>
            <div id="AISCCURVE">
                
            </div>
        
        </div>
    </div>
    <div class="DESIGNCOMPRESS">
        <div>
            <H1>DESIGN FOR COMPRESSION MEMBER</H1>
        </div>
        <div class="INPUTCOMPRESS">
            <div>
                <label id="ASTMC">ASTM  Specification:</label>
                    <select name="ASTMinputC" id="ASTMinputC">
                        <option value="A36">A36</option>
                        <option value="A572Gr.42">A572 Gr. 42</option>
                        <option value="A572Gr.50">A572 Gr. 50</option>
                        <option value="A572Gr.55">A572 Gr. 55</option>
                        <option value="A572Gr.60">A572 Gr. 60</option>
                        <option value="A572Gr.65">A572 Gr. 65</option>
                        <option value="A588Gr.42">A588 Gr. 42</option>
                        <option value="A588Gr.46">A588 Gr. 46</option>
                        <option value="A588Gr.50">A588 Gr. 50</option>
                        <option value="A687">A687</option>
                        <option value="A992">A992</option>
                    </select>    
            </div>
            <div class="DesignMethod">
                <label for="designMethod">Design Method:</label>
                <select id="designMethod">
                    <option value="LRFD">LRFD</option>
                    <option value="ASD">ASD</option>
                </select>
            </div>
            <div>
                <label>DeadLoad:</label>
                <input id="DeadLoad" size="10" placeholder="kips">
                <label>Liveload:</label>
                <input  id="LiveLoad" size="10" placeholder="kips">
                <label>Lenght:</label>
                <input id="LenghtDC" size="10" placeholder="ft">
            </div>
             <button id="DesignC" class="DesignC">Design</button>

        </div> 
        <div class="LateralSupportC">
            <div class="TOPBOT">
                
                    <h3>TOP-BOT END</h3>
                        <div>
                            <label><B>TOP</B></label><br>
                        <label>Fixed:</label>
                        <input type="radio" name="top" id="topfixedC"><br>
                        <label>Pinned:</label>
                        <input type="radio" name="top" id="toppinnedC"><br>
                        <label>Free:</label>
                        <input type="radio" name="top" id="topfreeC"><br>
                        </div>
                        <div>
                            <label><B>BOT</B></label><br>
                        <label>Fixed:</label>
                        <input type="radio" name="bot" id="botfixedC"><br>
                        <label>Pinned:</label>
                        <input type="radio" name="bot" id="botpinnedC"><br>
                        <label>Free:</label>
                        <input type="radio" name="bot" id="botfreeC"><br>
                        </div>
                    
             
                <h3>Lateral Support</h3>
                <label>No support:</label>
                <input id="NosupportC" type="radio" name="pinnedC">
                <label>With Lateral Support:</label>
                <input id="supportC" type="radio" name="pinnedC">
                <div id="SupportC" style="display: none;">
                    <label>Amount of supports:</label>
                    <input type="number" id="supprtamountC" placeholder="0" size="1" max="3" min="0" step="1">
                    </div>
                         <div id="support1C">
                        <p><b>Support 1</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support1C" id="pinned1C">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support1C" id="fixed1C">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support1C" id="Free1C"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location1C" placeholder="ft" size="1" >
                         </div>
                          <div id="support2C">
                        <p><b>Support 2</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support2C" id="pinned2C">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support2C" id="fixed2C">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support2C" id="Free2C"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location2C" placeholder="ft" size="1" >
                            </div>
                            <div id="support3C">
                        <p><b>Support 3</b></p>
                        <label for="load">Pinned:</label>
                        <input type="radio" name="Support3C" id="pinned3C">
                        <label for="load">Fixed:</label>
                        <input type="radio" name="Support3C" id="fixed3C">
                        <label for="load">Free:</label>
                        <input type="radio" name="Support3C" id="Free3C"><br>
                        <label>location of support:</label>
                        <input type="numner" id="location3C" placeholder="" size="1" >
                    </div>


            </div>
            <div class="ResultCalcC">

                <div class="GraphicalColumn">
                    
                    
                    
                    
                </div>
                

               
                
            </div>
            
            
        </div>  
        <div class="ResultofallCD">
            

                
            </div>
            <div class="downlaod"></div>
        
        
        </div>
     </div>


        
        
 
        
    

    
</div>




<script>
// Function to handle the visibility of the SupportA container
function handleSupportVisibility() {
  // Get the radio buttons and the SupportA container
  const supportRadio = document.getElementById('support');
  const noSupportRadio = document.getElementById('Nosupport');
  const supportContainer = document.getElementById('SupportA');
  
  // Show the SupportA container if the support radio is checked
  if (supportRadio.checked) {
    supportContainer.style.display = 'block';
  }
  // Hide the SupportA container if the Nosupport radio is checked
  else if (noSupportRadio.checked) {
    supportContainer.style.display = 'none';
  }
}

// Add event listeners to both radio buttons
document.getElementById('support').addEventListener('change', handleSupportVisibility);
document.getElementById('Nosupport').addEventListener('change', handleSupportVisibility);

// Run the function once when the page loads to set the initial state
document.addEventListener('DOMContentLoaded', function() {
  // Check the initial state of the radio buttons and set visibility accordingly
  handleSupportVisibility();
});

document.addEventListener("DOMContentLoaded", function() {
    // Get references to DOM elements
    const noSupportRadio = document.getElementById("Nosupport");
    const withSupportRadio = document.getElementById("support");
    const supportADiv = document.getElementById("SupportA");
    const supportAmountInput = document.getElementById("supprtamount");
    const support1Div = document.getElementById("support1");
    const support2Div = document.getElementById("support2");
    const support3Div = document.getElementById("support3");

    // Initially hide all support divs
    support1Div.style.display = "none";
    support2Div.style.display = "none";
    support3Div.style.display = "none";

    // Show/hide SupportA div based on radio button selection
    noSupportRadio.addEventListener("change", function() {
        if (this.checked) {
            supportADiv.style.display = "none";
        }
    });

    withSupportRadio.addEventListener("change", function() {
        if (this.checked) {
            supportADiv.style.display = "block";
            // When support is initially shown, update which support divs are visible
            updateSupportDivs();
        }
    });

    // Listen for changes to the support amount input
    supportAmountInput.addEventListener("input", updateSupportDivs);

    function updateSupportDivs() {
        const amount = parseInt(supportAmountInput.value) || 0;
        
        // Show/hide support divs based on amount
        support1Div.style.display = amount >= 1 ? "block" : "none";
        support2Div.style.display = amount >= 2 ? "block" : "none";
        support3Div.style.display = amount >= 3 ? "block" : "none";
    }

    // Initialize state based on initial values
    if (withSupportRadio.checked) {
        supportADiv.style.display = "block";
        updateSupportDivs();
    } else {
        supportADiv.style.display = "none";
    }
});

document.addEventListener("DOMContentLoaded", function() {
    // Add containers for both visualizations after the "INTERACTIVECOLUMN" div
    const interactiveColumn = document.querySelector(".INTERACTIVECOLUMN");
    interactiveColumn.innerHTML = `
        <div style="display: flex; flex-wrap: wrap; gap: 20px; margin-top: 20px;">
            <!-- Y-axis visualization (with lateral supports) -->
            <div class="visualization-container" style="flex: 1; min-width: 300px; height: 500px; border: 1px solid #ccc; position: relative; overflow: hidden;">
                <h3 style="text-align: center; margin: 5px 0;">Y-Axis Visualization (Lateral Supports)</h3>
                <div id="beam-visualization-y" style="width: 100%; height: 450px; position: relative;">
                    <!-- SVG will be inserted here -->
                </div>
            </div>
            
            <!-- X-axis visualization (without lateral supports) -->
            <div class="visualization-container" style="flex: 1; min-width: 300px; height: 500px; border: 1px solid #ccc; position: relative; overflow: hidden;">
                <h3 style="text-align: center; margin: 5px 0;">X-Axis Visualization (Full Length)</h3>
                <div id="beam-visualization-x" style="width: 100%; height: 450px; position: relative;">
                    <!-- SVG will be inserted here -->
                </div>
            </div>
        </div>
    `;

    // Get all the input elements we need to monitor
    const lengthInput = document.getElementById("Lenght");
    const supportRadio = document.getElementById("support");
    const noSupportRadio = document.getElementById("Nosupport");
    const supportAmountInput = document.getElementById("supprtamount");
    const locationInputs = [
        document.getElementById("location1"),
        document.getElementById("location2"),
        document.getElementById("location3")
    ];
    
    // Top support options
    const topFixed = document.getElementById("topfixed");
    const topPinned = document.getElementById("toppinned");
    const topFree = document.getElementById("topfree");
    
    // Bottom support options
    const botFixed = document.getElementById("botfixed");
    const botPinned = document.getElementById("botpinned");
    const botFree = document.getElementById("botfree");
    
    // Lateral support options
    const lateralSupportTypes = [
        {
            pinned: document.getElementById("pinned1"),
            fixed: document.getElementById("fixed1"),
            free: document.getElementById("Free1")
        },
        {
            pinned: document.getElementById("pinned2"),
            fixed: document.getElementById("fixed2"),
            free: document.getElementById("Free2")
        },
        {
            pinned: document.getElementById("pinned3"),
            fixed: document.getElementById("fixed3"),
            free: document.getElementById("Free3")
        }
    ];

    // Analyze button
    const analyzeButton = document.getElementById("calculate");

    // Initial drawing
    drawBeamColumns();

    // Add event listeners to all inputs that should trigger a redraw
    lengthInput.addEventListener("input", drawBeamColumns);
    supportRadio.addEventListener("change", drawBeamColumns);
    noSupportRadio.addEventListener("change", drawBeamColumns);
    supportAmountInput.addEventListener("input", drawBeamColumns);
    
    for (let i = 0; i < locationInputs.length; i++) {
        locationInputs[i].addEventListener("input", drawBeamColumns);
    }
    
    // Top support options
    topFixed.addEventListener("change", drawBeamColumns);
    topPinned.addEventListener("change", drawBeamColumns);
    topFree.addEventListener("change", drawBeamColumns);
    
    // Bottom support options
    botFixed.addEventListener("change", drawBeamColumns);
    botPinned.addEventListener("change", drawBeamColumns);
    botFree.addEventListener("change", drawBeamColumns);
    
    // Lateral support options
    for (let i = 0; i < lateralSupportTypes.length; i++) {
        lateralSupportTypes[i].pinned.addEventListener("change", drawBeamColumns);
        lateralSupportTypes[i].fixed.addEventListener("change", drawBeamColumns);
        lateralSupportTypes[i].free.addEventListener("change", drawBeamColumns);
    }
    
    analyzeButton.addEventListener("click", drawBeamColumns);

    function drawBeamColumns() {
        // Draw both visualizations
        drawYAxisBeam();
        drawXAxisBeam();
    }

    function drawYAxisBeam() {
        const beamVisualization = document.getElementById("beam-visualization-y");
        if (!beamVisualization) return;

        // Get the current values from the form
        const columnLength = parseFloat(lengthInput.value) || 16; // Default to 16 if not specified
        const hasLateralSupports = supportRadio.checked;
        const supportCount = hasLateralSupports ? parseInt(supportAmountInput.value) || 0 : 0;
        
        // Get support locations and sort them by position
        const supportLocations = [];
        if (hasLateralSupports) {
            for (let i = 0; i < supportCount && i < 3; i++) {
                const location = parseFloat(locationInputs[i].value) || 0;
                if (location > 0 && location < columnLength) {
                    supportLocations.push({
                        position: location,
                        type: lateralSupportTypes[i].fixed.checked ? "fixed" :
                              lateralSupportTypes[i].pinned.checked ? "pinned" : "free",
                        index: i + 1
                    });
                }
            }
        }
        
        // Sort support locations by position
        supportLocations.sort((a, b) => a.position - b.position);
        
        // Get end supports
        const topSupport = topFixed.checked ? "fixed" : topPinned.checked ? "pinned" : "free";
        const botSupport = botFixed.checked ? "fixed" : botPinned.checked ? "pinned" : "free";

        // Calculate dimensions
        const svgWidth = beamVisualization.clientWidth;
        const svgHeight = beamVisualization.clientHeight;
        const margin = { top: 20, right: 40, bottom: 40, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        
        // Scale factors
        const yScale = height / columnLength;
        
        // Determine segment points (top, all supports, bottom)
        const segmentPoints = [0, ...supportLocations.map(s => s.position), columnLength];
        
        // Create the SVG
        const svg = `
            <svg width="${svgWidth}" height="${svgHeight}">
                <g transform="translate(${margin.left}, ${margin.top})">
                    <!-- Column shaft (W-shape) showing front and side view -->
                    <!-- Front view (Y-axis) -->
                    <path d="M ${width/2-15} 0 
                             L ${width/2-15} ${columnLength * yScale}
                             M ${width/2+15} 0
                             L ${width/2+15} ${columnLength * yScale}
                             M ${width/2-25} 0
                             L ${width/2+25} 0
                             M ${width/2-25} ${columnLength * yScale}
                             L ${width/2+25} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                    
                    <!-- "Y" label below the beam -->
                    <text x="${width/2}" y="${columnLength * yScale + 35}" 
                          text-anchor="middle" font-size="16" font-weight="bold">
                        Y
                    </text>
                    
                    <!-- Top support -->
                    ${renderSupport(width/2, 0, topSupport, "top")}
                    
                    <!-- Bottom support -->
                    ${renderSupport(width/2, columnLength * yScale, botSupport, "bottom")}
                    
                    <!-- Lateral supports -->
                    ${supportLocations.map(support => 
                        renderLateralSupport(width/2, support.position * yScale, support.type)
                    ).join('')}
                    
                    <!-- Column height label -->
                    <text x="${40}" y="${columnLength * yScale / 2}" 
                          transform="rotate(360, ${width/2 + 40}, ${columnLength * yScale / 2})"
                          text-anchor="middle" dominant-baseline="middle" font-size="12">
                        ${columnLength}' Column Length
                    </text>
                    
                    <!-- Support location labels -->
                    ${supportLocations.map((support) => `
                        <text x="${width/2 - 40}" y="${support.position * yScale}"
                              text-anchor="end" dominant-baseline="middle" font-size="12">
                            Support ${support.index}: ${support.position}'
                        </text>
                    `).join('')}
                    
                    <!-- Segment labels (y1, y2, etc.) -->
                    ${segmentPoints.slice(0, -1).map((startPoint, i) => {
                        const endPoint = segmentPoints[i + 1];
                        const segmentLength = endPoint - startPoint;
                        const midPoint = (startPoint + endPoint) / 2;
                        
                        return `
                            <!-- y${i+1} segment label -->
                            <text x="${width/2 + 30}" y="${(startPoint + (segmentLength/2)) * yScale}"
                                  text-anchor="start" dominant-baseline="middle" font-size="14" fill="blue" font-weight="bold">
                                y${i+1} = ${segmentLength.toFixed(2)}'
                            </text>
                            
                            <!-- Segment marker lines -->
                            <line x1="${width/2 + 15}" y1="${startPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${startPoint * yScale}"
                                  stroke="blue" stroke-width="1" />
                            <line x1="${width/2 + 15}" y1="${endPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${endPoint * yScale}"
                                  stroke="blue" stroke-width="1" />
                            
                            <!-- Connecting line for segment -->
                            <line x1="${width/2 + 25}" y1="${startPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${endPoint * yScale}"
                                  stroke="blue" stroke-width="1" stroke-dasharray="4,2" />
                        `;
                    }).join('')}
                </g>
            </svg>
        `;
        
        beamVisualization.innerHTML = svg;
    }
    
    function drawXAxisBeam() {
        const beamVisualization = document.getElementById("beam-visualization-x");
        if (!beamVisualization) return;

        // Get the current values from the form
        const columnLength = parseFloat(lengthInput.value) || 16; // Default to 16 if not specified
        
        // Get end supports
        const topSupport = topFixed.checked ? "fixed" : topPinned.checked ? "pinned" : "free";
        const botSupport = botFixed.checked ? "fixed" : botPinned.checked ? "pinned" : "free";

        // Calculate dimensions
        const svgWidth = beamVisualization.clientWidth;
        const svgHeight = beamVisualization.clientHeight;
        const margin = { top: 20, right: 40, bottom: 40, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        
        // Scale factors
        const yScale = height / columnLength;
        
        // Create the SVG - showing the beam from the side (X-axis view)
        const svg = `
            <svg width="${svgWidth}" height="${svgHeight}">
                <g transform="translate(${margin.left}, ${margin.top})">
                    <!-- Column shaft (W-shape) - side view (X-axis) -->
                    <path d="M ${width/2-25} 0 
                             L ${width/2-25} ${columnLength * yScale}
                             M ${width/2+25} 0
                             L ${width/2+25} ${columnLength * yScale}
                             M ${width/2-25} 0
                             L ${width/2+25} 0
                             M ${width/2-25} ${columnLength * yScale}
                             L ${width/2+25} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                          
                    <!-- Web of the W-shape (showing flange depth) -->
                    <path d="M ${width/2-10} 0 
                             L ${width/2-10} ${columnLength * yScale}
                             M ${width/2+10} 0
                             L ${width/2+10} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                    
                    <!-- "X" label below the beam -->
                    <text x="${width/2}" y="${columnLength * yScale + 35}" 
                          text-anchor="middle" font-size="16" font-weight="bold">
                        X
                    </text>
                    
                    <!-- Top support -->
                    ${renderSupport(width/2, 0, topSupport, "top")}
                    
                    <!-- Bottom support -->
                    ${renderSupport(width/2, columnLength * yScale, botSupport, "bottom")}
                    
                    <!-- Full column length label -->
                    <text x="${32}" y="${columnLength * yScale / 2}" 
                          transform="rotate(360, ${width/2 + 40}, ${columnLength * yScale / 2})"
                          text-anchor="middle" dominant-baseline="middle" font-size="12">
                        ${columnLength}' Column Length
                    </text>
                    
                    <!-- Main segment label for X-axis view -->
                    <text x="${width/2 + 30}" y="${columnLength * yScale / 2}"
                          text-anchor="start" dominant-baseline="middle" font-size="14" fill="blue" font-weight="bold">
                        y1 = ${columnLength.toFixed(2)}'
                    </text>
                    
                    <!-- Segment marker lines -->
                    <line x1="${width/2 + 25}" y1="0" 
                          x2="${width/2 + 35}" y2="0"
                          stroke="blue" stroke-width="1" />
                    <line x1="${width/2 + 25}" y1="${columnLength * yScale}" 
                          x2="${width/2 + 35}" y2="${columnLength * yScale}"
                          stroke="blue" stroke-width="1" />
                    
                    <!-- Connecting line for segment -->
                    <line x1="${width/2 + 35}" y1="0" 
                          x2="${width/2 + 35}" y2="${columnLength * yScale}"
                          stroke="blue" stroke-width="1" stroke-dasharray="4,2" />
                </g>
            </svg>
        `;
        
        beamVisualization.innerHTML = svg;
    }
    
    function renderSupport(x, y, type, position) {
        if (type === "fixed") {
            // Fixed support (triangle with hatching)
            const direction = position === "top" ? -1 : 1;
            return `
                <path d="M ${x-30} ${y + (direction * 10)} 
                         L ${x+30} ${y + (direction * 10)}
                         L ${x} ${y}"
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching lines for fixed support -->
                ${Array.from({length: 7}, (_, i) => 
                    `<line x1="${x-25 + i*10}" y1="${y + (direction * 10)}" 
                           x2="${x-25 + i*10}" y2="${y + (direction * 5)}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
            `;
        } else if (type === "pinned") {
            // Pinned support (triangle)
            const direction = position === "top" ? -1 : 1;
            return `
                <path d="M ${x-30} ${y + (direction * 10)} 
                         L ${x+30} ${y + (direction * 10)}
                         L ${x} ${y}"
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Circles to represent pins -->
                <circle cx="${x}" cy="${y}" r="3" fill="black" />
            `;
        } else { // free
            // Free end (nothing)
            return '';
        }
    }
    
    function renderLateralSupport(x, y, type) {
        if (type === "fixed") {
            // Fixed lateral support (square block with hatching)
            return `
                <rect x="${x+20}" y="${y-10}" width="20" height="20" 
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching for fixed support -->
                ${Array.from({length: 4}, (_, i) => 
                    `<line x1="${x+20}" y1="${y-10 + i*5}" 
                           x2="${x+40}" y2="${y-10 + i*5}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
                <!-- Line connecting to column -->
                <line x1="${x+15}" y1="${y}" x2="${x+20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                
                <!-- Left side support - mirror image -->
                <rect x="${x-40}" y="${y-10}" width="20" height="20" 
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching for fixed support -->
                ${Array.from({length: 4}, (_, i) => 
                    `<line x1="${x-40}" y1="${y-10 + i*5}" 
                           x2="${x-20}" y2="${y-10 + i*5}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
                <!-- Line connecting to column -->
                <line x1="${x-15}" y1="${y}" x2="${x-20}" y2="${y}"
                      stroke="black" stroke-width="2" />
            `;
        } else if (type === "pinned") {
            // Pinned lateral support (roller)
            return `
                <!-- Right side -->
                <circle cx="${x+30}" cy="${y}" r="10" 
                        stroke="black" stroke-width="2" fill="none" />
                <!-- Line connecting to column -->
                <line x1="${x+15}" y1="${y}" x2="${x+20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                <!-- Small circle for pin -->
                <circle cx="${x+20}" cy="${y}" r="3" fill="black" />
                
                <!-- Left side - mirror image -->
                <circle cx="${x-30}" cy="${y}" r="10" 
                        stroke="black" stroke-width="2" fill="none" />
                <!-- Line connecting to column -->
                <line x1="${x-15}" y1="${y}" x2="${x-20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                <!-- Small circle for pin -->
                <circle cx="${x-20}" cy="${y}" r="3" fill="black" />
            `;
        } else { // free
            // Free lateral support (just a line to indicate position)
            return `
                <line x1="${x-40}" y1="${y}" x2="${x+40}" y2="${y}"
                      stroke="blue" stroke-width="1" stroke-dasharray="5,5" />
            `;
        }
    }
});

// Steel Properties Database - Simplified version
// This would normally be loaded from ASTMSPEC.xlsx sheets
const steelProperties = {
    "A36": { Fy: 36, Fu: 58, E: 29000 },
    "A572Gr.42": { Fy: 42, Fu: 60, E: 29000 },
    "A572Gr.50": { Fy: 50, Fu: 65, E: 29000 },
    "A572Gr.55": { Fy: 55, Fu: 70, E: 29000 },
    "A572Gr.60": { Fy: 60, Fu: 75, E: 29000 },
    "A572Gr.65": { Fy: 65, Fu: 80, E: 29000 },
    "A588Gr.42": { Fy: 42, Fu: 63, E: 29000 },
    "A588Gr.46": { Fy: 46, Fu: 67, E: 29000 },
    "A588Gr.50": { Fy: 50, Fu: 70, E: 29000 },
    "A687": { Fy: 50, Fu: 70, E: 29000 },
    "A992": { Fy: 50, Fu: 65, E: 29000 }
};

// W-Shape Properties Database - Simplified with commonly used sections
const wShapeProperties = {
    "W10X77": {
        A: 22.7, d: 10.6, bf: 10.1, tf: 0.870, tw: 0.530,
        Ix: 455, Zx: 99.1, Sx: 85.9, rx: 4.49,
        Iy: 152, Zy: 45.3, Sy: 30.1, ry: 2.60,
        h: 8.86, J: 4.89, Cw: 3680
    },
    "W12X45": {
        A: 13.2, d: 11.9, bf: 8.0, tf: 0.576, tw: 0.335,
        Ix: 270, Zx: 51.7, Sx: 45.6, rx: 4.51,
        Iy: 88.6, Zy: 22.2, Sy: 22.1, ry: 2.59,
        h: 10.748, J: 1.24, Cw: 1260
    },
    // Add more sections as needed
};

// Main analysis function
document.addEventListener('DOMContentLoaded', function() {
    // Get elements
    const calculateBtn = document.getElementById('calculate');
    const resultDiv = document.getElementById('ResultComp');
    const supportRadio = document.getElementById('support');
    const noSupportRadio = document.getElementById('Nosupport');
    const supportAmountInput = document.getElementById('supprtamount');
    const supportDiv = document.getElementById('SupportA');
    
    // Show/hide support options based on radio selection
    supportRadio.addEventListener('change', function() {
        if (this.checked) {
            supportDiv.style.display = 'block';
        }
    });
    
    noSupportRadio.addEventListener('change', function() {
        if (this.checked) {
            supportDiv.style.display = 'none';
            supportAmountInput.value = '';
        }
    });
    
    // Analyze button click event
    calculateBtn.addEventListener('click', function() {
        analyzeCompression();
    });
    
    function analyzeCompression() {
        // Get inputs
        const astmSpec = document.getElementById('ASTMinput').value;
        const shapeDim = document.getElementById('dimA').value.toUpperCase();
        const columnLength = parseFloat(document.getElementById('Lenght').value) * 12; // Convert ft to inches
        
        // Get steel properties
        const steel = steelProperties[astmSpec];
        if (!steel) {
            resultDiv.innerHTML = `<div class="error">Error: Steel specification ${astmSpec} not found.</div>`;
            return;
        }
        
        // Get shape properties
        const shape = wShapeProperties[`W${shapeDim}`];
        if (!shape) {
            resultDiv.innerHTML = `<div class="error">Error: Shape W${shapeDim} not found.</div>`;
            return;
        }
        
        // Calculate effective length factor (K)
        let kx = 1.0; // Default value
        let ky = 1.0; // Default value
        
        // Determine K based on end conditions
        if (document.getElementById('topfixed').checked && document.getElementById('botfixed').checked) {
            kx = ky = 0.65; // Fixed-Fixed
        } else if (document.getElementById('topfixed').checked && document.getElementById('botpinned').checked) {
            kx = ky = 0.80; // Fixed-Pinned
        } else if (document.getElementById('toppinned').checked && document.getElementById('botpinned').checked) {
            kx = ky = 1.0; // Pinned-Pinned
        } else if ((document.getElementById('topfixed').checked && document.getElementById('botfree').checked) ||
                   (document.getElementById('topfree').checked && document.getElementById('botfixed').checked)) {
            kx = ky = 2.1; // Fixed-Free
        } else if ((document.getElementById('toppinned').checked && document.getElementById('botfree').checked) ||
                   (document.getElementById('topfree').checked && document.getElementById('botpinned').checked)) {
            kx = ky = 2.0; // Pinned-Free
        }
        
        // Calculate slenderness ratios
        const KLrx = (kx * columnLength) / shape.rx;
        const KLry = (ky * columnLength) / shape.ry;
        const KLr = Math.max(KLrx, KLry); // Critical KL/r
        
        // Update table
        document.getElementById('topL').textContent = (columnLength / 12).toFixed(2) + ' ft';
        document.getElementById('topK').textContent = kx.toFixed(2);
        document.getElementById('topr').textContent = shape.rx.toFixed(2);
        document.getElementById('topKLr').textContent = KLrx.toFixed(2);
        
        document.getElementById('sup1L').textContent = '-';
        document.getElementById('sup1K').textContent = '-';
        document.getElementById('sup1r').textContent = '-';
        document.getElementById('sup1KLr').textContent = '-';
        
        document.getElementById('sup2L').textContent = '-';
        document.getElementById('sup2K').textContent = '-';
        document.getElementById('sup2r').textContent = '-';
        document.getElementById('sup2KLr').textContent = '-';
        
        document.getElementById('sup3L').textContent = '-';
        document.getElementById('sup3K').textContent = '-';
        document.getElementById('sup3r').textContent = '-';
        document.getElementById('sup3KLr').textContent = '-';

        document.getElementById('sup4L').textContent = '-';
        document.getElementById('sup4K').textContent = '-';
        document.getElementById('sup4r').textContent = '-';
        document.getElementById('sup4KLr').textContent = '-';

        document.getElementById('sup5L').textContent = '-';
        document.getElementById('sup5K').textContent = '-';
        document.getElementById('sup5r').textContent = '-';
        document.getElementById('sup5KLr').textContent = '-';
        
        // Check if compact or slender
        // Flange check
        const lambdaFlange = shape.bf / (2 * shape.tf);
        const lambdaFlangeLimit = 0.56 * Math.sqrt(steel.E / steel.Fy);
        const isCompactFlange = lambdaFlange <= lambdaFlangeLimit;
        
        // Web check
        const lambdaWeb = shape.h / shape.tw;
        const lambdaWebLimit = 1.49 * Math.sqrt(steel.E / steel.Fy);
        const isCompactWeb = lambdaWeb <= lambdaWebLimit;
        
        // Calculate critical stress
        let Fcr;
        const Fe = (Math.pow(Math.PI, 2) * steel.E) / Math.pow(KLr, 2); // Elastic buckling stress
        
        if (KLr <= 4.71 * Math.sqrt(steel.E / steel.Fy)) {
            // Inelastic buckling
            Fcr = 0.658 ** (steel.Fy / Fe) * steel.Fy;
        } else {
            // Elastic buckling
            Fcr = 0.877 * Fe;
        }
        
        // Calculate nominal compression strength
        const Pn = shape.A * Fcr;
        
        // Calculate design strength (LRFD)
        const phi = 0.9; // Resistance factor for compression
        const Pu = phi * Pn;
        
        // Calculate available strength (ASD)
        const omega = 1.67; // Safety factor for compression
        const Pa = Pn / omega;
        
        // Format results for display
        let resultsHTML = `
            <h2>Compression Analysis Results for W${shapeDim} (${astmSpec})</h2>
            <div class="results-section">
                <h3>1. Section Classification</h3>
                <div class="result-item">
                    <strong>Flange:</strong> λ = ${lambdaFlange.toFixed(2)}, λr = ${lambdaFlangeLimit.toFixed(2)} → ${isCompactFlange ? "Compact" : "Slender"}
                </div>
                <div class="result-item">
                    <strong>Web:</strong> λ = ${lambdaWeb.toFixed(2)}, λr = ${lambdaWebLimit.toFixed(2)} → ${isCompactWeb ? "Compact" : "Slender"}
                </div>
                <div class="result-item">
                    <strong>Section:</strong> ${(isCompactFlange && isCompactWeb) ? "Compact Section" : "Non-Compact Section"}
                </div>
            </div>
            
            <div class="results-section">
                <h3>2. Critical Slenderness</h3>
                <div class="result-item">
                    <strong>X-axis:</strong> KL/r = ${KLrx.toFixed(2)}
                </div>
                <div class="result-item">
                    <strong>Y-axis:</strong> KL/r = ${KLry.toFixed(2)}
                </div>
                <div class="result-item">
                    <strong>Critical:</strong> KL/r = ${KLr.toFixed(2)}
                </div>
            </div>
            
            <div class="results-section">
                <h3>3. Buckling Stress and Strength</h3>
                <div class="result-item">
                    <strong>Elastic Buckling Stress (Fe):</strong> ${Fe.toFixed(2)} ksi
                </div>
                <div class="result-item">
                    <strong>Critical Stress (Fcr):</strong> ${Fcr.toFixed(2)} ksi
                </div>
                <div class="result-item">
                    <strong>Nominal Strength (Pn):</strong> ${Pn.toFixed(2)} kips
                </div>
            </div>
            
            <div class="results-section">
                <h3>4. Design Strength</h3>
                <div class="result-item">
                    <strong>LRFD (φPn):</strong> ${Pu.toFixed(2)} kips
                </div>
                <div class="result-item">
                    <strong>ASD (Pn/Ω):</strong> ${Pa.toFixed(2)} kips
                </div>
            </div>
        `;
        
        resultDiv.innerHTML = resultsHTML;
    }
});


const E = 29000; // ksi - Modulus of elasticity
const PI = Math.PI;

// Global variables to store data from Excel
let astmData = {};
let wShapesData = {};
let dataLoaded = false;

// Function to load data from Excel
async function loadExcelData() {
    try {
        // Use SheetJS to parse the Excel file
        // This assumes the ASTMSPEC.xlsx file is available
        const response = await fetch('ASTMSPEC.xlsx');
        const data = await response.arrayBuffer();
        const workbook = XLSX.read(data, { type: 'array' });
        
        console.log("Excel workbook loaded. Sheet names:", workbook.SheetNames);
        
        // Sheet 1: Steel name, Fy, Fu
        const sheet1 = workbook.Sheets[workbook.SheetNames[0]];
        const steelData = XLSX.utils.sheet_to_json(sheet1);
        
        console.log("Steel data sample:", steelData.slice(0, 3));
        
        // Process steel data into our format
        steelData.forEach(row => {
            if (row['Steel name']) {
                astmData[row['Steel name']] = {
                    Fy: row['Fy'] || 0,
                    Fu: row['Fu'] || 0
                };
            }
        });
        
        console.log("Processed ASTM data:", Object.keys(astmData));
        
        // Sheet 2: W-shape properties
        const sheet2 = workbook.Sheets[workbook.SheetNames[1]];
        const shapeData = XLSX.utils.sheet_to_json(sheet2);
        
        console.log("Shape data sample:", shapeData.slice(0, 3));
        console.log("Shape data columns:", Object.keys(shapeData[0] || {}));
        
        // Process shape data into our format
        shapeData.forEach(row => {
            // Check if it's a W-shape by the AISC_Manual_Label or some other field
            let shapeLabel = row['AISC_Manual_Label'] || row['W_shape'] || '';
            
            // Some Excel files might use different column names - try to detect them
            if (!shapeLabel) {
                // Look for any key that might contain shape information
                for (const key in row) {
                    if (typeof row[key] === 'string' && row[key].startsWith('W')) {
                        shapeLabel = row[key];
                        break;
                    }
                }
            }
            
            // Remove any spaces and convert to uppercase for consistency
            shapeLabel = shapeLabel.toString().replace(/\s+/g, '').toUpperCase();
            
            if (shapeLabel && shapeLabel.startsWith('W')) {
                wShapesData[shapeLabel] = {
                    A: row['A'] || 0,
                    d: row['d'] || 0,
                    tw: row['tw'] || 0,
                    bf: row['bf'] || 0,
                    tf: row['tf'] || 0,
                    htw: row['h/tw'] || 0,
                    Ix: row['Ix'] || 0,
                    Zx: row['Zx'] || 0,
                    Sx: row['Sx'] || 0,
                    rx: row['rx'] || 0,
                    Iy: row['Iy'] || 0,
                    Zy: row['Zy'] || 0,
                    Sy: row['Sy'] || 0,
                    ry: row['ry'] || 0
                };
            }
        });
        
        console.log("Processed W-shapes data:", Object.keys(wShapesData));
        
        dataLoaded = true;
        console.log("Excel data loaded successfully!");
        
        // Populate dropdown with ASTM specs
        const astmSelect = document.getElementById('ASTMinput');
        astmSelect.innerHTML = '';
        
        Object.keys(astmData).forEach(spec => {
            const option = document.createElement('option');
            option.value = spec;
            option.textContent = spec;
            astmSelect.appendChild(option);
        });
        
        // Enable the analyze button
        document.getElementById('calculate').disabled = false;
        
    } catch (error) {
        console.error("Error loading Excel data:", error);
        // If Excel loading fails, use hardcoded default data
        useDefaultData();
    }
}

// Fallback function to use hardcoded data if Excel loading fails
function useDefaultData() {
    console.log("Using default hardcoded data");
    
    // Default ASTM data
    astmData = {
        "A36": { Fy: 36, Fu: 58 },
        "A572Gr.50": { Fy: 50, Fu: 65 },
        "A992": { Fy: 50, Fu: 65 }
    };
    
    // Default W shape data (limited set)
    wShapesData = {
        "W12X14": {
            A: 4.16, d: 11.91, tw: 0.170, bf: 3.97, tf: 0.225, htw: 66.8, 
            Ix: 88.6, Zx: 17.3, Sx: 14.9, rx: 4.62, 
            Iy: 2.36, Zy: 1.19, Sy: 0.766, ry: 0.754
        },
        "W12X26": {
            A: 7.65, d: 12.22, tw: 0.230, bf: 6.49, tf: 0.380, htw: 50.1, 
            Ix: 204, Zx: 37.2, Sx: 33.4, rx: 5.17, 
            Iy: 21.3, Zy: 6.58, Sy: 4.22, ry: 1.67
        },
        "W12X45": {
            A: 13.2, d: 12.06, tw: 0.335, bf: 8.05, tf: 0.575, htw: 33.0, 
            Ix: 348, Zx: 64.2, Sx: 57.7, rx: 5.13, 
            Iy: 56.3, Zy: 14.0, Sy: 9.08, ry: 2.06
        }
    };
    
    dataLoaded = true;
    document.getElementById('calculate').disabled = false;
}

// Event listeners
document.addEventListener('DOMContentLoaded', function() {
    // Add SheetJS library
    const sheetJsScript = document.createElement('script');
    sheetJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
    document.head.appendChild(sheetJsScript);
    
    sheetJsScript.onload = function() {
        // Try to load Excel data once SheetJS is loaded
        loadExcelData();
    };
    
    // Disable calculate button until data is loaded
    document.getElementById('calculate').disabled = true;
    
    // Hide support options initially
    document.getElementById('SupportA').style.display = 'none';
    
    // Support radio button event listeners
    document.getElementById('Nosupport').addEventListener('change', toggleSupportOptions);
    document.getElementById('support').addEventListener('change', toggleSupportOptions);
    
    // Calculate button event listener
    document.getElementById('calculate').addEventListener('click', analyzeColumn);
    
    // Amount of supports input listener
    document.getElementById('supprtamount').addEventListener('input', function() {
        updateSupportInputs(this.value);
    });
});

// Function to toggle support options visibility
function toggleSupportOptions() {
    const supportDiv = document.getElementById('SupportA');
    if (document.getElementById('support').checked) {
        supportDiv.style.display = 'block';
    } else {
        supportDiv.style.display = 'none';
    }
}

// Function to show/hide support input fields based on quantity
function updateSupportInputs(amount) {
    // Hide all support divs first
    document.getElementById('support1').style.display = 'none';
    document.getElementById('support2').style.display = 'none';
    document.getElementById('support3').style.display = 'none';
    
    // Show divs based on amount
    for (let i = 1; i <= amount && i <= 5; i++) {
        document.getElementById('support' + i).style.display = 'block';
    }
}

// Main analysis function
function analyzeColumn() {
    if (!dataLoaded) {
        alert("Steel data is still loading. Please wait.");
        return;
    }
    
    // Get shape and material properties
    const astmSpec = document.getElementById('ASTMinput').value;
    const shapeDim = document.getElementById('dimA').value.toUpperCase();
    const shapeType = document.getElementById('shapeA').value + shapeDim;
    
    // Get material properties
    const material = astmData[astmSpec];
    if (!material) {
        alert(`Steel specification ${astmSpec} not found in database.`);
        return;
    }
    
    // Check if the shape exists in our database
    if (!wShapesData[shapeType]) {
        alert(`Shape ${shapeType} not found in database. Try another shape like W12X45.`);
        return;
    }
    
    // Get shape properties
    const shape = wShapesData[shapeType];
    
    // Get member length
    const lengthFt = parseFloat(document.getElementById('Lenght').value);
    if (isNaN(lengthFt) || lengthFt <= 0) {
        alert('Please enter a valid length.');
        return;
    }
    const lengthIn = lengthFt * 12;
    
    // Determine end conditions
    const topEnd = getEndCondition('top');
    const botEnd = getEndCondition('bot');
    
    // Calculate K factors for strong (x) and weak (y) axes
    const Kx = calculateKFactor(topEnd, botEnd);
    const Ky = calculateKFactor(topEnd, botEnd);
    
    // Calculate slenderness ratios for both axes
    const KLrx = (Kx * lengthIn) / shape.rx;
    const KLry = (Ky * lengthIn) / shape.ry;
    
    // Determine governing slenderness ratio
    const governingKLr = Math.max(KLrx, KLry);
    const governingAxis = (KLrx > KLry) ? 'X' : 'Y';
    
    // Populate the main table results
    document.getElementById('topL').textContent = lengthFt.toFixed(2);
    document.getElementById('topK').textContent = Kx.toFixed(2);
    document.getElementById('topr').textContent = shape.rx.toFixed(2);
    document.getElementById('topKLr').textContent = KLrx.toFixed(2);
    
    document.getElementById('botL').textContent = lengthFt.toFixed(2);
    document.getElementById('botK').textContent = Ky.toFixed(2);
    document.getElementById('botr').textContent = shape.ry.toFixed(2);
    document.getElementById('botKLr').textContent = KLry.toFixed(2);
    
    // Handle lateral supports if selected
    if (document.getElementById('support').checked) {
        const supportsAmount = parseInt(document.getElementById('supprtamount').value) || 0;
        
        // Create array to store support locations
        const supportLocations = [];
        
        // Get and validate support locations
        for (let i = 1; i <= supportsAmount && i <= 3; i++) {
            const locationInput = document.getElementById('location' + i);
            if (locationInput && locationInput.value) {
                const location = parseFloat(locationInput.value);
                if (!isNaN(location) && location > 0 && location < lengthFt) {
                    supportLocations.push(location);
                }
            }
        }
        
        // Sort support locations in ascending order
        supportLocations.sort((a, b) => a - b);
        
        // Calculate segment lengths (y1, y2, y3, y4, y5)
        const segments = [];
        
        // First segment (from start to first support)
        if (supportLocations.length > 0) {
            segments.push({
                start: 0,
                end: supportLocations[0],
                length: supportLocations[0]
            });
            
            // Middle segments (between supports)
            for (let i = 0; i < supportLocations.length - 1; i++) {
                segments.push({
                    start: supportLocations[i],
                    end: supportLocations[i + 1],
                    length: supportLocations[i + 1] - supportLocations[i]
                });
            }
            
            // Last segment (from last support to end)
            segments.push({
                start: supportLocations[supportLocations.length - 1],
                end: lengthFt,
                length: lengthFt - supportLocations[supportLocations.length - 1]
            });
        } else {
            // If no supports, just one segment for the full length
            segments.push({
                start: 0,
                end: lengthFt,
                length: lengthFt
            });
        }
        
        // Display segment information in the table
        for (let i = 0; i < segments.length && i < 5; i++) {
            const segmentRow = document.getElementById('y' + (i + 1));
            if (segmentRow) {
                segmentRow.style.display = 'table-row';
                
                const segLength = segments[i].length;
                const segK = Ky; // Using the same K factor for Y-axis
                
                document.getElementById('sup' + (i + 1) + 'L').textContent = segLength.toFixed(2);
                document.getElementById('sup' + (i + 1) + 'K').textContent = segK.toFixed(2);
                document.getElementById('sup' + (i + 1) + 'r').textContent = shape.ry.toFixed(2);
                document.getElementById('sup' + (i + 1) + 'KLr').textContent = 
                    (segK * segLength * 12 / shape.ry).toFixed(2);
            }
        }
        
        // Hide unused segment rows
        for (let i = segments.length + 1; i <= 5; i++) {
            const segmentRow = document.getElementById('y' + i);
            if (segmentRow) {
                segmentRow.style.display = 'none';
            }
        }
    } else {
        // No lateral supports
        // Display only one segment for the full length
        document.getElementById('y1').style.display = 'table-row';
        document.getElementById('sup1L').textContent = lengthFt.toFixed(2);
        document.getElementById('sup1K').textContent = Ky.toFixed(2);
        document.getElementById('sup1r').textContent = shape.ry.toFixed(2);
        document.getElementById('sup1KLr').textContent = KLry.toFixed(2);
        
        // Hide other segment rows
        for (let i = 2; i <= 5; i++) {
            const segmentRow = document.getElementById('y' + i);
            if (segmentRow) {
                segmentRow.style.display = 'none';
            }
        }
    }
    // Highlight governing row
    if (KLrx > KLry) {
        document.getElementById('X').style.backgroundColor = '#ffcccb';
        document.getElementById('Y').style.backgroundColor = '';
    } else {
        document.getElementById('X').style.backgroundColor = '';
        document.getElementById('Y').style.backgroundColor = '#ffcccb';
    }
    
    // Calculate Euler and AISC column strength
    const Fe = calculateEulerBuckling(governingKLr);
    const FcrAISC = calculateAISCStrength(material.Fy, governingKLr);
    
    // Calculate nominal strength
    const Pn = shape.A * FcrAISC;
    
    // Calculate LRFD and ASD design strength
    const phiPn = 0.9 * Pn; // LRFD design strength (ϕ = 0.9)
    const PnOmega = Pn / 1.67; // ASD allowable strength (Ω = 1.67)
    
    // Check compactness criteria
    const webCompactness = checkWebCompactness(shape.htw, material.Fy);
    const flangeCompactness = checkFlangeCompactness(shape.bf / (2 * shape.tf), material.Fy);
    
    // Generate HTML output for the results
    const resultHTML = generateResultHTML(
        astmSpec, 
        material, 
        shapeType, 
        shape, 
        governingKLr, 
        governingAxis, 
        Fe,
        FcrAISC, 
        Pn,
        phiPn,
        PnOmega,
        webCompactness, 
        flangeCompactness
    );
    
    document.getElementById('ResultComp').innerHTML = resultHTML;
    
    // Generate the AISC column curve visualization
    generateColumnCurve(material.Fy, governingKLr, Fe, FcrAISC);
}

// Function to determine end condition based on selected radio button
function getEndCondition(position) {
    if (document.getElementById(position + 'fixed').checked) {
        return 'fixed';
    } else if (document.getElementById(position + 'pinned').checked) {
        return 'pinned';
    } else if (document.getElementById(position + 'free').checked) {
        return 'free';
    }
    return 'pinned'; // Default to pinned if nothing selected
}

// Function to get end condition by support ID
function getEndConditionById(supportId) {
    if (document.getElementById('fixed' + supportId.charAt(supportId.length - 1)).checked) {
        return 'fixed';
    } else if (document.getElementById('pinned' + supportId.charAt(supportId.length - 1)).checked) {
        return 'pinned';
    } else if (document.getElementById('Free' + supportId.charAt(supportId.length - 1)).checked) {
        return 'free';
    }
    return 'pinned'; // Default to pinned if nothing selected
}

// Calculate effective length factor K based on end conditions
function calculateKFactor(topEnd, botEnd) {
    // These values are simplified approximations
    if (topEnd === 'fixed' && botEnd === 'fixed') {
        return 0.65;
    } else if ((topEnd === 'fixed' && botEnd === 'pinned') || 
               (topEnd === 'pinned' && botEnd === 'fixed')) {
        return 0.80;
    } else if (topEnd === 'pinned' && botEnd === 'pinned') {
        return 1.0;
    } else if ((topEnd === 'fixed' && botEnd === 'free') || 
               (topEnd === 'free' && botEnd === 'fixed')) {
        return 2.0;
    } else {
        return 1.0; // Default
    }
}

// Calculate K factor for a segment based on support type
function getSegmentK(supportType) {
    if (supportType === 'fixed') {
        return 0.65;
    } else if (supportType === 'pinned') {
        return 1.0;
    } else {
        return 1.0; // Default
    }
}

// Calculate elastic buckling stress using Euler's formula
function calculateEulerBuckling(KLr) {
    return (Math.PI * Math.PI * E) / (KLr * KLr);
}

// Calculate column strength per AISC
function calculateAISCStrength(Fy, KLr) {
    // Calculate Euler buckling stress
    const Fe = calculateEulerBuckling(KLr);
    
    if (KLr <= 4.71 * Math.sqrt(E / Fy)) {
        // Inelastic buckling
        const Fcr = Math.pow(0.658, Fy/Fe) * Fy;
        return Fcr;
    } else {
        // Elastic buckling
        const Fcr = 0.877 * Fe;
        return Fcr;
    }
}

// Check web compactness
function checkWebCompactness(htwRatio, Fy) {
    const lambdaP = 1.49 * Math.sqrt(E / Fy);
    const lambdaR = 1.98 * Math.sqrt(E / Fy);
    
    if (htwRatio <= lambdaP) {
        return { status: "Compact", ratio: htwRatio, limit: lambdaP };
    } else if (htwRatio <= lambdaR) {
        return { status: "Non-compact", ratio: htwRatio, limit: lambdaR };
    } else {
        return { status: "Slender", ratio: htwRatio, limit: lambdaR };
    }
}

// Check flange compactness
function checkFlangeCompactness(bftfRatio, Fy) {
    const lambdaP = 0.38 * Math.sqrt(E / Fy);
    const lambdaR = 0.84 * Math.sqrt(E / Fy);
    
    if (bftfRatio <= lambdaP) {
        return { status: "Compact", ratio: bftfRatio, limit: lambdaP };
    } else if (bftfRatio <= lambdaR) {
        return { status: "Non-compact", ratio: bftfRatio, limit: lambdaR };
    } else {
        return { status: "Slender", ratio: bftfRatio, limit: lambdaR };
    }
}

// Generate HTML for results display
function generateResultHTML(astmSpec, material, shapeType, shape, governingKLr, governingAxis, 
                          Fe, Fcr, Pn, phiPn, PnOmega, webCompactness, flangeCompactness) {
    return `
        <h3>Column Analysis Results</h3>
        <h4>Material Properties (${astmSpec})</h4>
        <p>Yield Stress (Fy): ${material.Fy} ksi</p>
        <p>Ultimate Stress (Fu): ${material.Fu} ksi</p>
        
        <h4>Shape Properties (${shapeType})</h4>
        <p>Area: ${shape.A.toFixed(2)} in²</p>
        <p>Depth: ${shape.d.toFixed(2)} in</p>
        <p>Web Thickness: ${shape.tw.toFixed(3)} in</p>
        <p>Flange Width: ${shape.bf.toFixed(2)} in</p>
        <p>Flange Thickness: ${shape.tf.toFixed(3)} in</p>
        <p>h/tw Ratio: ${shape.htw.toFixed(1)}</p>
        
        <h4>Compactness Check</h4>
        <p>Web: ${webCompactness.status} (h/tw = ${webCompactness.ratio.toFixed(1)}, Limit = ${webCompactness.limit.toFixed(1)})</p>
        <p>Flange: ${flangeCompactness.status} (bf/2tf = ${(shape.bf/(2*shape.tf)).toFixed(1)}, Limit = ${flangeCompactness.limit.toFixed(1)})</p>
        
        <h4>Column Strength</h4>
        <p>Governing Slenderness Ratio (KL/r): ${governingKLr.toFixed(2)} (${governingAxis}-axis)</p>
        <p>Elastic Buckling Stress (Fe): ${Fe.toFixed(2)} ksi</p>
        <p>Critical Stress (Fcr): ${Fcr.toFixed(2)} ksi</p>
        <p>Nominal Strength (Pn): ${Pn.toFixed(2)} kips</p>
        
        <h4>Design Strength</h4>
        <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
            <tr style="background-color: #f2f2f2;">
                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Design Method</th>
                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Factor</th>
                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Design Strength</th>
            </tr>
            <tr>
                <td style="padding: 8px; border: 1px solid #ddd;">LRFD (φPn)</td>
                <td style="padding: 8px; border: 1px solid #ddd;">φ = 0.9</td>
                <td style="padding: 8px; border: 1px solid #ddd;">${phiPn.toFixed(2)} kips</td>
            </tr>
            <tr>
                <td style="padding: 8px; border: 1px solid #ddd;">ASD (Pn/Ω)</td>
                <td style="padding: 8px; border: 1px solid #ddd;">Ω = 1.67</td>
                <td style="padding: 8px; border: 1px solid #ddd;">${PnOmega.toFixed(2)} kips</td>
            </tr>
        </table>
        
        <div id="columnCurveGraph" style="width: 100%; height: 300px;"></div>
    `;
}


// Function to generate AISC column curve visualization
function generateColumnCurve(Fy, actualKLr, actualFcr) {
    // Create canvas for visualization
    const canvas = document.createElement('canvas');
    canvas.width = 600;
    canvas.height = 400;
    canvas.style.width = '100%';
    canvas.style.height = '300px';
    
    const div = document.getElementById('columnCurveGraph');
    div.innerHTML = '';
    div.appendChild(canvas);
    
    const ctx = canvas.getContext('2d');
    
    // Calculate points for the column curve
    const points = [];
    const maxKLr = Math.max(200, actualKLr * 1.2);
    
    for (let KLr = 0; KLr <= maxKLr; KLr += 5) {
        const Fe = (Math.PI * Math.PI * E) / (KLr * KLr);
        let Fcr;
        
        if (KLr <= 4.71 * Math.sqrt(E / Fy)) {
            // Inelastic buckling
            Fcr = Math.pow(0.658, Fy/Fe) * Fy;
        } else {
            // Elastic buckling
            Fcr = 0.877 * Fe;
        }
        
        points.push({ x: KLr, y: Fcr });
    }
    
    // Draw the graph
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw axes
    ctx.beginPath();
    ctx.moveTo(50, 350);
    ctx.lineTo(550, 350);
    ctx.moveTo(50, 350);
    ctx.lineTo(50, 50);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Draw labels
    ctx.font = '12px Arial';
    ctx.fillStyle = '#000';
    ctx.fillText('KL/r', 300, 380);
    
    // Y-axis label
    ctx.save();
    ctx.translate(20, 200);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('Fcr (ksi)', 0, 0);
    ctx.restore();
    
    // Draw title
    ctx.font = '16px Arial';
    ctx.fillText('AISC Column Curve', 220, 30);
    
    // Scale factors
    const xScale = 500 / maxKLr;
    const yScale = 300 / Fy;
    
    // Draw the curve
    ctx.beginPath();
    ctx.moveTo(50 + points[0].x * xScale, 350 - points[0].y * yScale);
    
    for (let i = 1; i < points.length; i++) {
        ctx.lineTo(50 + points[i].x * xScale, 350 - points[i].y * yScale);
    }
    
    ctx.strokeStyle = '#0066cc';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Draw transition point (4.71√(E/Fy))
    const transitionKLr = 4.71 * Math.sqrt(E / Fy);
    const transitionX = 50 + transitionKLr * xScale;
    
    ctx.beginPath();
    ctx.moveTo(transitionX, 350);
    ctx.lineTo(transitionX, 50);
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Add text for transition point
    ctx.font = '12px Arial';
    ctx.fillStyle = '#666';
    ctx.fillText(`Transition KL/r = ${transitionKLr.toFixed(1)}`, transitionX - 80, 40);
    
    // Draw the actual point on the curve
    ctx.beginPath();
    ctx.arc(50 + actualKLr * xScale, 350 - actualFcr * yScale, 6, 0, 2 * Math.PI);
    ctx.fillStyle = 'red';
    ctx.fill();
    
    // Add text for the actual point
    ctx.fillStyle = '#000';
    ctx.fillText(`Current: KL/r = ${actualKLr.toFixed(1)}, Fcr = ${actualFcr.toFixed(1)} ksi`, 
                 50 + actualKLr * xScale - 100, 350 - actualFcr * yScale - 15);
    
    // Add legend for AISC column curve regions
    ctx.font = '12px Arial';
    ctx.fillStyle = '#333';
    ctx.fillText('Inelastic Buckling', transitionX - 200, 70);
    ctx.fillText('Elastic Buckling', transitionX + 50, 70);
}

// Function to handle uploading actual ASTMSPEC.xlsx file
function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        
        // Process Sheet 1 - ASTM data
        const sheet1 = workbook.Sheets[workbook.SheetNames[0]];
        const steelData = XLSX.utils.sheet_to_json(sheet1);
        
        astmData = {};
        steelData.forEach(row => {
            if (row['Steel name']) {
                astmData[row['Steel name']] = {
                    Fy: row['Fy'] || 0,
                    Fu: row['Fu'] || 0
                };
            }
        });
        
        // Process Sheet 2 - W-shape data
        const sheet2 = workbook.Sheets[workbook.SheetNames[1]];
        const shapeData = XLSX.utils.sheet_to_json(sheet2);
        
        wShapesData = {};
        shapeData.forEach(row => {
            if (row['AISC_Manual_Label']) {
                wShapesData[row['AISC_Manual_Label']] = {
                    A: row['A'] || 0,
                    d: row['d'] || 0,
                    tw: row['tw'] || 0,
                    bf: row['bf'] || 0,
                    tf: row['tf'] || 0,
                    htw: row['h/tw'] || 0,
                    Ix: row['Ix'] || 0,
                    Zx: row['Zx'] || 0,
                    Sx: row['Sx'] || 0,
                    rx: row['rx'] || 0,
                    Iy: row['Iy'] || 0,
                    Zy: row['Zy'] || 0,
                    Sy: row['Sy'] || 0,
                    ry: row['ry'] || 0
                };
            }
        });
        
        dataLoaded = true;
        alert("Excel data loaded successfully!");
        
        // Update UI with available shapes
        updateShapeOptions();
    };
    
    reader.readAsArrayBuffer(file);
}

// Function to update the shape selection options based on loaded data
function updateShapeOptions() {
    const dimInput = document.getElementById('dimA');
    
    // Create a datalist for shape dimensions
    let datalist = document.getElementById('shape-dimensions');
    if (!datalist) {
        datalist = document.createElement('datalist');
        datalist.id = 'shape-dimensions';
        document.body.appendChild(datalist);
        
        // Connect the input to the datalist
        dimInput.setAttribute('list', 'shape-dimensions');
    }
    
    // Clear and populate datalist
    datalist.innerHTML = '';
    
    // Extract just the dimensions part from shape names (e.g., "12X45" from "W12X45")
    const dimensions = Object.keys(wShapesData)
        .map(key => key.substring(1)) // Remove the "W" prefix
        .filter((value, index, self) => self.indexOf(value) === index); // Unique values
    
    // Add options to datalist
    dimensions.forEach(dim => {
        const option = document.createElement('option');
        option.value = dim;
        datalist.appendChild(option);
    });
}



// Function to handle the visibility of the SupportA container
function handleSupportVisibility() {
    // Get the radio buttons and the SupportA container
    const supportRadio = document.getElementById('supportC');
    const noSupportRadio = document.getElementById('NosupportC');
    const supportContainer = document.getElementById('SupportC');
    
    // Show the SupportA container if the support radio is checked
    if (supportRadio.checked) {
      supportContainer.style.display = 'block';
    }
    // Hide the SupportA container if the Nosupport radio is checked
    else if (noSupportRadio.checked) {
      supportContainer.style.display = 'none';
    }
  }
  
 
// Function to handle the visibility of the SupportC container
function handleSupportVisibilityC() {
  // Get the radio buttons and the SupportC container
  const supportRadio = document.getElementById('supportC');
  const noSupportRadio = document.getElementById('NosupportC');
  const supportContainer = document.getElementById('SupportC');
  
  // Show the SupportC container if the support radio is checked
  if (supportRadio.checked) {
    supportContainer.style.display = 'block';
  }
  // Hide the SupportC container if the Nosupport radio is checked
  else if (noSupportRadio.checked) {
    supportContainer.style.display = 'none';
  }
}

// Add event listeners to both radio buttons
document.getElementById('supportC').addEventListener('change', handleSupportVisibilityC);
document.getElementById('NosupportC').addEventListener('change', handleSupportVisibilityC);

// Run the function once when the page loads to set the initial state
document.addEventListener('DOMContentLoaded', function() {
  // Check the initial state of the radio buttons and set visibility accordingly
  handleSupportVisibilityC();
});

document.addEventListener("DOMContentLoaded", function() {
    // Get references to DOM elements
    const noSupportRadio = document.getElementById("NosupportC");
    const withSupportRadio = document.getElementById("supportC");
    const supportCDiv = document.getElementById("SupportC");
    const supportAmountInput = document.getElementById("supprtamountC");
    const support1Div = document.getElementById("support1C");
    const support2Div = document.getElementById("support2C");
    const support3Div = document.getElementById("support3C");

    // Initially hide all support divs
    support1Div.style.display = "none";
    support2Div.style.display = "none";
    support3Div.style.display = "none";

    // Show/hide SupportC div based on radio button selection
    noSupportRadio.addEventListener("change", function() {
        if (this.checked) {
            supportCDiv.style.display = "none";
        }
    });

    withSupportRadio.addEventListener("change", function() {
        if (this.checked) {
            supportCDiv.style.display = "block";
            // When support is initially shown, update which support divs are visible
            updateSupportDivs();
        }
    });

    // Listen for changes to the support amount input
    supportAmountInput.addEventListener("input", updateSupportDivs);

    function updateSupportDivs() {
        const amount = parseInt(supportAmountInput.value) || 0;
        
        // Show/hide support divs based on amount
        support1Div.style.display = amount >= 1 ? "block" : "none";
        support2Div.style.display = amount >= 2 ? "block" : "none";
        support3Div.style.display = amount >= 3 ? "block" : "none";
    }

    // Initialize state based on initial values
    if (withSupportRadio.checked) {
        supportCDiv.style.display = "block";
        updateSupportDivs();
    } else {
        supportCDiv.style.display = "none";
    }
});

document.addEventListener("DOMContentLoaded", function() {
    // Add containers for both visualizations after the page loads
    const graphicalColumnContainer = document.querySelector('.GraphicalColumn');
   
    
    graphicalColumnContainer.innerHTML = `
        <div style="display: flex; flex-wrap: wrap; gap: 20px; margin-top: 20px;">
            <!-- Y-axis visualization (with lateral supports) -->
            <div class="visualization-container" style="flex: 1; min-width: 300px; height: 500px; border: 1px solid #ccc; position: relative; overflow: hidden;">
                <h3 style="text-align: center; margin: 5px 0;">Y-Axis Visualization (Lateral Supports)</h3>
                <div id="beam-visualization-y-c" style="width: 100%; height: 450px; position: relative;">
                    <!-- SVG will be inserted here -->
                </div>
            </div>
            
            <!-- X-axis visualization (without lateral supports) -->
            <div class="visualization-container" style="flex: 1; min-width: 300px; height: 500px; border: 1px solid #ccc; position: relative; overflow: hidden;">
                <h3 style="text-align: center; margin: 5px 0;">X-Axis Visualization (Full Length)</h3>
                <div id="beam-visualization-x-c" style="width: 100%; height: 450px; position: relative;">
                    <!-- SVG will be inserted here -->
                </div>
            </div>
        </div>
    `;
    

    // Get all the input elements we need to monitor
    const lengthInput = document.getElementById("LenghtDC");
    const supportRadio = document.getElementById("supportC");
    const noSupportRadio = document.getElementById("NosupportC");
    const supportAmountInput = document.getElementById("supprtamountC");
    const locationInputs = [
        document.getElementById("location1C"),
        document.getElementById("location2C"),
        document.getElementById("location3C")
    ];
    
    // Top support options
    const topFixed = document.getElementById("topfixedC");
    const topPinned = document.getElementById("toppinnedC");
    const topFree = document.getElementById("topfreeC");
    
    // Bottom support options
    const botFixed = document.getElementById("botfixedC");
    const botPinned = document.getElementById("botpinnedC");
    const botFree = document.getElementById("botfreeC");
    
    // Lateral support options
    const lateralSupportTypes = [
        {
            pinned: document.getElementById("pinned1C"),
            fixed: document.getElementById("fixed1C"),
            free: document.getElementById("Free1C")
        },
        {
            pinned: document.getElementById("pinned2C"),
            fixed: document.getElementById("fixed2C"),
            free: document.getElementById("Free2C")
        },
        {
            pinned: document.getElementById("pinned3C"),
            fixed: document.getElementById("fixed3C"),
            free: document.getElementById("Free3C")
        }
    ];

    // Design button
    

    // Initial drawing
    drawBeamColumns();

    // Add event listeners to all inputs that should trigger a redraw
    lengthInput.addEventListener("input", drawBeamColumns);
    supportRadio.addEventListener("change", drawBeamColumns);
    noSupportRadio.addEventListener("change", drawBeamColumns);
    supportAmountInput.addEventListener("input", drawBeamColumns);
    
    for (let i = 0; i < locationInputs.length; i++) {
        if (locationInputs[i]) {
            locationInputs[i].addEventListener("input", drawBeamColumns);
        }
    }
    
    // Top support options
    if (topFixed) topFixed.addEventListener("change", drawBeamColumns);
    if (topPinned) topPinned.addEventListener("change", drawBeamColumns);
    if (topFree) topFree.addEventListener("change", drawBeamColumns);
    
    // Bottom support options
    if (botFixed) botFixed.addEventListener("change", drawBeamColumns);
    if (botPinned) botPinned.addEventListener("change", drawBeamColumns);
    if (botFree) botFree.addEventListener("change", drawBeamColumns);
    
    // Lateral support options
    for (let i = 0; i < lateralSupportTypes.length; i++) {
        if (lateralSupportTypes[i].pinned) lateralSupportTypes[i].pinned.addEventListener("change", drawBeamColumns);
        if (lateralSupportTypes[i].fixed) lateralSupportTypes[i].fixed.addEventListener("change", drawBeamColumns);
        if (lateralSupportTypes[i].free) lateralSupportTypes[i].free.addEventListener("change", drawBeamColumns);
    }
    
    if (designButtonc) {
        designButtonc.addEventListener("click", drawBeamColumns);
    }

    function drawBeamColumns() {
        // Draw both visualizations
        drawYAxisBeam();
        drawXAxisBeam();
    }

    function drawYAxisBeam() {
        const beamVisualization = document.getElementById("beam-visualization-y-c");
        if (!beamVisualization) return;

        // Get the current values from the form
        const columnLength = parseFloat(lengthInput.value) || 16; // Default to 16 if not specified
        const hasLateralSupports = supportRadio && supportRadio.checked;
        const supportCount = hasLateralSupports ? parseInt(supportAmountInput.value) || 0 : 0;
        
        // Get support locations and sort them by position
        const supportLocations = [];
        if (hasLateralSupports) {
            for (let i = 0; i < supportCount && i < 3; i++) {
                if (locationInputs[i]) {
                    const location = parseFloat(locationInputs[i].value) || 0;
                    if (location > 0 && location < columnLength) {
                        supportLocations.push({
                            position: location,
                            type: lateralSupportTypes[i].fixed && lateralSupportTypes[i].fixed.checked ? "fixed" :
                                  lateralSupportTypes[i].pinned && lateralSupportTypes[i].pinned.checked ? "pinned" : "free",
                            index: i + 1
                        });
                    }
                }
            }
        }
        
        // Sort support locations by position
        supportLocations.sort((a, b) => a.position - b.position);
        
        // Get end supports
        const topSupport = topFixed && topFixed.checked ? "fixed" : 
                          topPinned && topPinned.checked ? "pinned" : "free";
        const botSupport = botFixed && botFixed.checked ? "fixed" : 
                          botPinned && botPinned.checked ? "pinned" : "free";

        // Calculate dimensions
        const svgWidth = beamVisualization.clientWidth;
        const svgHeight = beamVisualization.clientHeight;
        const margin = { top: 20, right: 40, bottom: 40, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        
        // Scale factors
        const yScale = height / columnLength;
        
        // Determine segment points (top, all supports, bottom)
        const segmentPoints = [0, ...supportLocations.map(s => s.position), columnLength];
        
        // Create the SVG
        const svg = `
            <svg width="${svgWidth}" height="${svgHeight}">
                <g transform="translate(${margin.left}, ${margin.top})">
                    <!-- Column shaft (W-shape) showing front and side view -->
                    <!-- Front view (Y-axis) -->
                    <path d="M ${width/2-15} 0 
                             L ${width/2-15} ${columnLength * yScale}
                             M ${width/2+15} 0
                             L ${width/2+15} ${columnLength * yScale}
                             M ${width/2-25} 0
                             L ${width/2+25} 0
                             M ${width/2-25} ${columnLength * yScale}
                             L ${width/2+25} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                    
                    <!-- "Y" label below the beam -->
                    <text x="${width/2}" y="${columnLength * yScale + 35}" 
                          text-anchor="middle" font-size="16" font-weight="bold">
                        Y
                    </text>
                    
                    <!-- Top support -->
                    ${renderSupport(width/2, 0, topSupport, "top")}
                    
                    <!-- Bottom support -->
                    ${renderSupport(width/2, columnLength * yScale, botSupport, "bottom")}
                    
                    <!-- Lateral supports -->
                    ${supportLocations.map(support => 
                        renderLateralSupport(width/2, support.position * yScale, support.type)
                    ).join('')}
                    
                    <!-- Column height label -->
                    <text x="${width/3  }" y="${columnLength * yScale / 2}" 
                          transform="rotate(360, ${width/2 + 40}, ${columnLength * yScale / 2})"
                          text-anchor="middle" dominant-baseline="middle" font-size="12">
                        ${columnLength}' Column Length
                    </text>
                    
                    <!-- Support location labels -->
                    ${supportLocations.map((support) => `
                        <text x="${width/2 - 40}" y="${support.position * yScale}"
                              text-anchor="end" dominant-baseline="middle" font-size="12">
                            Support ${support.index}: ${support.position}'
                        </text>
                    `).join('')}
                    
                    <!-- Segment labels (y1, y2, etc.) -->
                    ${segmentPoints.slice(0, -1).map((startPoint, i) => {
                        const endPoint = segmentPoints[i + 1];
                        const segmentLength = endPoint - startPoint;
                        const midPoint = (startPoint + endPoint) / 2;
                        
                        return `
                            <!-- y${i+1} segment label -->
                            <text x="${width/2 + 30}" y="${(startPoint + (segmentLength/2)) * yScale}"
                                  text-anchor="start" dominant-baseline="middle" font-size="14" fill="blue" font-weight="bold">
                                y${i+1} = ${segmentLength.toFixed(2)}'
                            </text>
                            
                            <!-- Segment marker lines -->
                            <line x1="${width/2 + 15}" y1="${startPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${startPoint * yScale}"
                                  stroke="blue" stroke-width="1" />
                            <line x1="${width/2 + 15}" y1="${endPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${endPoint * yScale}"
                                  stroke="blue" stroke-width="1" />
                            
                            <!-- Connecting line for segment -->
                            <line x1="${width/2 + 25}" y1="${startPoint * yScale}" 
                                  x2="${width/2 + 25}" y2="${endPoint * yScale}"
                                  stroke="blue" stroke-width="1" stroke-dasharray="4,2" />
                        `;
                    }).join('')}
                </g>
            </svg>
        `;
        
        beamVisualization.innerHTML = svg;
    }
    
    function drawXAxisBeam() {
        const beamVisualization = document.getElementById("beam-visualization-x-c");
        if (!beamVisualization) return;

        // Get the current values from the form
        const columnLength = parseFloat(lengthInput.value) || 16; // Default to 16 if not specified
        
        // Get end supports
        const topSupport = topFixed && topFixed.checked ? "fixed" : 
                          topPinned && topPinned.checked ? "pinned" : "free";
        const botSupport = botFixed && botFixed.checked ? "fixed" : 
                          botPinned && botPinned.checked ? "pinned" : "free";

        // Calculate dimensions
        const svgWidth = beamVisualization.clientWidth;
        const svgHeight = beamVisualization.clientHeight;
        const margin = { top: 20, right: 40, bottom: 40, left: 60 };
        const width = svgWidth - margin.left - margin.right;
        const height = svgHeight - margin.top - margin.bottom;
        
        // Scale factors
        const yScale = height / columnLength;
        
        // Create the SVG - showing the beam from the side (X-axis view)
        const svg = `
            <svg width="${svgWidth}" height="${svgHeight}">
                <g transform="translate(${margin.left}, ${margin.top})">
                    <!-- Column shaft (W-shape) - side view (X-axis) -->
                    <path d="M ${width/2-25} 0 
                             L ${width/2-25} ${columnLength * yScale}
                             M ${width/2+25} 0
                             L ${width/2+25} ${columnLength * yScale}
                             M ${width/2-25} 0
                             L ${width/2+25} 0
                             M ${width/2-25} ${columnLength * yScale}
                             L ${width/2+25} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                          
                    <!-- Web of the W-shape (showing flange depth) -->
                    <path d="M ${width/2-10} 0 
                             L ${width/2-10} ${columnLength * yScale}
                             M ${width/2+10} 0
                             L ${width/2+10} ${columnLength * yScale}"
                          stroke="black" stroke-width="2" fill="none" />
                    
                    <!-- "X" label below the beam -->
                    <text x="${width/2}" y="${columnLength * yScale + 35}" 
                          text-anchor="middle" font-size="16" font-weight="bold">
                        X
                    </text>
                    
                    <!-- Top support -->
                    ${renderSupport(width/2, 0, topSupport, "top")}
                    
                    <!-- Bottom support -->
                    ${renderSupport(width/2, columnLength * yScale, botSupport, "bottom")}
                    
                    <!-- Full column length label -->
                    <text x="${width/3 }" y="${columnLength * yScale / 2}" 
                          transform="rotate(360, ${width/2 + 40}, ${columnLength * yScale / 2})"
                          text-anchor="middle" dominant-baseline="middle" font-size="12">
                        ${columnLength}' Column Length
                    </text>
                    
                    <!-- Main segment label for X-axis view -->
                    <text x="${width/2 + 30}" y="${columnLength * yScale / 2}"
                          text-anchor="start" dominant-baseline="middle" font-size="14" fill="blue" font-weight="bold">
                        y1 = ${columnLength.toFixed(2)}'
                    </text>
                    
                    <!-- Segment marker lines -->
                    <line x1="${width/2 + 25}" y1="0" 
                          x2="${width/2 + 35}" y2="0"
                          stroke="blue" stroke-width="1" />
                    <line x1="${width/2 + 25}" y1="${columnLength * yScale}" 
                          x2="${width/2 + 35}" y2="${columnLength * yScale}"
                          stroke="blue" stroke-width="1" />
                    
                    <!-- Connecting line for segment -->
                    <line x1="${width/2 + 35}" y1="0" 
                          x2="${width/2 + 35}" y2="${columnLength * yScale}"
                          stroke="blue" stroke-width="1" stroke-dasharray="4,2" />
                </g>
            </svg>
        `;
        
        beamVisualization.innerHTML = svg;
    }
    
    function renderSupport(x, y, type, position) {
        if (type === "fixed") {
            // Fixed support (triangle with hatching)
            const direction = position === "top" ? -1 : 1;
            return `
                <path d="M ${x-30} ${y + (direction * 10)} 
                         L ${x+30} ${y + (direction * 10)}
                         L ${x} ${y}"
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching lines for fixed support -->
                ${Array.from({length: 7}, (_, i) => 
                    `<line x1="${x-25 + i*10}" y1="${y + (direction * 10)}" 
                           x2="${x-25 + i*10}" y2="${y + (direction * 5)}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
            `;
        } else if (type === "pinned") {
            // Pinned support (triangle)
            const direction = position === "top" ? -1 : 1;
            return `
                <path d="M ${x-30} ${y + (direction * 10)} 
                         L ${x+30} ${y + (direction * 10)}
                         L ${x} ${y}"
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Circles to represent pins -->
                <circle cx="${x}" cy="${y}" r="3" fill="black" />
            `;
        } else { // free
            // Free end (nothing)
            return '';
        }
    }
    
    function renderLateralSupport(x, y, type) {
        if (type === "fixed") {
            // Fixed lateral support (square block with hatching)
            return `
                <rect x="${x+20}" y="${y-10}" width="20" height="20" 
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching for fixed support -->
                ${Array.from({length: 4}, (_, i) => 
                    `<line x1="${x+20}" y1="${y-10 + i*5}" 
                           x2="${x+40}" y2="${y-10 + i*5}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
                <!-- Line connecting to column -->
                <line x1="${x+15}" y1="${y}" x2="${x+20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                
                <!-- Left side support - mirror image -->
                <rect x="${x-40}" y="${y-10}" width="20" height="20" 
                      stroke="black" stroke-width="2" fill="none" />
                <!-- Hatching for fixed support -->
                ${Array.from({length: 4}, (_, i) => 
                    `<line x1="${x-40}" y1="${y-10 + i*5}" 
                           x2="${x-20}" y2="${y-10 + i*5}"
                           stroke="black" stroke-width="1" />`
                ).join('')}
                <!-- Line connecting to column -->
                <line x1="${x-15}" y1="${y}" x2="${x-20}" y2="${y}"
                      stroke="black" stroke-width="2" />
            `;
        } else if (type === "pinned") {
            // Pinned lateral support (roller)
            return `
                <!-- Right side -->
                <circle cx="${x+30}" cy="${y}" r="10" 
                        stroke="black" stroke-width="2" fill="none" />
                <!-- Line connecting to column -->
                <line x1="${x+15}" y1="${y}" x2="${x+20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                <!-- Small circle for pin -->
                <circle cx="${x+20}" cy="${y}" r="3" fill="black" />
                
                <!-- Left side - mirror image -->
                <circle cx="${x-30}" cy="${y}" r="10" 
                        stroke="black" stroke-width="2" fill="none" />
                <!-- Line connecting to column -->
                <line x1="${x-15}" y1="${y}" x2="${x-20}" y2="${y}"
                      stroke="black" stroke-width="2" />
                <!-- Small circle for pin -->
                <circle cx="${x-20}" cy="${y}" r="3" fill="black" />
            `;
        } else { // free
            // Free lateral support (just a line to indicate position)
            return `
                <line x1="${x-40}" y1="${y}" x2="${x+40}" y2="${y}"
                      stroke="blue" stroke-width="1" stroke-dasharray="5,5" />
            `;
        }
    }
});

// Column Load Capacity Calculator - Fixed Version
document.addEventListener("DOMContentLoaded", function() {
    // Initialize the application with error handling
    initializeColumnCalculator();
});

// Main initialization function
function initializeColumnCalculator() {
    try {
        console.log("Initializing Column Load Capacity Calculator...");
        
        // Get references to input elements with error checking
        const designButton = getRequiredElement("DesignC", "Design button");
        const astmSelect = getRequiredElement("ASTMinputC", "ASTM specification selector");
        const designMethodSelect = getRequiredElement("designMethod", "Design method selector");
        const deadLoadInput = getRequiredElement("DeadLoad", "Dead load input");
        const liveLoadInput = getRequiredElement("LiveLoad", "Live load input");
        const lengthInput = getRequiredElement("LenghtDC", "Column length input");
        
        // Get references to support options
        const topFixed = document.getElementById("topfixedC");
        const topPinned = document.getElementById("toppinnedC");
        const topFree = document.getElementById("topfreeC");
        const botFixed = document.getElementById("botfixedC");
        const botPinned = document.getElementById("botpinnedC");
        const botFree = document.getElementById("botfreeC");
        const noSupport = document.getElementById("NosupportC");
        const withSupport = document.getElementById("supportC");
        const supportAmountInput = document.getElementById("supprtamountC");
        
        // Get references to lateral support options
        const lateralSupportTypes = [
            {
                fixed: document.getElementById("fixed1C"),
                pinned: document.getElementById("pinned1C"),
                free: document.getElementById("Free1C"),
                location: document.getElementById("location1C")
            },
            {
                fixed: document.getElementById("fixed2C"),
                pinned: document.getElementById("pinned2C"),
                free: document.getElementById("Free2C"),
                location: document.getElementById("location2C")
            },
            {
                fixed: document.getElementById("fixed3C"),
                pinned: document.getElementById("pinned3C"),
                free: document.getElementById("Free3C"),
                location: document.getElementById("location3C")
            }
        ];
        
        // Set up event listeners
        setupEventListeners(designButton, noSupport, withSupport);
        
        console.log("Column Calculator initialized successfully");
    } catch (error) {
        console.error("Error initializing Column Calculator:", error);
        displayErrorMessage("Failed to initialize the column calculator. Please check console for details.");
    }
}

// Helper function to get required DOM elements
function getRequiredElement(id, description) {
    const element = document.getElementById(id);
    if (!element) {
        throw new Error(`Required ${description} (ID: ${id}) not found in document`);
    }
    return element;
}

// Function to set up event listeners
function setupEventListeners(designButton, noSupport, withSupport) {
    // Add event listener to design button
    if (designButton) {
        designButton.addEventListener("click", performDesign);
        console.log("Design button event listener attached");
    } else {
        console.warn("Design button not found, calculation functionality will be limited");
    }
    
    // Add event listeners to support radio buttons
    if (noSupport) {
        noSupport.addEventListener("change", handleSupportVisibilityC);
    }
    if (withSupport) {
        withSupport.addEventListener("change", handleSupportVisibilityC);
    }
    
    // Call support visibility handler to set initial state
    handleSupportVisibilityC();
}

// Display error message to user
function displayErrorMessage(message) {
    // Create error message element
    const errorDiv = document.createElement("div");
    errorDiv.className = "error-message";
    errorDiv.style.color = "red";
    errorDiv.style.padding = "10px";
    errorDiv.style.marginBottom = "10px";
    errorDiv.style.backgroundColor = "#ffeeee";
    errorDiv.style.border = "1px solid red";
    errorDiv.style.borderRadius = "5px";
    errorDiv.textContent = message;
    
    // Find a good place to display it
    const resultDiv = document.querySelector(".Result123");
    if (resultDiv) {
        resultDiv.prepend(errorDiv);
    } else {
        // If result div not found, insert at beginning of body
        const body = document.querySelector("body");
        if (body && body.firstChild) {
            body.insertBefore(errorDiv, body.firstChild);
        }
    }
}

// Handle lateral support visibility
function handleSupportVisibilityC() {
    try {
        const supportCDiv = document.getElementById("SupportC");
        const withSupport = document.getElementById("supportC");
        
        if (supportCDiv) {
            if (withSupport && withSupport.checked) {
                supportCDiv.style.display = "block";
            } else {
                supportCDiv.style.display = "none";
            }
        } else {
            console.warn("Support div container not found");
        }
    } catch (error) {
        console.error("Error handling support visibility:", error);
    }
}

// Function to perform the column design calculations
function performDesign() {
    console.log("Performing column design calculations...");
    
    try {
        // Get load values
        const deadLoad = parseFloat(document.getElementById("DeadLoad").value) || 0;
        const liveLoad = parseFloat(document.getElementById("LiveLoad").value) || 0;
        const columnLength = parseFloat(document.getElementById("LenghtDC").value) || 0;
        
        // Get ASTM specification
        const astmSpec = document.getElementById("ASTMinputC").value;
        
        // Get design method
        const designMethod = document.getElementById("designMethod").value;
        
        // Store DL and LL
        const DL = deadLoad;
        const LL = liveLoad;
        
        // Get support conditions
        const topSupport = getEndSupportCondition("top");
        const botSupport = getEndSupportCondition("bot");
        
        // Determine k-factor for X-axis based on end supports
        const kFactorX = determineKFactorX(topSupport, botSupport);
        
        // Get lateral support information
        const hasLateralSupports = document.getElementById("supportC").checked;
        const supportCount = hasLateralSupports ? 
            parseInt(document.getElementById("supprtamountC").value) || 0 : 0;
        
        // Get lateral support locations and types
        const lateralSupports = [];
        if (hasLateralSupports) {
            for (let i = 1; i <= supportCount; i++) {
                const location = parseFloat(document.getElementById(`location${i}C`).value) || 0;
                const type = getLateralSupportType(i);
                if (location > 0 && location < columnLength) {
                    lateralSupports.push({
                        position: location,
                        type: type
                    });
                }
            }
        }
        
        // Sort lateral supports by position
        lateralSupports.sort((a, b) => a.position - b.position);
        
        // Calculate segments for Y-axis
        const segments = calculateSegments(columnLength, lateralSupports);
        
        // Determine k-factors for Y-axis segments
        const kFactorsY = segments.map(segment => {
            const startSupport = segment.startType;
            const endSupport = segment.endType;
            return determineKFactorY(startSupport, endSupport);
        });
        
        // Calculate KL values for X and Y axes
        const KLx = kFactorX * columnLength;
        
        // Calculate KL values for Y-axis segments
        const KLySegments = segments.map((segment, index) => {
            return {
                segmentLength: segment.length,
                kFactor: kFactorsY[index],
                KL: kFactorsY[index] * segment.length
            };
        });
        
        // Find governing KLy (maximum KL value)
        const governingKLy = Math.max(...KLySegments.map(segment => segment.KL));
        
        // Determine steel properties
        const steelProperties = getSteelProperties(astmSpec);
        const Fy = steelProperties.Fy;
        const Fu = steelProperties.Fu;
        
        // Generate table with results
        displayResults(DL, LL, columnLength, kFactorX, KLx, segments, kFactorsY, KLySegments, governingKLy, Fy, Fu, designMethod);
        
        // Store values for future use
        storeDesignValues(DL, LL, columnLength, KLx, governingKLy, Fy, Fu, designMethod);
        
        console.log("Design calculations completed successfully");
        
        // Add delay before processing Excel export
        setTimeout(() => {
            exportToExcel();
        }, 1500);
        
    } catch (error) {
        console.error("Error performing design calculations:", error);
        displayErrorMessage("An error occurred during calculation. Please check your inputs and try again.");
    }
}

// Display error message
function displayErrorMessage(message) {
    const resultDiv = document.querySelector(".ResultofallCD");
    if (resultDiv) {
        resultDiv.innerHTML = `<div class="alert alert-danger">${message}</div>`;
    } else {
        console.error("Result div not found");
        alert(message);
    }
}

// Get the end support condition for top or bottom
function getEndSupportCondition(position) {
    if (position === "top") {
        if (document.getElementById("topfixedC").checked) return "fixed";
        if (document.getElementById("toppinnedC").checked) return "pinned";
        if (document.getElementById("topfreeC").checked) return "free";
    } else if (position === "bot") {
        if (document.getElementById("botfixedC").checked) return "fixed";
        if (document.getElementById("botpinnedC").checked) return "pinned";
        if (document.getElementById("botfreeC").checked) return "free";
    }
    return "pinned"; // Default to pinned if not specified
}

// Get the lateral support type for a specific support
function getLateralSupportType(supportIndex) {
    if (document.getElementById(`fixed${supportIndex}C`).checked) return "fixed";
    if (document.getElementById(`pinned${supportIndex}C`).checked) return "pinned";
    if (document.getElementById(`Free${supportIndex}C`).checked) return "free";
    return "free"; // Default to free if not specified
}

// Calculate segments between supports
function calculateSegments(columnLength, lateralSupports) {
    const segments = [];
    
    // If no lateral supports, entire column is one segment
    if (lateralSupports.length === 0) {
        segments.push({
            start: 0,
            end: columnLength,
            length: columnLength,
            startType: getEndSupportCondition("top"),
            endType: getEndSupportCondition("bot")
        });
        return segments;
    }
    
    // First segment (from top to first support)
    segments.push({
        start: 0,
        end: lateralSupports[0].position,
        length: lateralSupports[0].position,
        startType: getEndSupportCondition("top"),
        endType: lateralSupports[0].type
    });
    
    // Middle segments (between supports)
    for (let i = 0; i < lateralSupports.length - 1; i++) {
        segments.push({
            start: lateralSupports[i].position,
            end: lateralSupports[i + 1].position,
            length: lateralSupports[i + 1].position - lateralSupports[i].position,
            startType: lateralSupports[i].type,
            endType: lateralSupports[i + 1].type
        });
    }
    
    // Last segment (from last support to bottom)
    segments.push({
        start: lateralSupports[lateralSupports.length - 1].position,
        end: columnLength,
        length: columnLength - lateralSupports[lateralSupports.length - 1].position,
        startType: lateralSupports[lateralSupports.length - 1].type,
        endType: getEndSupportCondition("bot")
    });
    
    return segments;
}

// Determine k-factor for X-axis based on end supports
function determineKFactorX(topSupport, botSupport) {
    // Theoretical K factors based on AISC Column Design Guide
    if (topSupport === "fixed" && botSupport === "fixed") return 0.65; // Fixed-Fixed
    if (topSupport === "fixed" && botSupport === "pinned") return 0.80; // Fixed-Pinned
    if (topSupport === "fixed" && botSupport === "free") return 2.10; // Fixed-Free (cantilever)
    if (topSupport === "pinned" && botSupport === "pinned") return 1.0; // Pinned-Pinned
    if (topSupport === "pinned" && botSupport === "fixed") return 0.80; // Pinned-Fixed
    if (topSupport === "pinned" && botSupport === "free") return 2.0; // Pinned-Free
    if (topSupport === "free" && botSupport === "fixed") return 2.10; // Free-Fixed
    if (topSupport === "free" && botSupport === "pinned") return 2.0; // Free-Pinned
    
    // Default to pinned-pinned if combination not recognized
    return 1.0;
}

// Determine k-factor for Y-axis segment based on end supports
function determineKFactorY(startSupport, endSupport) {
    // Same logic as X-axis
    return determineKFactorX(startSupport, endSupport);
}

// Get steel properties based on ASTM specification
function getSteelProperties(astmSpec) {
    // Steel properties in ksi (yield and ultimate strengths)
    const steelProperties = {
        "A36": { Fy: 36, Fu: 58 },
        "A572Gr.42": { Fy: 42, Fu: 60 },
        "A572Gr.50": { Fy: 50, Fu: 65 },
        "A572Gr.55": { Fy: 55, Fu: 70 },
        "A572Gr.60": { Fy: 60, Fu: 75 },
        "A572Gr.65": { Fy: 65, Fu: 80 },
        "A588Gr.42": { Fy: 42, Fu: 63 },
        "A588Gr.46": { Fy: 46, Fu: 67 },
        "A588Gr.50": { Fy: 50, Fu: 70 },
        "A687": { Fy: 50, Fu: 70 },
        "A992": { Fy: 50, Fu: 65 }
    };
    
    return steelProperties[astmSpec] || { Fy: 36, Fu: 58 }; // Default to A36 if not found
}

// Display results in the ResultofallCD div
function displayResults(DL, LL, columnLength, kFactorX, KLx, segments, kFactorsY, KLySegments, governingKLy, Fy, Fu, designMethod) {
    const resultDiv = document.querySelector(".ResultofallCD");
    
    if (!resultDiv) {
        console.error("Result div not found");
        return;
    }
    
    // Create table HTML
    let tableHTML = `
        <h2>Column Design Results</h2>
        <table border="1" style="width: 100%; border-collapse: collapse;">
            <tr>
                <th colspan="2">Design Parameters</th>
                <th colspan="2">Material Properties</th>
            </tr>
            <tr>
                <td>Dead Load (DL):</td>
                <td>${DL.toFixed(2)} kips</td>
                <td>Yield Strength (Fy):</td>
                <td>${Fy} ksi</td>
            </tr>
            <tr>
                <td>Live Load (LL):</td>
                <td>${LL.toFixed(2)} kips</td>
                <td>Ultimate Strength (Fu):</td>
                <td>${Fu} ksi</td>
            </tr>
            <tr>
                <td>Column Length:</td>
                <td>${columnLength.toFixed(2)} ft</td>
                <td>Design Method:</td>
                <td>${designMethod}</td>
            </tr>
        </table>
        
        <h3>X-Axis Analysis</h3>
        <table border="1" style="width: 100%; border-collapse: collapse;">
            <tr>
                <th>Segment</th>
                <th>Length (ft)</th>
                <th>K Factor</th>
                <th>KL (ft)</th>
            </tr>
            <tr>
                <td>Full Length</td>
                <td>${columnLength.toFixed(2)}</td>
                <td>${kFactorX.toFixed(2)}</td>
                <td>${KLx.toFixed(2)}</td>
            </tr>
        </table>
        
        <h3>Y-Axis Analysis</h3>
        <table border="1" style="width: 100%; border-collapse: collapse;">
            <tr>
                <th>Segment</th>
                <th>Length (ft)</th>
                <th>K Factor</th>
                <th>KL (ft)</th>
            </tr>
    `;
    
    // Add rows for each Y-axis segment
    KLySegments.forEach((segment, index) => {
        tableHTML += `
            <tr>
                <td>y${index + 1}</td>
                <td>${segment.segmentLength.toFixed(2)}</td>
                <td>${segment.kFactor.toFixed(2)}</td>
                <td>${segment.KL.toFixed(2)}</td>
            </tr>
        `;
    });
    
    tableHTML += `
        </table>
        
        <h3>Governing Values</h3>
        <table border="1" style="width: 100%; border-collapse: collapse;">
            <tr>
                <th>Parameter</th>
                <th>Value</th>
            </tr>
            <tr>
                <td>Governing KLx:</td>
                <td>${KLx.toFixed(2)} ft</td>
            </tr>
            <tr>
                <td>Governing KLy:</td>
                <td>${governingKLy.toFixed(2)} ft</td>
            </tr>
            <tr>
                <td>Critical KL (max of KLx, KLy):</td>
                <td>${Math.max(KLx, governingKLy).toFixed(2)} ft</td>
            </tr>
        </table>
        
        <div class="downlaod">
            <p>Processing data for Excel export, please wait...</p>
        </div>
    `;
    
    resultDiv.innerHTML = tableHTML;
}

// Store design values for future use
function storeDesignValues(DL, LL, Length, KLx, KLy, Fy, Fu, designMethod) {
    // Store values in localStorage or a global variable for export
    window.columnDesignValues = {
        deadLoad: DL,
        liveLoad: LL,
        columnLength: Length,
        effectiveLengthX: KLx,
        effectiveLengthY: KLy,
        yieldStrength: Fy,
        ultimateStrength: Fu,
        designMethod: designMethod
    };
    
    console.log("Design values stored:", window.columnDesignValues);
}


// Function to export design values to Excel
function exportToExcel() {
    try {
        // Check if we have stored design values
        if (!window.columnDesignValues) {
            console.error("No design values to export");
            return;
        }
        
        const values = window.columnDesignValues;
        console.log("Exporting values to Excel:", values);
        
        // Load the ExcelJS library dynamically if not already loaded
        if (typeof ExcelJS === 'undefined') {
            console.log("Loading ExcelJS...");
            
            // Create a loading message
            const downloadDiv = document.querySelector('.downlaod');
            if (downloadDiv) {
                downloadDiv.innerHTML = '<p>Loading Excel libraries, please wait...</p>';
            }
            
            // Load ExcelJS from CDN
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js';
                script.onload = resolve;
                script.onerror = () => reject(new Error('Failed to load ExcelJS'));
                document.head.appendChild(script);
            })
            .then(() => {
                // Continue with Excel processing once library is loaded
                continueExcelProcessing(values);
            })
            .catch(error => {
                console.error("Error loading ExcelJS:", error);
                const downloadDiv = document.querySelector('.downlaod');
                if (downloadDiv) {
                    downloadDiv.innerHTML = `<p>Error loading Excel libraries: ${error.message}</p>`;
                }
            });
        } else {
            // ExcelJS is already loaded, continue processing
            continueExcelProcessing(values);
        }
    } catch (error) {
        console.error("Error in exportToExcel:", error);
        window.alert("Error preparing Excel export: " + error.message);
    }
}

// Continue Excel processing with ExcelJS
function continueExcelProcessing(values) {
    // Fetch the Excel file
    fetch('COMPRESSION-1.xlsx')
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to load Excel file');
            }
            return response.arrayBuffer();
        })
        .then(async (arrayBuffer) => {
            try {
                // Create a new Excel workbook from the array buffer
                const workbook = new ExcelJS.Workbook();
                await workbook.xlsx.load(arrayBuffer);
                
                // Get the first worksheet
                const worksheet = workbook.worksheets[0];
                
                // Update cell values without changing formatting
                // We only update the cell value property
                updateCellValue(worksheet, 'C35', values.deadLoad);
                updateCellValue(worksheet, 'C36', values.liveLoad);
                updateCellValue(worksheet, 'B31', values.yieldStrength);
                updateCellValue(worksheet, 'B32', values.ultimateStrength);
                updateCellValue(worksheet, 'C39', values.effectiveLengthX);
                updateCellValue(worksheet, 'C40', values.effectiveLengthY);
                
                // Write to buffer
                const buffer = await workbook.xlsx.writeBuffer();
                
                // Convert buffer to Blob
                const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                
                // Create download link
                const url = URL.createObjectURL(blob);
                
                // Update download div with link
                const downloadDiv = document.querySelector('.downlaod');
                if (downloadDiv) {
                    downloadDiv.innerHTML = `
                        <a href="${url}" download="COMPRESSION-1.xlsx" class="btn btn-success">
                            Download Updated Excel File
                        </a>
                    `;
                    console.log("Download link created");
                } else {
                    console.error("Download div not found");
                    
                    // Create and trigger download
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'COMPRESSION-1.xlsx';
                    document.body.appendChild(a);
                    a.click();
                    
                    // Clean up
                    setTimeout(() => {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                    }, 0);
                }
            } catch (error) {
                console.error("Error processing Excel file:", error);
                const downloadDiv = document.querySelector('.downlaod');
                if (downloadDiv) {
                    downloadDiv.innerHTML = `<p>Error processing Excel file: ${error.message}</p>`;
                } else {
                    window.alert("Error processing Excel file: " + error.message);
                }
            }
        })
        .catch(error => {
            console.error("Error fetching Excel file:", error);
            const downloadDiv = document.querySelector('.downlaod');
            if (downloadDiv) {
                downloadDiv.innerHTML = `<p>Error fetching Excel file: ${error.message}</p>`;
            } else {
                window.alert("Error fetching Excel file: " + error.message);
            }
        });
}

// Helper function to update cell value without modifying formatting
function updateCellValue(worksheet, cellRef, newValue) {
    // Parse cell reference (e.g., 'A1' into column and row)
    const colLetters = cellRef.replace(/[0-9]/g, '');
    const rowNum = parseInt(cellRef.replace(/[^0-9]/g, ''));
    
    // Get the column number from column letters
    let colNum = 0;
    for (let i = 0; i < colLetters.length; i++) {
        colNum = colNum * 26 + (colLetters.charCodeAt(i) - 64);
    }
    
    // Get the cell at the specified position
    const cell = worksheet.getCell(rowNum, colNum);
    
    // Update only the value, preserving all other properties and formatting
    cell.value = newValue;
}

// Update the DOM content loaded event listener to include ExcelJS
document.addEventListener("DOMContentLoaded", function() {
    console.log("DOM loaded, initializing...");
    
    // Attach event listener to Design button
    const designButton = document.getElementById("DesignC");
    if (designButton) {
        // Remove any existing event listeners first
        const newButton = designButton.cloneNode(true);
        designButton.parentNode.replaceChild(newButton, designButton);
        
        // Add our event listener
        newButton.addEventListener("click", function(e) {
            e.preventDefault();
            console.log("Design button clicked, calling performDesign()");
            performDesign();
        });
        console.log("Design button event listener attached");
    } else {
        console.error("Design button with ID 'DesignC' not found in the DOM");
    }
});

       

</script>

</body>
</html>